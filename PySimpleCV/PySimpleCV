#!/usr/bin/python3
import os
import io
import sys
import numpy as np 
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg 
from matplotlib.figure import Figure
import PySimpleGUI as sg
import matplotlib 
from matplotlib.lines import Line2D
import pandas as pd
import tarfile
import shutil
matplotlib.use('TkAgg')
from PySimpleCV_main_func import battery_xls2df, get_CV_init, find_state_seq, get_battery_eff, cy_idx_state_range, CV_file2df, get_CV_peak, search_pattern, ir_compen_func, diffusion, reaction_rate, deflection, find_alpha, min_max_peak

# ToDo
# Optimize peak deflection regcognision
# Add option to change electrode area and current unit

if not sys.warnoptions:
    import warnings
    warnings.simplefilter("ignore")

matplotlib.rcParams['figure.dpi'] = 80

def About_PySimpleCV():
    [sg.popup('PySimpleCV written by Kavin Teenakul',
    'License: GPL v3',
    'https://github.com/kevinsmia1939/PySimpleCV',
    'Libraries used:',
    'NumPy - https://numpy.org/',
    'pandas - https://pandas.pydata.org/',
    'Matplotlib - https://matplotlib.org/',
    'PySimpleGUI - https://www.pysimplegui.org',
    'impedance.py - https://impedancepy.readthedocs.io/en/latest/',
    'statsmodels - https://www.statsmodels.org',
    
    'Abbreviation',
    'Jpa - Anodic peak current/current density',
    'Jpc - Cathodic peak current/current density',
    'Epa - Anodic peak potential',
    'Epc - Cathodic peak potential',
    'E\u00bd  - Half-wave potential',
    'ΔE\u209a - Peak-to-peak separation potential',
    'Nicholson method - Nicholson, R. S. Semiempirical Procedure for Measuring with Stationary Electrode Polarography Rates of Chemical Reactions Involving the Product of Electron Transfer. Anal. Chem. 1966, 38 (10), 1406.'
    )]

sg.theme('DarkBlue')

def draw_figure(canvas, figure): 
    figure_canvas_agg = FigureCanvasTkAgg(figure, canvas) 
    figure_canvas_agg.draw() 
    figure_canvas_agg.get_tk_widget().pack(side='top', fill='both', expand=1) 
    return figure_canvas_agg

# Generate layout for CV tab
cv_slider_size = (50,18)
cv_cv=[[sg.Canvas(key='-CANVAS_cv-')]]
cv_diff=[[sg.Canvas(key='-CANVAS_cv_D-')]]
cv_kin =[[sg.Canvas(key='-CANVAS_cv_k-')]]

cv_open_menu = ["Menu",["VersaSTAT4 (.par)", "CorrWare (.cor)", "CSV (.csv)", "text (.txt)"]]
         
cv_settings = [
    [sg.ButtonMenu("Add/Open CV file",cv_open_menu,key='cv_open_menu'),sg.Button("Load saved CV files", key='cv_load_cv'),sg.Combo(values=(), default_value='', readonly=False, key='cv_combo_cv', enable_events=True, size=(30,15)),sg.Button("Delete CV File", disabled=True)],
    [sg.Text('.csv file with voltage on 1st colume and current on 2nd column separated by comma')],
    [sg.Checkbox('Switch anodic and cathodic current', default=False, key='inv_jpa_jpc', disabled=True, enable_events=True),sg.Checkbox('Switch finding max and min peak', default=False, key='inv_peak', disabled=True, enable_events=True)],
    [sg.Text('iR compensation'),sg.Input(default_text=('0'), key='ir_compen',size=(15,5),disabled=True, enable_events=True),sg.Text('Ω'),sg.Text('Electrode area'),sg.Input(default_text=('1'), key='elec_area',size=(15,5),disabled=True, enable_events=True),sg.Text('cm\u00b2'),
     sg.Text('Scan rate'),sg.Input(default_text=('0'), key='scan_rate',size=(15,5),disabled=True, enable_events=True),sg.Text('V')],
    [sg.Text('Trim CV plot start'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_s', disable_number_display=True, enable_events=True, disabled=True)],
    [sg.Text('Trim CV plot end'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_e', enable_events=True, disabled=True)],
    [sg.Text('Start 1'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpa_lns', enable_events=True, disabled=True)],
    [sg.Text('End 1'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpa_lne', enable_events=True, disabled=True)],
    [sg.Text('Start 2'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpc_lns', enable_events=True, disabled=True)],
    [sg.Text('End 2'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpc_lne', enable_events=True, disabled=True)],
    [sg.Text('Peak search range'),sg.Slider(range=(1, 100), size=cv_slider_size, orientation='h', key='peak_range', enable_events=True, disabled=True)],
    [sg.Text('Top peak position'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='peak_pos', enable_events=True, disabled=True), sg.Checkbox('Deflection', default=False, key='peak_defl_bool', disabled=True, enable_events=True)],
    [sg.Text('Bottom peak position'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='trough_pos',  enable_events=True, disabled=True), sg.Checkbox('Deflection', default=False, key='trough_defl_bool', disabled=True, enable_events=True)],
    
    [sg.Frame('Nicholson Method',[   
    [sg.Checkbox('Nicholson method (if baseline cannot be determine)', default=False, key='nicholson_cb', enable_events=True, disabled=True)],
    [sg.Text('Switching potential current (jps0)'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='idx_jsp0', enable_events=True, disabled=True),sg.Text('', key='jsp0_volt')],
    ], key='-frame_nicholson-')],
    
    [sg.Frame('Diffusion Coefficienct and rate of reaction',[   
    [sg.Text('Bulk concentration'),sg.Input(default_text=('0'), key='bulk_conc',size=(15,5),disabled=True, enable_events=True),sg.Text('mol/cm\u00b3'),sg.Text('Number of electrons'),sg.Input(default_text=('1'), key='elec_n',size=(15,5),disabled=True, enable_events=True)],
    [sg.Text('Average anodic alpha'),sg.Input(text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(), key='alpha_ano',size=(15,5),disabled=True, enable_events=True),sg.Text('Average cathodic alpha'),sg.Input(text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(), key='alpha_cat',size=(15,5),disabled=True, enable_events=True)],
    [sg.Text('Ano rev D (cm\u00b2/s)'),sg.Input('', key='d_rev_jpa', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True),sg.Text('Cat rev D (cm\u00b2/s)'),sg.Input('', key='d_rev_jpc', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True)],
    [sg.Text('Ano irr D (cm\u00b2/s)'),sg.Input('', key='d_irr_jpa', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True),sg.Text('Cat irr D (cm\u00b2/s)'),sg.Input('', key='d_irr_jpc', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True)],
    [sg.Text('Ano k (cm/s)'),sg.Input('', key='k_jpa', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True),sg.Text('Cat k (cm/s)'),sg.Input('', key='k_jpc', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True)],
    ], key='-frame_D_k-')],
    
    [sg.Button('Save parameters', key='save_cv_param'),sg.Button('Save plot', key='save_cv'),sg.Button('About PySimpleCV'),sg.Button('Exit', key='exit')]
]
cv_D_k_tab = sg.TabGroup([[sg.Tab('CV', cv_cv), sg.Tab('Diffusion', cv_diff),sg.Tab('Kinetics', cv_kin)]])
             
cv_layout = [
            [sg.Checkbox('Plot Jp vs √scanrate for diffusion', default=False, key='enable_d', disabled=False, enable_events=True),sg.Checkbox('Plot Jp vs Ep-E0 for kinetic', default=False, key='enable_k', disabled=False, enable_events=True)],
            [cv_D_k_tab,sg.Column(cv_settings)],
            [sg.Multiline('',size=(130,8), disabled=True, key = 'cv_results_dis', font=('DejaVu Sans Mono', 12), no_scrollbar=False, horizontal_scroll=True)],  
            ]

cv_ecsa1 =[[sg.Canvas(key='-CANVAS_cv_ecsa-')]]
cv_ecsa2 = [
    [sg.ButtonMenu("Add/Open CV file",cv_open_menu,key='cv_open_menu_ecsa'),sg.Button("Load saved CV files", key='cv_load_ecsa'),sg.Combo(values=(), default_value='', readonly=False, key='cv_combo_ecsa', enable_events=True, size=(30,15)),sg.Button("Delete CV File", disabled=True)],
    [sg.Text('.csv file with voltage on 1st colume and current on 2nd column separated by comma')],
    [sg.Text('iR compensation'),sg.Input(default_text=('0'), key='ir_compen_ecsa',size=(15,5),disabled=True, enable_events=True),sg.Text('Ω'),sg.Text('Electrode area'),sg.Input(default_text=('1'), key='elec_area_ecsa',size=(15,5),disabled=True, enable_events=True),sg.Text('cm\u00b2'),
     sg.Text('Scan rate'),sg.Input(default_text=('0'), key='scan_rate_ecsa',size=(15,5),disabled=True, enable_events=True),sg.Text('V')],
    [sg.Text('Trim CV plot start'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_s_ecsa', disable_number_display=True, enable_events=True, disabled=True)],
    [sg.Text('Trim CV plot end'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_e_ecsa', enable_events=True, disabled=True)],
    [sg.Text('Vertical Line'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_v_ln_ecsa', enable_events=True, disabled=True)],
    [sg.Text('Horizontal Line'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_h_ln_ecsa', enable_events=True, disabled=True)],
    [sg.Text('Peak search range'),sg.Slider(range=(1, 100), size=cv_slider_size, orientation='h', key='peak_range_ecsa', enable_events=True, disabled=False)],
    [sg.Text('Area: voltage x current'),sg.Input(text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(), key='VA_ecsa',size=(15,5),disabled=True, enable_events=True)]
    ]

cv_ecsa_layout = [[sg.Column(cv_ecsa1),sg.Column(cv_ecsa2)]]

# Generate layout for battery cycling tab.
bat_col1=[[sg.Canvas(key='-CANVAS_bat-')]]
bat_col2 = [
    [sg.Button("Open Battery File"),sg.Text('.xls files'),
     sg.Checkbox('Voltage', default=True, key='cb_volt', disabled=True, enable_events=True), 
     sg.Checkbox('Current', default=True, key='cb_current', disabled=True, enable_events=True),
     sg.Checkbox('Efficiencies', default=True, key='cb_eff', disabled=True, enable_events=True),
     sg.Checkbox('Capacities', default=True, key='cb_cap', disabled=True, enable_events=True)],
    [sg.Text('Battery file:'), sg.Text('No Battery file selected', key = 'bat_file_use')],
    [sg.Text('Average voltage efficiency='),sg.Text('', key = 'output_ve'),sg.Text('%')],
    [sg.Text('Average coulombic efficiency='), sg.Text('', key = 'output_ce'),sg.Text('%')],
    [sg.Text('Average energy efficiency='), sg.Text('', key = 'output_ee'),sg.Text('%')],
    [sg.Text('Total number of cycles='), sg.Text('', key= 'tot_cycle')],
    [sg.Text('Voltage, current, energy efficiency(%) for each row of cycle, press ctrl+c to copy')],
    [sg.Text('To copy nicely to spreadsheet software, select space as delimiter and merge delimters.')],
    [sg.Multiline('',size=(90,5), disabled=True, key = 'output_arr')],
    [sg.Text('Cycle start'), sg.Slider(range=(0, 0), size=(50, 8), orientation='h', key='cycle_start', enable_events=True, disabled=False)],
    [sg.Text('Cycle end'), sg.Slider(range=(1, 1), size=(50, 8), orientation='h', key='cycle_end', enable_events=True, disabled=False)],
    [sg.Button('Clear plot',key='bat_clear'),sg.Button('Save plot', key='save_bat'), sg.Button('Exit', key='exit_2')]
    ]          
bat_layout = [[sg.Column(bat_col1),sg.Column(bat_col2)]]

layout = sg.TabGroup([[sg.Tab('CV', cv_layout, key='cv_layout_key'),sg.Tab('CV ECSA', cv_ecsa_layout, key='cv_ecsa_layout_key'),sg.Tab('Battery Cycling', bat_layout, key='bat_layout_key')]], enable_events=True, expand_x=True, expand_y=True)
          
window = sg.Window('PySimpleCV', [[layout]], finalize=True, element_justification='center')

# window.maximize()
canvas_cv = window['-CANVAS_cv-'].tk_canvas
canvas_cv_D = window['-CANVAS_cv_D-'].tk_canvas
canvas_cv_k = window['-CANVAS_cv_k-'].tk_canvas
canvas_cv_ecsa = window['-CANVAS_cv_ecsa-'].tk_canvas
canvas_bat = window['-CANVAS_bat-'].tk_canvas
# canvas_eis = window['-CANVAS_eis-'].tk_canvas

# Generate initial empty plot.
fig_cv = Figure(figsize=(9,9))
ax_cv = fig_cv.add_subplot(111)
ax_cv.set_xlabel("Voltage")
ax_cv.set_ylabel("Current")
ax_cv.grid()

fig_cv_D = Figure(figsize=(9,9))
ax_cv_D = fig_cv_D.add_subplot(111)
ax_cv_D.set_xlabel("Scan rate 1/2")
ax_cv_D.set_ylabel("Jp")
ax_cv_D.grid()

fig_cv_kin = Figure(figsize=(9,9))
ax_cv_kin = fig_cv_kin.add_subplot(111)
ax_cv_kin.set_xlabel("Ep - E0")
ax_cv_kin.set_ylabel("Jp")
ax_cv_kin.grid()

# tight layout push away y label
# fig_cv.tight_layout(pad=2)
fig_agg_cv = draw_figure(canvas_cv, fig_cv)
fig_agg_cv_D = draw_figure(canvas_cv_D, fig_cv_D)
fig_agg_cv_k = draw_figure(canvas_cv_k, fig_cv_kin)

fig_cv_ecsa = Figure(figsize=(9,9))
ax_cv_ecsa = fig_cv_ecsa.add_subplot(111)
ax_cv_ecsa.set_xlabel("Voltage")
ax_cv_ecsa.set_ylabel("Current")
ax_cv_ecsa.grid()

fig_agg_cv_ecsa = draw_figure(canvas_cv_ecsa, fig_cv_ecsa)

fig_bat = Figure(figsize=(10,10))
ax_bat_volt = fig_bat.add_subplot(111)
ax_bat_current = ax_bat_volt.twinx()
ax_bat_eff = ax_bat_volt.twinx()
ax_bat_cap = ax_bat_volt.twinx()
ax_bat_cycle = ax_bat_volt.twiny()
ax_bat_eff.spines.right.set_position(("axes", 1.11))
ax_bat_cap.spines.right.set_position(("axes", 1.21))
ax_bat_volt.set_ylabel("Voltage")
ax_bat_current.set_ylabel("Current")
ax_bat_eff.set_ylabel("Voltage/Coulombic/ Energy Efficiencies")
ax_bat_cap.set_ylabel("Capacity")
ax_bat_cycle.set_xlabel("Cycle")
ax_bat_volt.set_xlabel("Time")
# Create manual legend so we can put them in the same box
volt_leg = Line2D([0], [0], label='Voltage', color='blue', linestyle='-')
current_leg = Line2D([0], [0], label='Current', color='red', linestyle='--')
VE_leg = Line2D([0], [0], label='VE', color='blue', marker='*', linestyle='None')
CE_leg = Line2D([0], [0], label='CE', color='red', marker='.', linestyle='None')
EE_leg = Line2D([0], [0], label='EE', color='green', marker='^', linestyle='None')
cap_leg = Line2D([0], [0], label='Capacity', color='orange', marker='s', linestyle='None')
ax_bat_volt.legend(handles=[volt_leg,current_leg,VE_leg,CE_leg,EE_leg,cap_leg],ncol=6, bbox_to_anchor=(0.5,-0.25),loc='lower center')
ax_bat_cycle.grid()
ax_bat_volt.grid(axis='y')
fig_bat.tight_layout()
fig_agg_bat = draw_figure(canvas_bat, fig_bat)

cycle_start = 1
cycle_end = 1

def clear_battery_plot():
    # function to clear the plot.
    # Reset scrolls and checkboxes
    window['cb_volt'].Update(False)
    window['cb_current'].Update(False)
    window['cb_eff'].Update(False)
    window['cb_volt'].Update(disabled=True)
    window['cb_current'].Update(disabled=True)
    window['cb_eff'].Update(disabled=True)
    window['cycle_start'].Update(range=(0,0))
    window['cycle_end'].Update(range=(1,1))
    window['cycle_start'].Update(disabled=True)
    window['cycle_end'].Update(disabled=True)    
    # Remove existing plot.
    ax_bat_current.cla()
    ax_bat_volt.cla()
    ax_bat_eff.cla()
    ax_bat_cap.cla()
    ax_bat_cycle.cla()
    #Redraw Efficiency axis and labels.
    ax_bat_eff.spines.right.set_position(("axes", 1.11))
    ax_bat_cap.spines.right.set_position(("axes", 1.21))
    ax_bat_volt.set_ylabel("Voltage")
    ax_bat_current.set_ylabel("Current")
    ax_bat_eff.set_ylabel("Voltage/Current/Energy Efficiencies")
    ax_bat_cap.set_ylabel("Capacity")
    ax_bat_cycle.set_xlabel("Cycle")
    ax_bat_volt.set_xlabel("Time")
    # Create manual legend so we can put them in the same box
    volt_leg = Line2D([0], [0], label='Voltage', color='blue', linestyle='-')
    current_leg = Line2D([0], [0], label='Current', color='red', linestyle='--')
    VE_leg = Line2D([0], [0], label='VE', color='blue', marker='*', linestyle='None')
    CE_leg = Line2D([0], [0], label='CE', color='red', marker='.', linestyle='None')
    EE_leg = Line2D([0], [0], label='EE', color='green', marker='^', linestyle='None')
    ax_bat_volt.legend(handles=[volt_leg,current_leg,VE_leg,CE_leg,EE_leg],ncol=5, bbox_to_anchor=(0.5,-0.25),loc='lower center')
    ax_bat_cycle.grid()
    fig_agg_bat.draw()
    
def disable_slider(bool):
    window['sl_cutval_s'].Update(disabled=bool)
    window['sl_cutval_e'].Update(disabled=bool)
    window['sl_jpa_lns'].Update(disabled=bool)
    window['sl_jpa_lne'].Update(disabled=bool)
    window['sl_jpc_lns'].Update(disabled=bool)
    window['sl_jpc_lne'].Update(disabled=bool)
    window['peak_range'].Update(disabled=bool)
    window['peak_pos'].Update(disabled=bool)
    window['trough_pos'].Update(disabled=bool)
    window['inv_jpa_jpc'].Update(disabled=bool)
    window['inv_peak'].Update(disabled=bool)
    window['peak_defl_bool'].Update(disabled=bool)
    window['trough_defl_bool'].Update(disabled=bool)
    window['nicholson_cb'].Update(disabled=bool)
    window['idx_jsp0'].Update(disabled=bool)
    window['Delete CV File'].Update(disabled=bool)
    window['ir_compen'].Update(disabled=bool)
    window['elec_area'].Update(disabled=bool)
    window['scan_rate'].Update(disabled=bool)
    window['bulk_conc'].Update(disabled=bool)
    window['elec_n'].Update(disabled=bool)
    
    window['sl_cutval_s_ecsa'].Update(disabled=bool)
    window['sl_cutval_e_ecsa'].Update(disabled=bool)    
    window['sl_v_ln_ecsa'].Update(disabled=bool)
    window['sl_h_ln_ecsa'].Update(disabled=bool)
    window['peak_range_ecsa'].Update(disabled=bool)

randles_select = True
volt_lst = []
smh_volt_lst = []
smh_curr_lst = []
idx_intc_defl_lst = []
current_lst = []
current_den_lst = []
volt_ir_lst = []
cv_path_lst = []
cv_name_lst = []
cv_size_lst = []
fitting_default = np.array([[0.,0.,0.,0.,0.,0.,1.,1.,1.,0.,0.,0.,1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,1.]])
fitting_save_array = np.zeros((1,fitting_default.size))
cv_name_idx_old = -1 #set to -1 so that cv_name_idx != cv_name_idx_old will trigger the first time
ir_compen_old = 0
elec_area_old = 1
cv_results = pd.DataFrame(columns =  ["file_name", "scan_rate", "Jpa", "Jpc", "Epa", "Epc", "Jpa/Jpc", "E\u00bd", "ΔE\u209a", "alpha_ano", "alpha_cat"])
while True:
    event, values = window.read()
    # print(event, values)
    # print(values[1]) #This print active tab
    match event:
        case 'About PySimpleCV':
            About_PySimpleCV()
            continue
        case 'cv_open_menu' | 'cv_load_cv' | 'cv_combo_cv' | 'inv_jpa_jpc' | 'inv_peak' | 'ir_compen' | 'elec_area' | 'sl_cutval_s' | 'sl_cutval_e' | 'sl_jpa_lns' | 'sl_jpa_lne' |  'sl_jpc_lns' | 'sl_jpc_lne' | 'peak_range' | 'peak_pos' | 'trough_pos' | 'nicholson_cb' | 'idx_jsp0' | 'scan_rate'  | 'bulk_conc'  | 'elec_n' | 'enable_d' | 'enable_k' | 'peak_defl_bool' | 'trough_defl_bool' | 'cv_open_menu_ecsa' | 'cv_load_ecsa' | 'cv_combo_ecsa' | 'sl_v_ln_ecsa' | 'sl_h_ln_ecsa' | 'sl_cutval_s_ecsa' | 'sl_cutval_e_ecsa' | 'peak_range_ecsa':
            if event == 'cv_open_menu' or event == 'cv_load_cv' or event == 'cv_open_menu_ecsa' or event == 'cv_load_ecsa':
                if event == 'cv_load_cv' or event == 'cv_load_ecsa':
                    load_cv_dir = sg.popup_get_file('', no_window=True, file_types=(("All TAR Files", "*.tar"), ("All Files", "*.*")))
                    if load_cv_dir is None or load_cv_dir == '' or load_cv_dir == ():
                        continue
                    temp_path = os.path.splitext(load_cv_dir)[0]+'_temp_pysimplecv'
                    with tarfile.open(load_cv_dir, 'r') as tar:
                        tar.extractall(temp_path)
                    try:
                        fitting_save_array = np.loadtxt(temp_path+'/cv_param.csv', delimiter=',')
                        cv_file_temp = temp_path+'/cv'
                        cv_file_temp_list = os.listdir(cv_file_temp)
                        cv_file_temp_path = [os.path.join(cv_file_temp, file) for file in cv_file_temp_list]
                        cv_file_new = ';'.join(cv_file_temp_path)
                    except FileNotFoundError as file_not_found_error:
                        sg.popup('CV file not found, maybe missing file in TAR archive',file_not_found_error, keep_on_top=True)
                        continue
                    
                    # values['cv_open_menu'] == "VersaSTAT4 (.par)" or values['cv_open_menu_ecsa'] == "VersaSTAT4 (.par)":
                if event == 'cv_open_menu' or event == 'cv_open_menu_ecsa':
                    if values['cv_open_menu'] == "VersaSTAT4 (.par)" or values['cv_open_menu_ecsa'] == "VersaSTAT4 (.par)":
                        cv_format = "VersaSTAT"
                        cv_file_new = sg.popup_get_file('Choose VersaSTAT4 CV file',multiple_files=True)
                    elif values['cv_open_menu'] == "CorrWare (.cor)" or values['cv_open_menu_ecsa'] == "CorrWare (.cor)":
                        cv_format = "CorrWare"
                        cv_file_new = sg.popup_get_file('Choose CorrWare CV file',multiple_files=True)
                    elif values['cv_open_menu'] == "CSV (.csv)" or values['cv_open_menu_ecsa'] == "CSV (.csv)":
                        cv_format = "CSV"
                        cv_file_new = sg.popup_get_file('Choose CSV CV file',multiple_files=True)
                    elif values['cv_open_menu'] == "text (.txt)" or values['cv_open_menu_ecsa'] == "text (.txt)":
                        cv_format = "text"
                        cv_file_new = sg.popup_get_file('Choose text CV file',multiple_files=True)
                # If cancel, close the window, go back to beginning
                if cv_file_new is None or cv_file_new == '' or cv_file_new == ():
                    continue
                try:
                    cv_file_multiple = cv_file_new     
                    for cv_file in cv_file_multiple.split(';'):      
                        cv_name = os.path.basename(cv_file) #Get file name
                        df_CV, file_scan_rate = CV_file2df(cv_file, cv_format)       
                        cv_size, volt, current = get_CV_init(df_CV)
                        
                        window['sl_cutval_s'].Update(range=(0,cv_size-1))
                        window['sl_jpa_lns'].Update(range=(0,cv_size-1))
                        window['sl_jpa_lne'].Update(range=(0,cv_size-1))
                        window['sl_jpc_lns'].Update(range=(0,cv_size-1))
                        window['sl_jpc_lne'].Update(range=(0,cv_size-1))
                        window['peak_range'].Update(range=(1, 100))
                        window['peak_pos'].Update(range=(0, cv_size-1))
                        window['trough_pos'].Update(range=(0, cv_size-1))
                        window['idx_jsp0'].Update(range=(0, cv_size-1))
                        
                        window['sl_cutval_s_ecsa'].Update(range=(0,cv_size-1))
                        window['sl_v_ln_ecsa'].Update(range=(0,cv_size-1))
                        window['sl_h_ln_ecsa'].Update(range=(0,cv_size-1))
                        window['peak_range_ecsa'].Update(range=(1,100))
                        
                        
                        cv_path_lst.append(cv_file) #Create 2D array of CVs so we can select, plot, and analyze data based on index
                        cv_name_lst.append(cv_name)
                        volt_lst.append(volt)
                        current_lst.append(current)
                        volt_ir_lst.append(volt) #Append volt to ir compensated volt, this is like ir=0
                        current_den_lst.append(current) # This is like elec_area = 1
                        cv_size_lst.append(cv_size)
                        
                        # deflection and Peak detection
                        _, idx_intc_defl = deflection(cv_size,volt,current)
                        idx_intc_defl_lst.append(idx_intc_defl)
                        
                        ###############################################################################
                        # Add new value from the CV file to save data array
                        fitting_default[:,1] = cv_size
                        fitting_default[:,19] = cv_size 
                        fitting_default[:,16] = file_scan_rate
                        fitting_save_array = np.append(fitting_save_array,fitting_default,axis=0)
                        ###############################################################################
                        
                        window['cv_combo_cv'].Update(values=cv_name_lst) # Update combo list of CVs
                        window['cv_combo_cv'].Update(cv_name) # Update default combo display
                        values['cv_combo_cv'] = cv_name
                        window['cv_combo_ecsa'].Update(values=cv_name_lst) # Update combo list of CVs
                        window['cv_combo_ecsa'].Update(cv_name) # Update default combo display
                        values['cv_combo_ecsa'] = cv_name
                        disable_slider(False)
                        cv_select = cv_name    
                        cv_name_idx = cv_name_lst.index(cv_select)
                        cv_results.loc[cv_name_idx] = [cv_select, file_scan_rate, '0', '0', '0', '0', '0', '0', '0', '0', '0']
                except Exception as file_error:
                    sg.popup(file_error, keep_on_top=True)
                    continue
            if values[1] == 'cv_layout_key':
                cv_select = values['cv_combo_cv']
                if values['cv_combo_cv'] == '': #Prevent error when combo box value is empty
                    cv_name_idx = 0
                else:
                    cv_name_idx = cv_name_lst.index(cv_select)
            elif values[1] == 'cv_ecsa_layout_key':
                cv_select = values['cv_combo_ecsa']
                if values['cv_combo_ecsa'] == '': #Prevent error when combo box value is empty
                    cv_name_idx = 0
                else:
                    cv_name_idx = cv_name_lst.index(cv_select)
            
            # if values['cv_combo'] == '': #Prevent error when combo box value is empty
            #     cv_name_idx = 0
            # else:
            #     cv_name_idx = cv_name_lst.index(cv_select)

            volt = volt_lst[cv_name_idx]
            current = current_lst[cv_name_idx]
            cv_size = cv_size_lst[cv_name_idx]
            idx_arr = np.arange(0,cv_size)
            
            # Deflection points
            idx_defl_points = np.array(idx_intc_defl_lst[cv_name_idx])  

            window['sl_cutval_s'].Update(range=(0,cv_size-1))
            window['sl_cutval_e'].Update(range=(0,cv_size-1))
            window['sl_jpa_lns'].Update(range=(0,cv_size-1))
            window['sl_jpa_lne'].Update(range=(0,cv_size-1))
            window['sl_jpc_lns'].Update(range=(0,cv_size-1))
            window['sl_jpc_lne'].Update(range=(0,cv_size-1))
            window['peak_range'].Update(range=(1, 100))
            window['peak_pos'].Update(range=(1, cv_size-1))
            window['trough_pos'].Update(range=(1, cv_size-1))
            window['idx_jsp0'].Update(range=(1, cv_size-1))
            window['sl_cutval_s_ecsa'].Update(range=(0,cv_size-1))
            window['sl_cutval_e_ecsa'].Update(range=(0,cv_size-1))
            window['sl_v_ln_ecsa'].Update(range=(0,cv_size-1))
            window['sl_h_ln_ecsa'].Update(range=(0,cv_size-1))
            window['peak_range_ecsa'].Update(range=(1,100))

            if cv_name_idx != cv_name_idx_old: #If the option index change (combo box change), update slider
                cv_name_idx_old = cv_name_idx
                # Restore saved values
                cutval_s_save = int(fitting_save_array[cv_name_idx+1,0])
                cutval_e_save = int(fitting_save_array[cv_name_idx+1,1])
                jpa_lns_save = int(fitting_save_array[cv_name_idx+1,2])
                jpa_lne_save = int(fitting_save_array[cv_name_idx+1,3])
                jpc_lns_save = int(fitting_save_array[cv_name_idx+1,4])
                jpc_lne_save = int(fitting_save_array[cv_name_idx+1,5])
                peak_pos_save = int(fitting_save_array[cv_name_idx+1,6])
                trough_pos_save = int(fitting_save_array[cv_name_idx+1,7])
                peak_range_save = int(fitting_save_array[cv_name_idx+1,8])
                ir_compen_save = float(fitting_save_array[cv_name_idx+1,9])
                peak_defl_bool_save = bool(fitting_save_array[cv_name_idx+1,10])
                trough_defl_bool_save = bool(fitting_save_array[cv_name_idx+1,11])
                elec_area_save = int(fitting_save_array[cv_name_idx+1,12])
                idx_jsp0_save = int(fitting_save_array[cv_name_idx+1,13])
                inv_jpa_jpc_save = int(fitting_save_array[cv_name_idx+1,14])
                inv_peak_save = int(fitting_save_array[cv_name_idx+1,15])
                scan_rate_save = float(fitting_save_array[cv_name_idx+1,16])
                nicholson_cb_save = float(fitting_save_array[cv_name_idx+1,17])

                cutval_s_ecsa_save = int(fitting_save_array[cv_name_idx+1,18])
                cutval_e_ecsa_save = int(fitting_save_array[cv_name_idx+1,19])               
                v_ln_ecsa_save = int(fitting_save_array[cv_name_idx+1,20])
                h_ln_ecsa_save = int(fitting_save_array[cv_name_idx+1,21])
                peak_range_ecsa_save = int(fitting_save_array[cv_name_idx+1,22])
                # Put slider to previous position
                window['sl_cutval_s'].Update(cutval_s_save)
                window['sl_cutval_e'].Update(cutval_e_save)
                window['sl_jpa_lns'].Update(jpa_lns_save)
                window['sl_jpa_lne'].Update(jpa_lne_save)
                window['sl_jpc_lns'].Update(jpc_lns_save)
                window['sl_jpc_lne'].Update(jpc_lne_save)
                window['peak_pos'].Update(peak_pos_save)
                window['trough_pos'].Update(trough_pos_save)
                window['peak_range'].Update(peak_range_save)
                window['ir_compen'].Update(ir_compen_save)
                window['peak_defl_bool'].Update(peak_defl_bool_save)
                window['trough_defl_bool'].Update(trough_defl_bool_save)
                window['elec_area'].Update(elec_area_save)
                window['idx_jsp0'].Update(idx_jsp0_save)
                window['inv_jpa_jpc'].Update(inv_jpa_jpc_save)
                window['inv_peak'].Update(inv_peak_save)
                window['scan_rate'].Update(scan_rate_save)
                window['nicholson_cb'].Update(nicholson_cb_save)
                
                window['sl_cutval_s_ecsa'].Update(cutval_s_ecsa_save)
                window['sl_cutval_e_ecsa'].Update(cutval_e_ecsa_save)
                window['sl_v_ln_ecsa'].Update(v_ln_ecsa_save)
                window['sl_h_ln_ecsa'].Update(h_ln_ecsa_save)
                window['peak_range_ecsa'].Update(peak_range_ecsa_save)
                # Assign the value from saved data
                cutval_s = cutval_s_save
                cutval_e = cutval_e_save
                jpa_lns = jpa_lns_save
                jpa_lne = jpa_lne_save
                jpc_lns = jpc_lns_save
                jpc_lne = jpc_lne_save
                peak_pos = peak_pos_save
                trough_pos = trough_pos_save
                peak_range = peak_range_save
                ir_compen = ir_compen_save
                peak_defl_bool = peak_defl_bool_save
                trough_defl_bool = trough_defl_bool_save
                elec_area = elec_area_save
                idx_jsp0 = idx_jsp0_save
                inv_jpa_jpc = inv_jpa_jpc_save
                inv_peak = inv_peak_save
                scan_rate = scan_rate_save
                nicholson_cb = nicholson_cb_save
                cutval_s_ecsa = cutval_s_ecsa_save
                cutval_e_ecsa = cutval_e_ecsa_save
                v_ln_ecsa = v_ln_ecsa_save
                h_ln_ecsa = h_ln_ecsa_save
                peak_range_ecsa = peak_range_ecsa_save
            elif cv_name_idx == cv_name_idx_old: #If combobox does not change, simply read value from slider
                cutval_s = int(values['sl_cutval_s'])
                cutval_e = int(values['sl_cutval_e'])
                jpa_lns = int(values['sl_jpa_lns'])
                jpa_lne = int(values['sl_jpa_lne'])
                jpc_lns = int(values['sl_jpc_lns'])
                jpc_lne = int(values['sl_jpc_lne'])
                peak_pos = int(values['peak_pos'])
                trough_pos = int(values['trough_pos'])
                peak_range = int(values['peak_range'])
                peak_defl_bool = int(values['peak_defl_bool'])
                trough_defl_bool = int(values['trough_defl_bool'])
                idx_jsp0 = int(values['idx_jsp0'])
                inv_jpa_jpc = int(values['inv_jpa_jpc'])
                inv_peak = int(values['inv_peak'])
                nicholson_cb = int(values['nicholson_cb'])
                
                cutval_s_ecsa = int(values['sl_cutval_s_ecsa'])
                cutval_e_ecsa = int(values['sl_cutval_e_ecsa'])
                v_ln_ecsa = int(values['sl_v_ln_ecsa'])
                h_ln_ecsa = int(values['sl_h_ln_ecsa'])
                peak_range_ecsa = int(values['peak_range_ecsa'])
                
                # Only accept float value from ir compensation
                try:
                    ir_compen = float(values['ir_compen'])
                except ValueError:
                    ir_compen = float(0)
                    
                try:
                    scan_rate = float(values['scan_rate'])
                except ValueError:
                    scan_rate = float(0)    
                   
                try:
                    elec_area = float(values['elec_area'])
                except ValueError:
                    elec_area = float(1)
                # print(cutval_e) 
                # print(cutval_e_ecsa,h_ln_ecsa) 
                fitting_save = np.array([cutval_s, cutval_e, jpa_lns, jpa_lne, jpc_lns, jpc_lne, peak_pos, trough_pos, peak_range, ir_compen, peak_defl_bool, trough_defl_bool,elec_area, idx_jsp0, inv_jpa_jpc, inv_peak, scan_rate, nicholson_cb, cutval_s_ecsa, cutval_e_ecsa, v_ln_ecsa, h_ln_ecsa, peak_range_ecsa]) 
                fitting_save_array[cv_name_idx+1] = fitting_save
            
            if ir_compen != ir_compen_old:
                ir_compen_old = ir_compen
                volt_compen = ir_compen_func(volt,current,ir_compen)
                # Overwrite volt and curr with ir compen
                volt_ir_lst[cv_name_idx] = volt_compen
            else:
                volt_compen = volt_ir_lst[cv_name_idx]
            
            if elec_area != elec_area_old:
                elec_area_old = elec_area
                current_den = current/elec_area
                # Overwrite current with current density
                current_den_lst[cv_name_idx] = current_den
            else:
                current_den = current_den_lst[cv_name_idx]
            
            # Switch slider when it cross
            if jpa_lns >= jpa_lne:
                jpa_lne_old = jpa_lne
                jpa_lne = jpa_lns
                jpa_lns = jpa_lne_old
            if jpc_lns >= jpc_lne:
                jpc_lne_old = jpc_lne
                jpc_lne = jpc_lns
                jpc_lns = jpc_lne_old  
                
            # if v_ln_ecsa >= h_ln_ecsa:
            #     h_ln_ecsa_old = h_ln_ecsa
            #     h_ln_ecsa = v_ln_ecsa
            #     v_ln_ecsa = h_ln_ecsa_old   
            
            if peak_defl_bool == 1:
                peak_pos = idx_defl_points[np.abs(idx_defl_points - peak_pos).argmin()]
                peak_pos = int(peak_pos)
            else:
                peak_defl_bool = 0
            if trough_defl_bool == 1:
                trough_pos = idx_defl_points[np.abs(idx_defl_points - trough_pos).argmin()]
                trough_pos = int(trough_pos)
            else:
                trough_defl_bool = 0
                
            if values[1] == 'cv_layout_key':
                ax_cv.cla() ###### Clear plot before redraw
                if nicholson_cb == True:
                    if values['inv_jpa_jpc'] == True: 
                        jp1_text = 'jpc'
                        jp2_text = 'jpa0'
                    else:
                        jp1_text = 'jpa'
                        jp2_text = 'jpc0'
                    jpc0_lns = jpa_lns
                    jpc0_lne = jpa_lne
                    low_range_peak, high_range_peak, peak_volt, peak_curr, low_range_trough, high_range_trough, trough_volt, trough_curr, jpa, jpc0, jpa_poly1d, _ = get_CV_peak(inv_peak, cv_size, volt_compen, current_den, peak_range, peak_pos, trough_pos, jpa_lns, jpa_lne, jpc0_lns, jpc0_lne, peak_defl_bool, trough_defl_bool)
                    
                    # Find estimate standard electrode potential (E1/2~E0)
                    E1_2 = (trough_volt+peak_volt)/2
                    ax_cv.plot(E1_2,0,"D", markersize = 6)
                
                    ax_cv.plot((volt_compen[low_range_peak],volt_compen[high_range_peak]),(current_den[low_range_peak],current_den[high_range_peak]),"|", markersize = 10)
                    ax_cv.plot((volt_compen[low_range_trough],volt_compen[high_range_trough]),(current_den[low_range_trough],current_den[high_range_trough]),"|", markersize = 10)
                
                    ax_cv.plot(np.array([volt_compen[jpa_lns],peak_volt]),np.array([jpa_poly1d(volt_compen[jpa_lns]),jpa_poly1d(peak_volt)]),'--', color='green') #Peak
                    ax_cv.plot(np.array([volt_compen[jpa_lns],trough_volt]),np.array([jpa_poly1d(volt_compen[jpa_lns]),jpa_poly1d(trough_volt)]),'--', color='green') #Peak    
                    ax_cv.arrow(trough_volt,jpa_poly1d(trough_volt),0,-jpc0,linewidth=0.2,head_width=0.005, head_length=0.0003 ,color='green', length_includes_head=True) #jpc0 
                    ax_cv.arrow(peak_volt,jpa_poly1d(peak_volt),0,jpa,linewidth=0.2,head_width=0.005, head_length=0.0003, color='black', length_includes_head=True) #jpa
    
                    jsp0_volt = volt_compen[idx_jsp0]
                    jsp0 = current_den[idx_jsp0]-jpa_poly1d(jsp0_volt)
                    ax_cv.plot(np.array([volt_compen[jpa_lns],volt_compen[idx_jsp0]]),np.array([jpa_poly1d(volt_compen[jpa_lns]),jpa_poly1d(jsp0_volt)]),'--', color='green') #jsp0
                    ax_cv.plot(volt_compen[jpa_lns:jpa_lne],current_den[jpa_lns:jpa_lne],linewidth=3,linestyle='-', color='blue')
                    ax_cv.arrow(volt_compen[idx_jsp0],jpa_poly1d(jsp0_volt),0,jsp0,linewidth=0.2,head_width=0.005, head_length=0.0003, color='b', length_includes_head=True) #jsp0
                    
                    ax_cv.text(peak_volt,jpa_poly1d(peak_volt), jp1_text, fontsize=10)
                    ax_cv.text(trough_volt,jpa_poly1d(trough_volt), jp2_text, fontsize=10)
                    ax_cv.text(volt_compen[idx_jsp0],jpa_poly1d(jsp0_volt), 'jsp0', fontsize=10)
                    
                    jpa = np.abs(jpa)
                    jpc0 = np.abs(jpc0)
                    jsp0 = np.abs(jsp0)
                    # Nicholson, R. S. Semiempirical Procedure for Measuring with
                    # Stationary Electrode Polarography Rates of Chemical Reactions
                    # Involving the Product of Electron Transfer. Anal. Chem. 1966, 38
                    # (10), 1406.
                    jpc = jpa*((jpc0/jpa)+((0.485*np.abs(jsp0))/jpa)+0.086)
                        
                    window['jsp0_volt'].Update(jsp0_volt)
                elif nicholson_cb == False:
                    low_range_peak, high_range_peak, peak_volt, peak_curr, low_range_trough, high_range_trough, trough_volt, trough_curr, jpa, jpc, jpa_poly1d, jpc_poly1d = get_CV_peak(inv_peak,cv_size, volt_compen, current_den, peak_range, peak_pos, trough_pos, jpa_lns, jpa_lne, jpc_lns, jpc_lne, peak_defl_bool, trough_defl_bool)
                    
                    # Find alpha
                    ep12_jpa, jp12_jpa, alpha_jpa, ep12_jpc, jp12_jpc, alpha_jpc = find_alpha(volt_compen,current_den,jpa_lns,jpc_lns,peak_pos,trough_pos,jpa_poly1d,jpc_poly1d,jpa,jpc,peak_volt,trough_volt)
                    ax_cv.plot(ep12_jpa,jp12_jpa,'x')
                    ax_cv.plot(ep12_jpc,jp12_jpc,'x')
                    
                    # Find estimate standard electrode potential (E1/2~E0)
                    E1_2 = (trough_volt+peak_volt)/2
                    ax_cv.plot(E1_2,0,"D", markersize = 6)
                    
                    
                    ax_cv.plot((volt_compen[low_range_peak],volt_compen[high_range_peak]),(current_den[low_range_peak],current_den[high_range_peak]),"|", markersize = 10)
                    ax_cv.plot((volt_compen[low_range_trough],volt_compen[high_range_trough]),(current_den[low_range_trough],current_den[high_range_trough]),"|", markersize = 10)
                
                    ax_cv.plot(volt_compen[jpa_lns:jpa_lne],current_den[jpa_lns:jpa_lne],linewidth=2,linestyle='-', color='red')
                    ax_cv.arrow(peak_volt,jpa_poly1d(peak_volt),0,jpa,linewidth=0.2,head_width=0.005, head_length=0.0003 ,color='r', length_includes_head=True)
                    ax_cv.plot(np.array([volt_compen[jpa_lns],peak_volt]),np.array([jpa_poly1d(volt_compen[jpa_lns]),jpa_poly1d(peak_volt)]),'--', color='red')
                    
                    ax_cv.plot(volt_compen[jpc_lns:jpc_lne],current_den[jpc_lns:jpc_lne],linewidth=2,linestyle='-',color='blue')
                    ax_cv.arrow(trough_volt,jpc_poly1d(trough_volt),0,-jpc,linewidth=0.2,head_width=0.005, head_length=0.0003, color='b', length_includes_head=True)
                    ax_cv.plot(np.array([volt_compen[jpc_lns],trough_volt]),np.array([jpc_poly1d(volt_compen[jpc_lns]),jpc_poly1d(trough_volt)]),'--', color='blue')
                   
                # invert jpa and jpc or not
                if values['inv_jpa_jpc'] == True:
                    jpa, jpc = jpc, jpa
                    alpha_jpa, alpha_jpc = alpha_jpc, alpha_jpa
                    
                # Find peak-peak separation voltage
                delta_e = np.abs(trough_volt-peak_volt)
                # Start plotting
                volt_lst_len = len(volt_lst)
                for j in np.arange(0,volt_lst_len):
                    cutval_s_all = int(fitting_save_array[j+1,0])
                    cutval_e_all = int(fitting_save_array[j+1,1])
                    ax_cv.plot(np.array(volt_ir_lst[j][cutval_s_all:cutval_e_all]).T, np.array(current_den_lst[j][cutval_s_all:cutval_e_all]).T, '-', color='black',linewidth=0.8)
                
                if peak_defl_bool == 1 or trough_defl_bool == 1:
                    clip_defl = idx_defl_points[(idx_defl_points >= cutval_s) & (idx_defl_points <= cutval_e)]
                    volt_defl = np.interp([clip_defl], idx_arr, volt_compen)
                    curr_defl = np.interp([clip_defl], idx_arr, current_den)
              
                    ax_cv.plot(volt_defl,curr_defl,'.',color='green')
                ax_cv.grid()
                ax_cv.set_xlabel("Voltage")
                ax_cv.set_ylabel("Current")  
                
                fig_agg_cv.draw()
                cv_results.loc[cv_name_idx] = [cv_select, scan_rate, jpa, jpc, peak_volt, trough_volt, jpa/jpc, E1_2, delta_e, alpha_jpa, alpha_jpc]
                cv_results = cv_results.sort_index()
                window['cv_results_dis'].Update(cv_results.to_string(index=False))
                
            if values[1] == 'cv_ecsa_layout_key':
                ax_cv_ecsa.cla() ###### Clear plot before redraw
                volt_lst_len = len(volt_lst)
                for j in np.arange(0,volt_lst_len):
                    cutval_s_ecsa_all = int(fitting_save_array[j+1,18])
                    cutval_e_ecsa_all = int(fitting_save_array[j+1,19])
                    ax_cv_ecsa.plot(np.array(volt_ir_lst[j][cutval_s_ecsa_all:cutval_e_ecsa_all]).T, np.array(current_den_lst[j][cutval_s_ecsa_all:cutval_e_ecsa_all]).T, '-', color='black',linewidth=0.8)
                
                search_mode = 'max'
                high_range_peak, low_range_peak, peak_volt, peak_curr, peak_real_idx = min_max_peak(search_mode, cv_size, volt, current, peak_range_ecsa, v_ln_ecsa)
                
                ax_cv_ecsa.plot((volt_compen[low_range_peak],volt_compen[high_range_peak]),(current_den[low_range_peak],current_den[high_range_peak]),"|", markersize = 10)
                
                ax_cv_ecsa.hlines(y=current_den[h_ln_ecsa], xmin=peak_volt, xmax=volt_compen[h_ln_ecsa], linewidth=2, color='r', linestyle='--')
                ax_cv_ecsa.vlines(x=peak_volt, ymin=peak_curr, ymax=current_den[h_ln_ecsa], linewidth=2, color='r', linestyle='--')

                # Switch position for fill_between and np.trapz
                # b is always larger than a
                if peak_real_idx > h_ln_ecsa:
                    a = h_ln_ecsa
                    b = peak_real_idx
                else:
                    b = h_ln_ecsa
                    a = peak_real_idx
                    
                ax_cv_ecsa.fill_between(volt_compen[a:b], current_den[h_ln_ecsa],current_den[a:b],color='orange')
                ax_cv_ecsa.grid()
                ax_cv_ecsa.set_xlabel("Voltage")
                ax_cv_ecsa.set_ylabel("Current")  
                fig_agg_cv_ecsa.draw()

                volt_ecsa = volt_compen[a:b]
                curr_ecsa = current_den[a:b]

                cv_ecsa_area = abs(np.trapz(curr_ecsa,volt_ecsa))
                sq_area = abs(current_den[h_ln_ecsa] * (volt_compen[h_ln_ecsa]-peak_volt))
                VA_area = abs(cv_ecsa_area-sq_area)
                window['VA_ecsa'].Update(f"{VA_area:e}")
                
            # Read value from Input box, does not matter what CV it is.
            # Find Diffusion Coefficient
            try:
                bulk_conc = float(values['bulk_conc'])
            except ValueError:
                bulk_conc = float(0)             
                
            try:
                elec_n = int(values['elec_n'])
            except ValueError:
                elec_n = int(1)
                
            alpha_ano = np.average(np.asarray(cv_results.loc[:,'alpha_ano'].to_numpy(), dtype=float))
            alpha_cat = np.average(np.asarray(cv_results.loc[:,'alpha_cat'].to_numpy(), dtype=float))
            window['alpha_ano'].Update(alpha_ano)
            window['alpha_cat'].Update(alpha_cat)    
                
            if values['enable_d'] == True:
                scan = np.array([float(value) for value in cv_results['scan_rate']])
                # scan = scan/1000 #convert mV to V
                jpc_arr = np.asarray(cv_results.loc[:,'Jpc'].to_numpy(), dtype=float)
                jpa_arr = np.asarray(cv_results.loc[:,'Jpa'].to_numpy(), dtype=float)

                # Plot peak current vs scan rate^1/2 to find diffusion coefficient
                ax_cv_D.cla()
                try:
                    sqrt_scan, jpa_fit ,D_irr_a ,D_rev_a ,r2 = diffusion(scan,jpa_arr,alpha_ano,bulk_conc,elec_n)
                    sqrt_scan, jpc_fit ,D_irr_c ,D_rev_c ,r2 = diffusion(scan,jpc_arr,alpha_cat,bulk_conc,elec_n)
                    ax_cv_D.plot(sqrt_scan,jpa_fit,'-',color='red')
                    ax_cv_D.plot(sqrt_scan,jpc_fit,'-',color='blue')
                    window['d_rev_jpa'].Update(f"{D_rev_a:e}")
                    window['d_rev_jpc'].Update(f"{D_rev_c:e}")
                    window['d_irr_jpa'].Update(f"{D_irr_a:e}")
                    window['d_irr_jpc'].Update(f"{D_irr_c:e}")
                except SystemError:
                    pass
                ax_cv_D.plot(sqrt_scan,jpa_arr,'o',color='red',label='Jpa')
                ax_cv_D.plot(sqrt_scan,jpc_arr,'o',color='blue',label='Jpc')
                ax_cv_D.set_xlabel("Scan rate 1/2")
                ax_cv_D.set_ylabel("Jp")
                fig_cv_D.legend()
                fig_agg_cv_D.draw()
            #Find kinetic parameter
            if values['enable_k'] == True:       
                e_e0_arr = (np.array([float(value) for value in cv_results['ΔE\u209a']]))/2
                ax_cv_kin.cla()
                try: 
                    lnjpa, lnjpa_fit, k0_a, alpha_cat_a, alpha_ano_a, r2_a = reaction_rate(e_e0_arr,jpa_arr,bulk_conc,elec_n)
                    lnjpc, lnjpc_fit, k0_c, alpha_cat_c, alpha_ano_c, r2_c = reaction_rate(e_e0_arr,jpc_arr,bulk_conc,elec_n)
                    ax_cv_kin.plot(e_e0_arr,lnjpa_fit,'-',color='red')
                    ax_cv_kin.plot(e_e0_arr,lnjpc_fit,'-',color='blue')
                    window['k_jpa'].Update(f"{k0_a:e}")
                    window['k_jpc'].Update(f"{k0_c:e}")
                except SystemError:
                    pass            
                ax_cv_kin.plot(e_e0_arr,lnjpa,'o',color='red',label='Jpa')
                ax_cv_kin.plot(e_e0_arr,lnjpc,'o',color='blue',label='Jpc')
                ax_cv_kin.set_xlabel("Ep - E0")
                ax_cv_kin.set_ylabel("Jp")
                fig_cv_kin.legend()
                fig_agg_cv_k.draw()
        case 'save_cv_param':
            save_cv_dir = sg.popup_get_file('', save_as=True, no_window=True, file_types=(("All TAR Files", "*.tar"), ("All Files", "*.*")))
            if save_cv_dir is None or save_cv_dir == '' or save_cv_dir == ():
                continue
            with tarfile.open(save_cv_dir, 'w') as tar:
                csv_buffer = io.BytesIO()
                np.savetxt(csv_buffer, fitting_save_array, delimiter=',')
                csv_buffer.seek(0)
                tarinfo = tarfile.TarInfo('cv_param'+'.csv')
                tarinfo.size = len(csv_buffer.getvalue())
                tar.addfile(tarinfo, fileobj=csv_buffer)
                for cv_file in cv_path_lst:
                    arcname = os.path.basename(cv_file)
                    tar.add(cv_file, arcname='cv/'+str(arcname))
            tar.close()
        case 'Delete CV File':
            del current_lst[cv_name_idx]
            del current_den_lst[cv_name_idx]
            del cv_name_lst[cv_name_idx]
            del cv_path_lst[cv_name_idx]
            del cv_size_lst[cv_name_idx]
            del idx_intc_defl_lst[cv_name_idx]
            del smh_volt_lst[cv_name_idx]
            del smh_curr_lst[cv_name_idx]
            del volt_lst[cv_name_idx]
            del volt_ir_lst[cv_name_idx]           
            fitting_save_array = np.delete(fitting_save_array,1+cv_name_idx,0)
            cv_results = cv_results.drop([cv_name_idx])
            cv_results.reset_index(inplace=True)
            cv_results = cv_results.drop('index',axis=1)
            
            # If the deleted data is the last in the list, when delete, the cv_name_idx must be substract to refer to data below it.
            if len(cv_name_lst)-1 < cv_name_idx: 
                cv_name_idx = cv_name_idx - 1
                    
            if cv_results.empty: # If dataframe empty, just put nothing in display
                window['cv_results_dis'].Update('')
            else:
                window['cv_results_dis'].Update(cv_results.to_string(index=False))
            
            window['cv_combo'].Update(values=cv_name_lst)
            
            if len(cv_name_lst) == 0: # If CV all delete, make combo empty and disable slider
                window['cv_combo'].Update()
                disable_slider(True)
                window['Delete CV File'].Update(disabled=True) # Disable delete button if empty
                window['cv_combo'].Update('')
                values['cv_combo'] = ''
                continue
            elif len(cv_name_lst) >= 1:
                window['cv_combo'].Update(cv_name_lst)     
                cv_select = cv_name_lst[cv_name_idx]
                window['cv_combo'].Update(cv_select)
                values['cv_combo'] = cv_select
        case 'save_cv':
            save_cv_loc = sg.popup_get_file('Create of choose a file (PNG) to save to', save_as=True)
            if save_cv_loc is None or save_cv_loc == '' or save_cv_loc == ():
                continue
            fig_cv.savefig(save_cv_loc)
        case 'Open Battery File':
            bat_file_new = sg.popup_get_file('Choose battery cycle file (.xls)')
            # If cancel, close the window, go back to beginning
            # If empty, use old file
            if bat_file_new is None or bat_file_new == '' or bat_file_new == ():
                continue
            try:
                clear_battery_plot()
                bat_file = bat_file_new
                df_bat, row_size, time_df, volt_df, current_df, capacity_df, state_df = battery_xls2df(bat_file)
    
                # Voltage difference with current interrupt method between C_CC and R
                CIM_idx = search_pattern(list(state_df), ['C_CC','R'])
                CIM_volt_drop_lst = []
                for i in CIM_idx:
                    CIM_volt_drop = volt_df[i]-volt_df[i+1]
                    CIM_volt_drop_lst.append(CIM_volt_drop)              
                # Sequence information
                charge_CC_seq, discharge_CC_seq, rest_seq, charge_CV_seq, discharge_CV_seq = find_state_seq(state_df)
                VE_arr, CE_arr, EE_arr, charge_cap_arr, discharge_cap_arr, tot_cycle_number = get_battery_eff(row_size, time_df, volt_df, current_df, capacity_df, state_df, charge_CC_seq, discharge_CC_seq)
                
                VE_avg = np.average(VE_arr[0:cycle_end])
                CE_avg = np.average(CE_arr[0:cycle_end])
                EE_avg = np.average(EE_arr[0:cycle_end])
                charge_cap_avg = np.average(charge_cap_arr[0:cycle_end])
                discharge_cap_avg = np.average(discharge_cap_arr[0:cycle_end]) 
                #For display table
                df_display=pd.DataFrame([charge_cap_arr,discharge_cap_arr,VE_arr,CE_arr,EE_arr]) # Create dataframe to display in multiline output
                df_display=df_display.T
                df_display.columns = ['Charge-Capacity','Discharge-Capacity','VE', 'CE', 'EE']
                df_display.index = df_display.index + 1 # Start index at 1 for nice looking
                
                window['cycle_end'].Update(disabled=False)
                window['cycle_start'].Update(disabled=False)
                window['cb_volt'].Update(disabled=False)
                window['cb_current'].Update(disabled=False)
                window['cb_eff'].Update(disabled=False)
                window['cb_cap'].Update(disabled=False)
                window['cb_volt'].Update(True)
                window['cb_current'].Update(True)
                window['cb_eff'].Update(True)
                window['cycle_start'].Update(range=(0,tot_cycle_number-1))
                window['cycle_end'].Update(range=(1,tot_cycle_number))
                window['bat_file_use'].Update(bat_file)
                window['output_arr'].Update(df_display.to_string()) # Make sure to print all lines
                window['tot_cycle'].Update(tot_cycle_number) 
                window['output_ve'].Update(np.round(VE_avg,3))
                window['output_ce'].Update(np.round(CE_avg,3))
                window['output_ee'].Update(np.round(EE_avg,3))
                
                volt_line, = ax_bat_volt.plot(time_df, volt_df, '-', label='Voltage', color='blue')
                current_line, = ax_bat_current.plot(time_df, current_df, '--', label='Current', color='red')
                
                cycle_idx = (charge_CC_seq)[:,1]
    
                cycle_idx = cycle_idx[0:min((charge_CC_seq)[:,1].size,(discharge_CC_seq)[:,1].size)]
                time_cycle = time_df[cycle_idx]
                VE_marker, = ax_bat_eff.plot(time_df[cycle_idx], VE_arr, '*',color='blue',label='VE', markersize=8)
                CE_marker, = ax_bat_eff.plot(time_df[cycle_idx], CE_arr, '.',color='red',label='CE', markersize=8)
                EE_marker, = ax_bat_eff.plot(time_df[cycle_idx], EE_arr, '^',color='green',label='EE', markersize=4)              
                charge_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], charge_cap_arr, 's',color='orange',label='capacity', markersize=4)
                dis_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], discharge_cap_arr, 'x',color='brown',label='capacity', markersize=4)
                CIM_marker, = ax_bat_volt.plot(time_df[cycle_idx], np.array(CIM_volt_drop_lst)/0.65, 'o',color='blue',label='CIM', markersize=4)
                
                ax_bat_volt.autoscale()
                ax_bat_current.autoscale()
                ax_bat_eff.autoscale()
                ax_bat_cap.autoscale()
                # Set limit and ticks of bat_cycle
                # Match cycle scale to time scale and plot efficiency.
                cycle_plot = np.arange(0,tot_cycle_number,10)
                ax_bat_cycle.set_xticks(cycle_plot)
                ax_bat_cycle.set_xlim(left=0,right=tot_cycle_number)
                
                # Set limit for efficiencies
                ax_bat_eff.set_ylim(0,100)
                
                ax_bat_volt.set_xlim(left=0,right=max(time_df))
    
                ax_bat_cycle.grid()
                ax_bat_volt.grid(axis='y')
                fig_agg_bat.draw()
            except Exception as file_error:
                sg.popup(file_error, keep_on_top=True)
        case 'cb_eff':
            if values['cb_eff'] == False:
                VE_marker.remove()
                CE_marker.remove()
                EE_marker.remove()
            else:
                VE_marker, = ax_bat_eff.plot(time_df[cycle_idx], VE_arr, '*',color='blue',label='VE', markersize=8)
                CE_marker, = ax_bat_eff.plot(time_df[cycle_idx], CE_arr, '.',color='red',label='CE', markersize=8)
                EE_marker, = ax_bat_eff.plot(time_df[cycle_idx], EE_arr, '^',color='green',label='EE', markersize=4)
            fig_agg_bat.draw()
        case 'cb_cap':
            if values['cb_cap'] == False:
                charge_cap_marker.remove()
                dis_cap_marker.remove()
            else:            
                charge_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], charge_cap_arr, 's',color='orange',label='capacity', markersize=4)
                dis_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], discharge_cap_arr, 'x',color='brown',label='capacity', markersize=4)
            fig_agg_bat.draw()
        case 'cb_volt':
            if values['cb_volt'] == False:
                volt_line.remove()
            else:
                volt_line, = ax_bat_volt.plot(time_df, volt_df, '-', label='Voltage', color='blue')
            fig_agg_bat.draw()
        case 'cb_current':
            if values['cb_current'] == False:
                current_line.remove()
            else:
                current_line, = ax_bat_current.plot(time_df, current_df, '--', label='Current', color='red')
            fig_agg_bat.draw()
        case 'cycle_start' | 'cycle_end':
            cycle_start = int(values['cycle_start'])
            
            if cycle_start > cycle_end - 1:
                cycle_end = cycle_start + 1
                window['cycle_end'].Update(cycle_end)
                
            cycle_end = int(values['cycle_end'])
            if cycle_end < cycle_start + 1:
                cycle_start = cycle_end - 1
                window['cycle_start'].Update(cycle_start)
                
            # Do not replot, since we only change xlim.
            cycle_idx_range = cy_idx_state_range(state_df, cycle_start, cycle_end, charge_CC_seq, discharge_CC_seq)
            left_bound = time_df[cycle_idx_range][0]
            right_bound = time_df[cycle_idx_range][1]
            
           # Change number of ticks with cycle range
            if cycle_end-cycle_start <= 10:  
                cycle_plot = np.arange(0,tot_cycle_number,1)
            elif cycle_end-cycle_start >= 10 and cycle_end-cycle_start <= 200:  
                cycle_plot = np.arange(0,tot_cycle_number,10)
            elif cycle_end-cycle_start >= 201 and cycle_end-cycle_start <= 500:
                cycle_plot = np.arange(0,tot_cycle_number,20)
            elif cycle_end-cycle_start >= 501 and cycle_end-cycle_start <= 1000:
                cycle_plot = np.arange(0,tot_cycle_number,50)          
            elif cycle_end-cycle_start >= 1001:
                cycle_plot = np.arange(0,tot_cycle_number,100)                    
            ax_bat_cycle.set_xticks(cycle_plot)
                
            ax_bat_volt.set_xlim(left=left_bound,right=right_bound)
            ax_bat_cycle.set_xlim(left=cycle_start,right=cycle_end)
            ax_bat_cycle.grid()
            
            VE_avg = np.average(VE_arr[cycle_start:cycle_end])
            CE_avg = np.average(CE_arr[cycle_start:cycle_end])
            EE_avg = np.average(EE_arr[cycle_start:cycle_end])
            window['output_ve'].Update(np.round(VE_avg,3))
            window['output_ce'].Update(np.round(CE_avg,3))
            window['output_ee'].Update(np.round(EE_avg,3))
            
            # ax_bat_volt.autoscale()
            # ax_bat_current.autoscale()
            # ax_bat_eff.autoscale()
            # ax_bat_cap.autoscale()
            
            ax_bat_cap.set_ylim(min(charge_cap_arr[cycle_start:cycle_end]), max(charge_cap_arr[cycle_start:cycle_end]))
            
            fig_agg_bat.draw()
        case 'bat_clear':
            clear_battery_plot()
        case 'save_bat':
            save_bat_loc = sg.popup_get_file('Create of choose a file (PNG) to save to', save_as=True)
            if save_bat_loc is None:
                continue
            elif save_bat_loc == '':
                continue
            fig_cv.savefig(save_bat_loc)            
        case sg.WIN_CLOSED | 'exit' | 'exit_2':
            try:
                shutil.rmtree(temp_path) # Delete temporary files from loading CV tar file.
            except NameError:
                pass
            break
window.close()
