#!/usr/bin/python3
import numpy as np 
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg 
from matplotlib.figure import Figure
import PySimpleGUI as sg
import matplotlib 
from matplotlib.lines import Line2D
import pandas as pd
from impedance import preprocessing
from impedance.models.circuits import Randles, CustomCircuit
# from impedance.visualization import plot_nyquist
matplotlib.use('TkAgg')
from PySimpleCV_main_func import battery_xls2df, get_CV_init, find_state_seq, get_battery_eff, cy_idx_state_range, CV_file2df, get_CV_peak, eis_fit, eis_read_file, search_pattern, lowess, diff, ir_compen_func, lowess_diff, idx_intercept
# import statsmodels.api as sm

# ToDo
# Save result in array
# Delete selected CV
# Detect deflection


import os

import sys

if not sys.warnoptions:
    import warnings
    warnings.simplefilter("ignore")

matplotlib.rcParams['figure.dpi'] = 80

def draw_figure(canvas, figure): 
    figure_canvas_agg = FigureCanvasTkAgg(figure, canvas) 
    figure_canvas_agg.draw() 
    figure_canvas_agg.get_tk_widget().pack(side='top', fill='both', expand=1) 
    return figure_canvas_agg

def About_PySimpleCV():
    [sg.popup('PySimpleCV written by Kavin Teenakul',
    'License: GPL v3',
    'https://github.com/kevinsmia1939/PySimpleCV',
    'Libraries used:',
    'NumPy - https://numpy.org/',
    'pandas - https://pandas.pydata.org/',
    'Matplotlib - https://matplotlib.org/',
    'PySimpleGUI - https://www.pysimplegui.org',
    'impedance.py - https://impedancepy.readthedocs.io/en/latest/',
    )]
    
sg.theme('DarkBlue')

# Generate layout for CV tab
cv_slider_size = (50,8)
cv_col1=[[sg.Canvas(key='-CANVAS_cv-')]]
cv_col2 = [
    [sg.Button("Add/Open CV File"),sg.Combo(values=(), default_value='', readonly=False, key='cv_combo', enable_events=True, size=(30,15)),sg.Button("Delete CV File")],
    [sg.Text('.csv file with voltage on 1st colume and current on 2nd column separated by comma')],
    [sg.Checkbox('Switch anodic and cathodic current', default=False, key='inv_jpa_jpc', disabled=True, enable_events=True)],
    [sg.Text('iR compensation'),sg.Input(default_text=('0'), key='ir_compen',size=(10,5),disabled=False, enable_events=True),sg.Text('Ω'),sg.Text('', key = 'ir_compen_warning')],
    [sg.Text('jpa='), sg.Text('', key = 'output_jpa'), sg.Text('jpc='), sg.Text('', key = 'output_jpc'), sg.Text('Epa='), sg.Text('', key = 'output_epa'), 
     sg.Text('Epc='), sg.Text('', key = 'output_epc'), sg.Text('E\u00bd='), sg.Text('', key = 'output_e1_2'), sg.Text('ΔE\u209a='), sg.Text('', key = 'output_delta_e')],
    [sg.Text('jpa/jpc='), sg.Text('', key = 'output_rev')],
    [sg.Text('Trim CV plot start'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_s', enable_events=True, disabled=True)],
    [sg.Text('Trim CV plot end'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_e', enable_events=True, disabled=True)],
    [sg.Text('Start 1'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpa_lns', enable_events=True, disabled=True)],
    [sg.Text('End 1'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpa_lne', enable_events=True, disabled=True)],
    [sg.Text('Start 2'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpc_lns', enable_events=True, disabled=True)],
    [sg.Text('End 2'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpc_lne', enable_events=True, disabled=True)],
    [sg.Text('Peak search range'),sg.Slider(range=(1, 100), size=cv_slider_size, orientation='h', key='peak_range', enable_events=True, disabled=False)],
    [sg.Text('Top peak position'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='peak_pos', enable_events=True, disabled=False),sg.Checkbox('Detect deflection', default=False, key='peak_defl_bool', disabled=True, enable_events=True)],
    [sg.Text('Bottom peak position'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='trough_pos', enable_events=True, disabled=False),sg.Checkbox('Detect deflection', default=False, key='trough_defl_bool', disabled=True, enable_events=True)],
    [sg.Multiline('',size=(90,5), disabled=True, key = 'cv_name_dis')],
    
    [sg.Button('Clear plot', key='cv_clear'),sg.Button('Exit', key='exit'),sg.Button('Save plot', key='save_cv'),sg.Button('About PySimpleCV')]
]
cv_layout = [[sg.Column(cv_col1),sg.Column(cv_col2)]]

# Generate layout for battery cycling tab.
bat_col1=[[sg.Canvas(key='-CANVAS_bat-')]]
bat_col2 = [
    [sg.Button("Open Battery File"),sg.Text('.xls files'),
     sg.Checkbox('Voltage', default=True, key='cb_volt', disabled=True, enable_events=True), 
     sg.Checkbox('Current', default=True, key='cb_current', disabled=True, enable_events=True),
     sg.Checkbox('Efficiencies', default=True, key='cb_eff', disabled=True, enable_events=True),
     sg.Checkbox('Capacities', default=True, key='cb_cap', disabled=True, enable_events=True)],
    [sg.Text('Battery file:'), sg.Text('No Battery file selected', key = 'bat_file_use')],
    [sg.Text('Average voltage efficiency='),sg.Text('', key = 'output_ve'),sg.Text('%')],
    [sg.Text('Average coulombic efficiency='), sg.Text('', key = 'output_ce'),sg.Text('%')],
    [sg.Text('Average energy efficiency='), sg.Text('', key = 'output_ee'),sg.Text('%')],
    [sg.Text('Total number of cycles='), sg.Text('', key= 'tot_cycle')],
    [sg.Text('Voltage, current, energy efficiency(%) for each row of cycle, press ctrl+c to copy')],
    [sg.Text('To copy nicely to spreadsheet software, select space as delimiter and merge delimters.')],
    [sg.Multiline('',size=(90,5), disabled=True, key = 'output_arr')],
    [sg.Text('Cycle start'), sg.Slider(range=(0, 0), size=(50, 8), orientation='h', key='cycle_start', enable_events=True, disabled=False)],
    [sg.Text('Cycle end'), sg.Slider(range=(1, 1), size=(50, 8), orientation='h', key='cycle_end', enable_events=True, disabled=False)],
    [sg.Button('Clear plot',key='bat_clear'),sg.Button('Save plot', key='save_bat'), sg.Button('Exit', key='exit_2')]
    ]          
bat_layout = [[sg.Column(bat_col1),sg.Column(bat_col2)]]

eis_col1=[[sg.Canvas(key='-CANVAS_eis-')],
      [sg.Text('EIS file:'), sg.Text('No EIS file selected', key = 'eis_file_use')],
      [sg.Text('Initial Guesses'),sg.Input(default_text='.01, .01, .001, 1, .1, 1', key='initial_guess',size=(72,5))]
      ]
eis_col2=[[sg.Button("Open EIS File", key = 'open_eis_file'), sg.Button("Plot", key='plot_eis')],
      [sg.Text('File type:'),sg.Combo(values=('CSV (.csv)', 'Gamry (.dta)','zplot (.z)','Versastudio (.par)','biologic (.mpt)', 'Autolab (.txt)', 'Parstat (.txt)', 'PowerSuite (.txt)', 'CHInstruments (.txt)'), default_value='CSV (.csv)', readonly=True, key='eis_file_type_select', enable_events=True, change_submits=True)],
      [sg.Checkbox('Ignore negative imaginary impedance', default=True, enable_events=True, k='ign_neg_img')],
      [sg.Radio('Randles circuit', "rad_eis_circuit", default=True, enable_events=True, k='randles_select_circuit'),sg.Checkbox('with CPE', default=True, enable_events=True, k='randles_cpe')],
      [sg.Radio('Custom circuit', "rad_eis_circuit", default=False, enable_events=True, k='custom_select_circuit')],
      [sg.Text('Custom circuit scheme')],
      [sg.Input(default_text=('R0-p(R1-Wo1,CPE1)'), key='custom_circuit',size=(50,5),disabled=True)],
      [sg.Multiline('',size=(50,20), disabled=True, key = 'circuit_output')],
      [sg.Button('Clear plot', key='eis_clear'),sg.Button('Exit', key='exit'),sg.Button('Save plot', key='save_eis')],
      [sg.Text('Visit https://impedancepy.readthedocs.io/en/latest/ for help')],
      ]
eis_layout = [[sg.Column(eis_col1),sg.Column(eis_col2)]]

layout =[[sg.TabGroup([[  sg.Tab('Cyclic Voltammetry', cv_layout),
                          sg.Tab('Battery Cycling', bat_layout),
                          sg.Tab('EIS', eis_layout)
                           ]], key='-TAB GROUP-', expand_x=True, expand_y=True),
]]
          
window = sg.Window('PySimpleCV', layout, finalize=True, element_justification='center')
# window.maximize()
canvas_cv = window['-CANVAS_cv-'].tk_canvas
canvas_bat = window['-CANVAS_bat-'].tk_canvas
canvas_eis = window['-CANVAS_eis-'].tk_canvas

# Generate initial empty plot.
fig_cv = Figure(figsize=(10,10))
ax_cv = fig_cv.add_subplot(111)
ax_cv.set_xlabel("Voltage")
ax_cv.set_ylabel("Current")
ax_cv.grid()
# tight layout push away y label
# fig_cv.tight_layout(pad=2)
fig_agg_cv = draw_figure(canvas_cv, fig_cv)

fig_bat = Figure(figsize=(10,10))
ax_bat_volt = fig_bat.add_subplot(111)
ax_bat_current = ax_bat_volt.twinx()
ax_bat_eff = ax_bat_volt.twinx()
ax_bat_cap = ax_bat_volt.twinx()
ax_bat_cycle = ax_bat_volt.twiny()
ax_bat_eff.spines.right.set_position(("axes", 1.11))
ax_bat_cap.spines.right.set_position(("axes", 1.21))
ax_bat_volt.set_ylabel("Voltage")
ax_bat_current.set_ylabel("Current")
ax_bat_eff.set_ylabel("Voltage/Coulombic/ Energy Efficiencies")
ax_bat_cap.set_ylabel("Capacity")
ax_bat_cycle.set_xlabel("Cycle")
ax_bat_volt.set_xlabel("Time")
# Create manual legend so we can put them in the same box
volt_leg = Line2D([0], [0], label='Voltage', color='blue', linestyle='-')
current_leg = Line2D([0], [0], label='Current', color='red', linestyle='--')
VE_leg = Line2D([0], [0], label='VE', color='blue', marker='*', linestyle='None')
CE_leg = Line2D([0], [0], label='CE', color='red', marker='.', linestyle='None')
EE_leg = Line2D([0], [0], label='EE', color='green', marker='^', linestyle='None')
cap_leg = Line2D([0], [0], label='Capacity', color='orange', marker='s', linestyle='None')
ax_bat_volt.legend(handles=[volt_leg,current_leg,VE_leg,CE_leg,EE_leg,cap_leg],ncol=6, bbox_to_anchor=(0.5,-0.25),loc='lower center')
ax_bat_cycle.grid()
ax_bat_volt.grid(axis='y')
fig_bat.tight_layout()
fig_agg_bat = draw_figure(canvas_bat, fig_bat)

# Generate initial empty plot.
fig_eis = Figure(figsize=(10,10))
ax_eis = fig_eis.add_subplot(111)
ax_eis.set_xlabel("Z'(w)[Ohms]")
ax_eis.set_ylabel('-Z"(w)[Ohms]')
ax_eis.set_aspect('equal', 'box')
ax_eis.axis('equal')
ax_eis.grid()
fig_agg_eis = draw_figure(canvas_eis, fig_eis)

cycle_start = 1
cycle_end = 1

def clear_battery_plot():
    # function to clear the plot.
    # Reset scrolls and checkboxes
    window['cb_volt'].Update(False)
    window['cb_current'].Update(False)
    window['cb_eff'].Update(False)
    window['cb_volt'].Update(disabled=True)
    window['cb_current'].Update(disabled=True)
    window['cb_eff'].Update(disabled=True)
    window['cycle_start'].Update(range=(0,0))
    window['cycle_end'].Update(range=(1,1))
    window['cycle_start'].Update(disabled=True)
    window['cycle_end'].Update(disabled=True)    
    # Remove existing plot.
    ax_bat_current.cla()
    ax_bat_volt.cla()
    ax_bat_eff.cla()
    ax_bat_cap.cla()
    ax_bat_cycle.cla()
    
    #Redraw Efficiency axis and labels.
    ax_bat_eff.spines.right.set_position(("axes", 1.11))
    ax_bat_cap.spines.right.set_position(("axes", 1.21))
    ax_bat_volt.set_ylabel("Voltage")
    ax_bat_current.set_ylabel("Current")
    ax_bat_eff.set_ylabel("Voltage/Current/Energy Efficiencies")
    ax_bat_cap.set_ylabel("Capacity")
    ax_bat_cycle.set_xlabel("Cycle")
    ax_bat_volt.set_xlabel("Time")
    # Create manual legend so we can put them in the same box
    volt_leg = Line2D([0], [0], label='Voltage', color='blue', linestyle='-')
    current_leg = Line2D([0], [0], label='Current', color='red', linestyle='--')
    VE_leg = Line2D([0], [0], label='VE', color='blue', marker='*', linestyle='None')
    CE_leg = Line2D([0], [0], label='CE', color='red', marker='.', linestyle='None')
    EE_leg = Line2D([0], [0], label='EE', color='green', marker='^', linestyle='None')
    ax_bat_volt.legend(handles=[volt_leg,current_leg,VE_leg,CE_leg,EE_leg],ncol=5, bbox_to_anchor=(0.5,-0.25),loc='lower center')
    ax_bat_cycle.grid()
    fig_agg_bat.draw()
    
def clear_cv_plot():
    # function to clear the plot.
    # Reset scrolls and checkboxes
    window['sl_cutval_s'].Update(disabled=True)
    window['sl_cutval_e'].Update(disabled=True)
    window['sl_jpa_lns'].Update(disabled=True)
    window['sl_jpa_lne'].Update(disabled=True)
    window['sl_jpc_lns'].Update(disabled=True)
    window['sl_jpc_lne'].Update(disabled=True)
    window['peak_range'].Update(disabled=True)
    window['peak_pos'].Update(disabled=True)
    window['trough_pos'].Update(disabled=True)
    window['sl_cutval_s'].Update(range=(0, 1))
    window['sl_cutval_e'].Update(range=(0, 1))
    window['sl_jpa_lns'].Update(range=(1, 1))
    window['sl_jpa_lne'].Update(range=(1, 1))
    window['sl_jpc_lns'].Update(range=(1, 1))
    window['sl_jpc_lne'].Update(range=(1, 1))
    window['peak_range'].Update(range=(1, 100))
    window['peak_pos'].Update(range=(1, 1))
    window['trough_pos'].Update(range=(1, 1))
    ax_cv.cla()
    ax_cv.grid()
    ax_cv.set_xlabel("Voltage")
    ax_cv.set_ylabel("Current")
    fig_agg_cv.draw()
    
def clear_eis_plot():
    ax_eis.cla()
    ax_eis.set_xlabel("Z'(w)[Ohms]")
    ax_eis.set_ylabel('-Z"(w)[Ohms]')
    ax_eis.set_aspect('equal', 'box')
    ax_eis.axis('equal')
    ax_eis.grid()
    fig_agg_eis.draw()
    
def enable_slider(bool):
    window['sl_cutval_s'].Update(disabled=bool)
    window['sl_cutval_e'].Update(disabled=bool)
    window['sl_jpa_lns'].Update(disabled=bool)
    window['sl_jpa_lne'].Update(disabled=bool)
    window['sl_jpc_lns'].Update(disabled=bool)
    window['sl_jpc_lne'].Update(disabled=bool)
    window['peak_range'].Update(disabled=bool)
    window['peak_pos'].Update(disabled=bool)
    window['trough_pos'].Update(disabled=bool)
    window['inv_jpa_jpc'].Update(disabled=bool)
    window['peak_defl_bool'].Update(disabled=bool)
    window['trough_defl_bool'].Update(disabled=bool)

randles_select = True
volt_array = []
smh_volt_array = []
smh_curr_array = []
diff1_curr_array = []
diff2_curr_array = []
diff3_curr_array = []
idx_intc_peak_array = []
idx_intc_deflection_array = []
current_array = []
volt_ir_array = []
cv_path_array = []
cv_name_array = []
cv_size_array = []
fitting_save_array = np.zeros((1,12))
fitting_default = np.array([[0,0,0,0,0,0,1,1,1,0,0,0]])
cv_name_idx_old = -1 #set to -1 so that cv_name_idx != cv_name_idx_old will trigger the first time
ir_compen_old = 0
diff1 = []
while True:
    event, values = window.read()
    match event:
        case sg.WIN_CLOSED | 'exit' | 'exit_2':
            break
        case 'About PySimpleCV':
            About_PySimpleCV()
        case 'cv_clear':
            clear_cv_plot()
        case 'Add/Open CV File':
            cv_file_new = sg.popup_get_file('Choose CV file')
            # If cancel, close the window, go back to beginning
            if cv_file_new is None:
                continue
            elif cv_file_new == '':
                continue
            # try:
                # Clear plot every time new plot open
            # clear_cv_plot()
            
            cv_file = cv_file_new
            cv_name = os.path.basename(cv_file) #Get file name
            df_CV = CV_file2df(cv_file)
            ir_compen = 0 #initially is 0
            cv_size, volt, current = get_CV_init(df_CV) # Only need the cv_size so set to [0]
            
            window['sl_cutval_s'].Update(range=(0,cv_size-1))
            window['sl_cutval_e'].Update(range=(0,cv_size-1))
            window['sl_cutval_e'].Update(cv_size)
            window['sl_jpa_lns'].Update(range=(0,cv_size-1))
            window['sl_jpa_lne'].Update(range=(0,cv_size-1))
            window['sl_jpc_lns'].Update(range=(0,cv_size-1))
            window['sl_jpc_lne'].Update(range=(0,cv_size-1))
            window['peak_range'].Update(range=(1, 100))
            window['peak_pos'].Update(range=(0, cv_size-1))
            window['trough_pos'].Update(range=(0, cv_size-1))
            
            cv_path_array.append(cv_file) #Create 2D array of CVs so we can select, plot, and analyze data based on index
            cv_name_array.append(cv_name)
            volt_array.append(volt)
            current_array.append(current)
            volt_ir_array.append(volt) #Append volt to ir compensated volt, this is like ir=0
            cv_size_array.append(cv_size)
            
            # deflection and Peak detection
            idx_arr = np.arange(0,cv_size)
            frac = 0.05
            _,smh_curr = lowess(idx_arr,current,frac)
            _,smh_volt = lowess(idx_arr,volt,frac)
            diff1_curr = diff(smh_volt,smh_curr) #First diff
            diff2_curr = lowess_diff(idx_arr,smh_volt,diff1_curr,0.05)
            diff3_curr = lowess_diff(idx_arr,smh_volt,diff2_curr,0) #Detect deflection
            smh_volt_array.append(smh_volt)
            smh_curr_array.append(smh_curr)
            diff1_curr_array.append(diff1_curr)
            diff2_curr_array.append(diff2_curr)
            diff3_curr_array.append(diff3_curr) 
            # Store peak and deflection value
            idx_intc_peak_array.append(idx_intercept(0,diff1_curr))
            idx_intc_deflection_array.append(idx_intercept(0,diff3_curr))

            # Add new default save data array
            fitting_save_array = np.append(fitting_save_array,fitting_default,axis=0)
            
            window['cv_combo'].Update(values=cv_name_array) # Update combo list of CVs
            window['cv_combo'].Update(cv_name) # Update default combo display

            enable_slider(False)

            ax_cv.grid()
            # fig_agg_cv.draw()
            # except Exception as file_error:
                # sg.popup(file_error, keep_on_top=True)
            cv_select = cv_name    
            cv_name_idx = cv_name_array.index(cv_select)
            window['cv_name_dis'].Update(cv_name_idx)
        case 'sl_cutval_s' | 'sl_cutval_e' | 'sl_jpa_lns' | 'sl_jpa_lne' | 'sl_jpc_lns' | 'sl_jpc_lne' | 'peak_pos'| 'trough_pos'| 'peak_range' | 'inv_jpa_jpc' | 'ir_compen' | 'cv_combo' | 'peak_defl_bool' | 'trough_defl_bool':

            ax_cv.cla()
            # print(cv_init)
            # cv_init.remove()
            
            cv_select = values['cv_combo']
            cv_name_idx = cv_name_array.index(cv_select)
            window['cv_name_dis'].Update(cv_name_idx)

            volt = volt_array[cv_name_idx]
            current = current_array[cv_name_idx]
            cv_size = cv_size_array[cv_name_idx]
            
            idx_peak_points = np.array(idx_intc_peak_array[cv_name_idx])
            idx_defl_points = np.array(idx_intc_deflection_array[cv_name_idx])    
            
            window['sl_cutval_s'].Update(range=(0,cv_size-1))
            window['sl_cutval_e'].Update(range=(0,cv_size-1))
            window['sl_jpa_lns'].Update(range=(0,cv_size-1))
            window['sl_jpa_lne'].Update(range=(0,cv_size-1))
            window['sl_jpc_lns'].Update(range=(0,cv_size-1))
            window['sl_jpc_lne'].Update(range=(0,cv_size-1))
            window['peak_range'].Update(range=(1, 100))
            window['peak_pos'].Update(range=(1, cv_size-1))
            window['trough_pos'].Update(range=(1, cv_size-1))

            try:
                ir_compen = float(values['ir_compen'])
            except ValueError:
                ir_compen = float(0)            

            if cv_name_idx != cv_name_idx_old: #If the option index change (combo box change), update slider
               cv_name_idx_old = cv_name_idx
               # Restore saved values
               cutval_s_save = int(fitting_save_array[cv_name_idx+1,0])
               cutval_e_save = int(fitting_save_array[cv_name_idx+1,1])
               jpa_lns_save = int(fitting_save_array[cv_name_idx+1,2])
               jpa_lne_save = int(fitting_save_array[cv_name_idx+1,3])
               jpc_lns_save = int(fitting_save_array[cv_name_idx+1,4])
               jpc_lne_save = int(fitting_save_array[cv_name_idx+1,5])
               peak_pos_save = int(fitting_save_array[cv_name_idx+1,6])
               trough_pos_save = int(fitting_save_array[cv_name_idx+1,7])
               peak_range_save = int(fitting_save_array[cv_name_idx+1,8])
               ir_compen_save = int(fitting_save_array[cv_name_idx+1,9])
               peak_defl_bool_save = bool(fitting_save_array[cv_name_idx+1,10])
               trough_defl_bool_save = bool(fitting_save_array[cv_name_idx+1,11])
               # Put slider to previous position
               window['sl_cutval_s'].Update(cutval_s_save)
               window['sl_cutval_e'].Update(cutval_e_save)
               window['sl_jpa_lns'].Update(jpa_lns_save)
               window['sl_jpa_lne'].Update(jpa_lne_save)
               window['sl_jpc_lns'].Update(jpc_lns_save)
               window['sl_jpc_lne'].Update(jpc_lne_save)
               window['peak_pos'].Update(peak_pos_save)
               window['trough_pos'].Update(trough_pos_save)
               window['peak_range'].Update(peak_range_save)
               window['ir_compen'].Update(ir_compen_save)
               window['peak_defl_bool'].Update(peak_defl_bool_save)
               window['trough_defl_bool'].Update(trough_defl_bool_save)              
               # Assign the value from saved data
               cutval_s = cutval_s_save
               cutval_e = cutval_e_save
               jpa_lns = jpa_lns_save
               jpa_lne = jpa_lne_save
               jpc_lns = jpc_lns_save
               jpc_lne = jpc_lne_save
               peak_pos = peak_pos_save
               trough_pos = trough_pos_save
               peak_range = peak_range_save
               ir_compen = ir_compen_save
               peak_defl_bool = peak_defl_bool_save
               trough_defl_bool = trough_defl_bool_save
            elif cv_name_idx == cv_name_idx_old: #If combobox does not change, simply read value from slider
               cutval_s = int(values['sl_cutval_s'])
               cutval_e = int(values['sl_cutval_e'])
               jpa_lns = int(values['sl_jpa_lns'])
               jpa_lne = int(values['sl_jpa_lne'])
               jpc_lns = int(values['sl_jpc_lns'])
               jpc_lne = int(values['sl_jpc_lne'])
               peak_pos = int(values['peak_pos'])
               trough_pos = int(values['trough_pos'])
               peak_range = int(values['peak_range'])
               peak_defl_bool = int(values['peak_defl_bool'])
               trough_defl_bool = int(values['trough_defl_bool'])
               # Only accept float value from ir compensation
               try:
                   ir_compen = float(values['ir_compen'])
               except ValueError:
                   ir_compen = float(0)   
               fitting_save = np.array([cutval_s, cutval_e, jpa_lns, jpa_lne, jpc_lns, jpc_lne, peak_pos, trough_pos, peak_range, ir_compen, peak_defl_bool, trough_defl_bool]) 
               np.put(fitting_save_array[cv_name_idx+1],[0,1,2,3,4,5,6,7,8,9,10,11], fitting_save) #Save data 
            
            if ir_compen != ir_compen_old:
                ir_compen_old = ir_compen
                volt_compen = ir_compen_func(volt,current,ir_compen)
                # Overwrite volt and curr with ir compen
                volt_ir_array[cv_name_idx] = volt_compen
            else:
                volt_compen = volt_ir_array[cv_name_idx]
            
            if jpa_lns >= jpa_lne:
                jpa_lne_old = jpa_lne
                jpa_lne = jpa_lns
                jpa_lns = jpa_lne_old
            if jpc_lns >= jpc_lne:
                jpc_lne_old = jpc_lne
                jpc_lne = jpc_lns
                jpc_lns = jpc_lne_old  
            
            if values['peak_defl_bool'] == 1:
                peak_range = 0
                peak_defl_bool = 1
                # aaa = idx_defl_points - peak_pos
                peak_pos = idx_defl_points[np.abs(idx_defl_points - peak_pos).argmin()]
                peak_pos = int(peak_pos)
            else:
                peak_defl_bool = 0
            if values['trough_defl_bool'] == 1:
                trough_range = 0
                trough_defl_bool = 1
                # aaa = idx_defl_points - peak_pos
                trough_pos = idx_defl_points[np.abs(idx_defl_points - trough_pos).argmin()]
                trough_pos = int(trough_pos)
            else:
                trough_defl_bool = 0
                
            low_range_peak, high_range_peak, peak_volt, peak_curr, low_range_trough, high_range_trough, trough_volt, trough_curr, jpa, jpc, jpa_poly1d, jpc_poly1d = get_CV_peak(cv_size, volt_compen, current, peak_range, peak_pos, trough_pos, jpa_lns, jpa_lne, jpc_lns, jpc_lne, peak_defl_bool, trough_defl_bool)
         
            # Find estimate standard electrode potential (E1/2~E0)
            E1_2 = (trough_volt+peak_volt)/2
            ax_cv.plot(E1_2,0,"D", markersize = 6)
            # Find peak-peak separation voltage
            delta_e = np.abs(trough_volt-peak_volt)
            
            # invert jpa and jpc or not
            if values['inv_jpa_jpc'] == False:   
                jpa_show = jpa
                jpc_show = jpc
                jpa_text = 'jpa'
                jpc_text = 'jpc'
            else:
                jpa_show = jpc
                jpc_show = jpa    
                jpa_text = 'jpc'
                jpc_text = 'jpa'
                

            # Start plotting
            ccc = len(volt_array)
            for j in np.arange(0,ccc):
                cutval_s_all = int(fitting_save_array[j+1,0])
                cutval_e_all = int(fitting_save_array[j+1,1])
                ax_cv.plot(np.array(volt_ir_array[j][cutval_s_all:cutval_e_all]).T, np.array(current_array[j][cutval_s_all:cutval_e_all]).T, '-', color='black')
                
            clip_defl = idx_defl_points[(idx_defl_points >= cutval_s_all) & (idx_defl_points <= cutval_e_all)]
            volt_defl = np.interp([clip_defl], idx_arr, volt_compen)
            curr_defl = np.interp([clip_defl], idx_arr, current)
            ax_cv.plot(volt_defl,curr_defl,'*',color='red')

            # clip_defl = defl_points[(defl_points >= 3995) & (defl_points <= 5995)]
            
            # volt_defl = np.interp([deflection_points], idx_arr, volt_compen)
            # curr_defl = np.interp([deflection_points], idx_arr, current)
            # ax_cv.plot(volt_defl,curr_defl,'*',color='red')
                
            # Peak
            # ax_cv.plot(volt_compen[peak_points],current[peak_points],'o',color='red')
            
            # volt_peak = np.interp([peak_points], idx_arr, volt_compen)
            # curr_peak = np.interp([peak_points], idx_arr, current)
            # ax_cv.plot(volt_peak,curr_peak,'*',color='blue')
            
            # volt_defl = np.interp([deflection_points], idx_arr, volt_compen)
            # curr_defl = np.interp([deflection_points], idx_arr, current)
            # ax_cv.plot(volt_defl,curr_defl,'*',color='red')
            
            
            ax_cv.plot((volt_compen[low_range_peak],volt_compen[high_range_peak]),(current[low_range_peak],current[high_range_peak]),"|", markersize = 10)
            ax_cv.plot((volt_compen[low_range_trough],volt_compen[high_range_trough]),(current[low_range_trough],current[high_range_trough]),"|", markersize = 10)

            ax_cv.plot(volt_compen[jpa_lns:jpa_lne],current[jpa_lns:jpa_lne],linewidth=4,linestyle='-',color='red')
            ax_cv.annotate(text='',ha="center",va="center", xy=(peak_volt,jpa_poly1d(peak_volt)), xytext=(peak_volt,peak_curr), arrowprops=dict(arrowstyle='<-'))
            ax_cv.plot(np.array([volt_compen[jpa_lns],peak_volt]),np.array([jpa_poly1d(volt_compen[jpa_lns]),jpa_poly1d(peak_volt)]),'--')
            
            ax_cv.plot(volt_compen[jpc_lns:jpc_lne],current[jpc_lns:jpc_lne],linewidth=4,linestyle='-',color='blue')
            ax_cv.annotate(text='',ha="center",va="center", xy=(trough_volt,jpc_poly1d(trough_volt)), xytext=(trough_volt,trough_curr), arrowprops=dict(arrowstyle='<-'))
            ax_cv.plot(np.array([volt_compen[jpc_lns],trough_volt]),np.array([jpc_poly1d(volt_compen[jpc_lns]),jpc_poly1d(trough_volt)]),'--')
            
            ax_cv.grid()
            ax_cv.set_xlabel("Voltage")
            ax_cv.set_ylabel("Current")
            fig_agg_cv.draw()
            window['output_jpa'].Update(np.round(jpa_show*1000/5,3)) #convert to mA in 5 cm2 area
            window['output_jpc'].Update(np.round(jpc_show*1000/5,3))
            window['output_epa'].Update(np.round(peak_volt,3))
            window['output_epc'].Update(np.round(trough_volt,3))
            window['output_rev'].Update(np.round((jpa_show/jpc_show),3))
            window['output_e1_2'].Update(np.round(E1_2,3))
            window['output_delta_e'].Update(np.round(delta_e,3))
        case 'save_cv':
            save_cv_loc = sg.popup_get_file('Create of choose a file (PNG) to save to', save_as=True)
            if save_cv_loc is None:
                continue
            elif save_cv_loc == '':
                continue
            fig_cv.savefig(save_cv_loc)
        case 'Open Battery File':
            bat_file_new = sg.popup_get_file('Choose battery cycle file (.xls)')
            # If cancel, close the window, go back to beginning
            # If empty, use old file
            if bat_file_new is None:
                continue
            elif bat_file_new == '':
                continue
            # try:
            clear_battery_plot()
            bat_file = bat_file_new
            df_bat, row_size, time_df, volt_df, current_df, capacity_df, state_df = battery_xls2df(bat_file)

            # Voltage difference with current interrupt method between C_CC and R
            CIM_idx = search_pattern(list(state_df), ['C_CC','R'])
            CIM_volt_drop_lst = []
            for i in CIM_idx:
                CIM_volt_drop = volt_df[i]-volt_df[i+1]
                CIM_volt_drop_lst.append(CIM_volt_drop)
            
            
            # Sequence information
            charge_CC_seq, discharge_CC_seq, rest_seq, charge_CV_seq, discharge_CV_seq = find_state_seq(state_df)
            VE_arr, CE_arr, EE_arr, charge_cap_arr, discharge_cap_arr, tot_cycle_number = get_battery_eff(row_size, time_df, volt_df, current_df, capacity_df, state_df, charge_CC_seq, discharge_CC_seq)
            
            VE_avg = np.average(VE_arr[0:cycle_end])
            CE_avg = np.average(CE_arr[0:cycle_end])
            EE_avg = np.average(EE_arr[0:cycle_end])
            charge_cap_avg = np.average(charge_cap_arr[0:cycle_end])
            discharge_cap_avg = np.average(discharge_cap_arr[0:cycle_end]) 
            #For display table
            df_display=pd.DataFrame([charge_cap_arr,discharge_cap_arr,VE_arr,CE_arr,EE_arr]) # Create dataframe to display in multiline output
            df_display=df_display.T
            df_display.columns = ['Charge-Capacity','Discharge-Capacity','VE', 'CE', 'EE']
            df_display.index = df_display.index + 1 # Start index at 1 for nice looking
            
            window['cycle_end'].Update(disabled=False)
            window['cycle_start'].Update(disabled=False)
            window['cb_volt'].Update(disabled=False)
            window['cb_current'].Update(disabled=False)
            window['cb_eff'].Update(disabled=False)
            window['cb_cap'].Update(disabled=False)
            window['cb_volt'].Update(True)
            window['cb_current'].Update(True)
            window['cb_eff'].Update(True)
            window['cycle_start'].Update(range=(0,tot_cycle_number-1))
            window['cycle_end'].Update(range=(1,tot_cycle_number))
            window['bat_file_use'].Update(bat_file)
            window['output_arr'].Update(df_display.to_string()) # Make sure to print all lines
            window['tot_cycle'].Update(tot_cycle_number) 
            window['output_ve'].Update(np.round(VE_avg,3))
            window['output_ce'].Update(np.round(CE_avg,3))
            window['output_ee'].Update(np.round(EE_avg,3))
            
            volt_line, = ax_bat_volt.plot(time_df, volt_df, '-', label='Voltage', color='blue')
            current_line, = ax_bat_current.plot(time_df, current_df, '--', label='Current', color='red')
            

            cycle_idx = (charge_CC_seq)[:,1]
            

            cycle_idx = cycle_idx[0:min((charge_CC_seq)[:,1].size,(discharge_CC_seq)[:,1].size)]
            # min((charge_seq)[:,1].size,(discharge_seq)[:,1].size)
            time_cycle = time_df[cycle_idx]
            VE_marker, = ax_bat_eff.plot(time_df[cycle_idx], VE_arr, '*',color='blue',label='VE', markersize=8)
            CE_marker, = ax_bat_eff.plot(time_df[cycle_idx], CE_arr, '.',color='red',label='CE', markersize=8)
            EE_marker, = ax_bat_eff.plot(time_df[cycle_idx], EE_arr, '^',color='green',label='EE', markersize=4)              
            charge_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], charge_cap_arr, 's',color='orange',label='capacity', markersize=4)
            dis_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], discharge_cap_arr, 'x',color='brown',label='capacity', markersize=4)
            CIM_marker, = ax_bat_volt.plot(time_df[cycle_idx], np.array(CIM_volt_drop_lst)/0.65, 'o',color='blue',label='CIM', markersize=4)
            
            ax_bat_volt.autoscale()
            ax_bat_current.autoscale()
            ax_bat_eff.autoscale()
            ax_bat_cap.autoscale()
            # Set limit and ticks of bat_cycle
            # Match cycle scale to time scale and plot efficiency.
            cycle_plot = np.arange(0,tot_cycle_number,10)
            ax_bat_cycle.set_xticks(cycle_plot)
            ax_bat_cycle.set_xlim(left=0,right=tot_cycle_number)
            
            # Set limit for efficiencies
            ax_bat_eff.set_ylim(0,100)
            
            ax_bat_volt.set_xlim(left=0,right=max(time_df))

            ax_bat_cycle.grid()
            ax_bat_volt.grid(axis='y')
            fig_agg_bat.draw()
            # except Exception as file_error:
            #     sg.popup(file_error, keep_on_top=True)
        case 'cb_eff':
            if values['cb_eff'] == False:
                VE_marker.remove()
                CE_marker.remove()
                EE_marker.remove()
            else:
                VE_marker, = ax_bat_eff.plot(time_df[cycle_idx], VE_arr, '*',color='blue',label='VE', markersize=8)
                CE_marker, = ax_bat_eff.plot(time_df[cycle_idx], CE_arr, '.',color='red',label='CE', markersize=8)
                EE_marker, = ax_bat_eff.plot(time_df[cycle_idx], EE_arr, '^',color='green',label='EE', markersize=4)
            fig_agg_bat.draw()
        case 'cb_cap':
            if values['cb_cap'] == False:
                charge_cap_marker.remove()
                dis_cap_marker.remove()
            else:            
                charge_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], charge_cap_arr, 's',color='orange',label='capacity', markersize=4)
                dis_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], discharge_cap_arr, 'x',color='brown',label='capacity', markersize=4)
            fig_agg_bat.draw()
        case 'cb_volt':
            if values['cb_volt'] == False:
                volt_line.remove()
            else:
                volt_line, = ax_bat_volt.plot(time_df, volt_df, '-', label='Voltage', color='blue')
            fig_agg_bat.draw()
        case 'cb_current':
            if values['cb_current'] == False:
                current_line.remove()
            else:
                current_line, = ax_bat_current.plot(time_df, current_df, '--', label='Current', color='red')
            fig_agg_bat.draw()
        case 'cycle_start' | 'cycle_end':
            cycle_start = int(values['cycle_start'])
            
            if cycle_start > cycle_end - 1:
                cycle_end = cycle_start + 1
                window['cycle_end'].Update(cycle_end)
                
            cycle_end = int(values['cycle_end'])
            if cycle_end < cycle_start + 1:
                cycle_start = cycle_end - 1
                window['cycle_start'].Update(cycle_start)
                
            # Do not replot, since we only change xlim.
            cycle_idx_range = cy_idx_state_range(state_df, cycle_start, cycle_end, charge_CC_seq, discharge_CC_seq)
            left_bound = time_df[cycle_idx_range][0]
            right_bound = time_df[cycle_idx_range][1]
            
           # Change number of ticks with cycle range
            if cycle_end-cycle_start <= 10:  
                cycle_plot = np.arange(0,tot_cycle_number,1)
            elif cycle_end-cycle_start >= 10 and cycle_end-cycle_start <= 200:  
                cycle_plot = np.arange(0,tot_cycle_number,10)
            elif cycle_end-cycle_start >= 201 and cycle_end-cycle_start <= 500:
                cycle_plot = np.arange(0,tot_cycle_number,20)
            elif cycle_end-cycle_start >= 501 and cycle_end-cycle_start <= 1000:
                cycle_plot = np.arange(0,tot_cycle_number,50)          
            elif cycle_end-cycle_start >= 1001:
                cycle_plot = np.arange(0,tot_cycle_number,100)                    
            ax_bat_cycle.set_xticks(cycle_plot)
                
            ax_bat_volt.set_xlim(left=left_bound,right=right_bound)
            ax_bat_cycle.set_xlim(left=cycle_start,right=cycle_end)
            ax_bat_cycle.grid()
            
            VE_avg = np.average(VE_arr[cycle_start:cycle_end])
            CE_avg = np.average(CE_arr[cycle_start:cycle_end])
            EE_avg = np.average(EE_arr[cycle_start:cycle_end])
            window['output_ve'].Update(np.round(VE_avg,3))
            window['output_ce'].Update(np.round(CE_avg,3))
            window['output_ee'].Update(np.round(EE_avg,3))
            
            # ax_bat_volt.autoscale()
            # ax_bat_current.autoscale()
            # ax_bat_eff.autoscale()
            # ax_bat_cap.autoscale()
            
            ax_bat_cap.set_ylim(min(charge_cap_arr[cycle_start:cycle_end]), max(charge_cap_arr[cycle_start:cycle_end]))
            
            fig_agg_bat.draw()
        case "bat_clear":
            clear_battery_plot()
        case "save_bat":
            save_bat_loc = sg.popup_get_file('Create of choose a file (PNG) to save to', save_as=True)
            if save_bat_loc is None:
                continue
            elif save_bat_loc == '':
                continue
            fig_cv.savefig(save_bat_loc)            
        case "open_eis_file":
            eis_file_new = sg.popup_get_file('Choose EIS file')
            if eis_file_new is None:
                continue
            elif eis_file_new == '':
                continue
            eis_file = eis_file_new
            window['eis_file_use'].Update(eis_file)
        case "plot_eis": # case "plot_eis" | "eis_file_type_select" | "ign_neg_img" | "randles_cpe":
            print('CPE',values['randles_cpe'])
            eis_choose_file_type = values['eis_file_type_select']
            try:
                frequencies, z = eis_read_file(eis_file,eis_choose_file_type)
            except Exception as file_error:
                sg.popup(file_error, keep_on_top=True)
                sg.popup("Probably wrong file type chosen, choose a new file type.")
                continue
            try:    
                if values['ign_neg_img'] == True:
                    frequencies, z = preprocessing.ignoreBelowX(frequencies, z)
                    print("preprocessing")
                    
                initial_guess = [float(i) for i in values['initial_guess'].split(',')]    
                # if randles selected
                if values['randles_select_circuit'] == True:
                    try:
                        circuit = Randles(initial_guess=initial_guess, CPE=values['randles_cpe'])
                    except:
                        sg.popup("Need initial guess or number of guesses do not match the circuit (could be CPE?)", keep_on_top=True)
                        continue
                
                # custom circuit enabled
                if values['custom_select_circuit'] == True:
                    circuit_scheme = values['custom_circuit']
                    print(circuit_scheme)
                    circuit = CustomCircuit(initial_guess=initial_guess, circuit=circuit_scheme)
                    
                circuit.fit(frequencies, z)
                z_fit = circuit.predict(frequencies)
            except Exception as file_error:
                sg.popup(file_error, keep_on_top=True)  
                
            ax_eis.plot(np.real(z_fit), -np.imag(z_fit),'--')
            ax_eis.plot(np.real(z), -np.imag(z),':')

            ax_eis.set_aspect('equal', 'box')
            ax_eis.axis('equal')
            fig_agg_eis.draw()
            window['circuit_output'].Update(circuit)
        case "randles_select_circuit":
            window['randles_cpe'].Update(disabled=False)
            window['custom_circuit'].Update(disabled=True)
        case "custom_select_circuit":
            window['randles_cpe'].Update(disabled=True)
            window['custom_circuit'].Update(disabled=False)
        case "eis_clear":
            clear_eis_plot()
window.close()

            # Clear plot every time new plot open
            
            # frac = 0.01
            # cv_idx = np.arange(0,cv_size)  
            # cv_init, = ax_cv.plot(cv_idx, current, '-', color='black')
            
            #Smooth CV
            # smh_volt, smh_curr = lowess(cv_idx,current,frac)
            # ax_cv.plot(smh_volt, smh_curr)
            
            # #Diff CV
            # diff_volt, diff_curr = diff(smh_volt, smh_curr)
            # sdiff_volt, sdiff_curr = lowess(diff_volt, diff_curr,frac)
            # ax_cv.plot(sdiff_volt, sdiff_curr*180)
            
            # #Diff2
            # diff2_volt, diff2_curr = diff(sdiff_volt, sdiff_curr)
            # sdiff2_volt, sdiff2_curr = lowess(diff2_volt, diff2_curr,frac)
            # # ax_cv.plot(sdiff2_volt, sdiff2_curr*10000)           
            
            # #Diff3
            # diff3_volt, diff3_curr = diff(sdiff2_volt, sdiff2_curr)
            # sdiff3_volt, sdiff3_curr = lowess(diff3_volt, diff3_curr,frac)
            # ax_cv.plot(sdiff3_volt, sdiff3_curr*1000000)            
            
            # print(idx.size)
            # print(current.size)
            # print(cv_idx.size)
            # ax_cv.plot(cv_idx,current)
            
            # diff_cv_idx, diff_curr, diff = diff_smh(cv_idx,current,frac)
            # print(diff_curr.size)
            # print(diff_volt.size)
            # ax_cv.plot(cv_idx,diff*170)
            # ax_cv.plot(diff_cv_idx,diff_curr*170)
            
            # diff2_curr = np.gradient(diff_curr,cv_idx)
            
            # diff2_cv_idx, diff2_curr, diff = diff_smh(diff_cv_idx,diff_curr,frac)
            # ax_cv.plot(diff2_cv_idx, diff2_curr*20000)

            # ax_cv.set_ylim(-0.1,0.1)
            # ax_cv.set_xlim(0,1000)
            
                        
            
                            
                
            ########################################################################

            # max_v_idx = np.argmax(volt)
            # min_v_idx = np.argmin(volt)
            
            
            # print(max_v_idx,min_v_idx)
            # print(volt.size)
            # cv_size = volt.size-1
            # if max_v_idx == 0 or min_v_idx == 0 or max_v_idx == cv_size or min_v_idx == cv_size:
            #     if max_v_idx == 0 or max_v_idx == cv_size:
            #         #negative
            #         seg1 = (0,min_v_idx)
            #         seg2 = (min_v_idx,cv_size)
            #     elif min_v_idx == 0 or min_v_idx == cv_size:
            #         #positive
            #         seg1 = (0,max_v_idx)
            #         seg2 = (max_v_idx,cv_size)
            #     smh_volt1, smh_curr1 = diff_smh(volt[seg1[0]:seg1[1]],current[seg1[0]:seg1[1]],frac)
            #     smh_volt2, smh_curr2 = diff_smh(volt[seg2[0]:seg2[1]],current[seg2[0]:seg2[1]],frac)
            #     print('test')
            #     ax_cv.plot(smh_volt1, smh_curr1, smh_volt2, smh_curr2)      
                
            # else:
            #     print(max_v_idx,min_v_idx)
            #     if max_v_idx <= min_v_idx:
            #         seg1 = (0,max_v_idx)
            #         seg2 = (max_v_idx,min_v_idx)
            #         seg3 = (min_v_idx,volt.size)
            #         print(seg3)
            #         print(volt.size)
            #     else: 
            #         seg1 = (0,min_v_idx)
            #         seg2 = (min_v_idx,max_v_idx)
            #         seg3 = (max_v_idx,volt.size)
            #         print(volt.size)
            #         print(seg3)
            #     smh_volt1, smh_curr1 = diff_smh(volt[seg1[0]:seg1[1]],current[seg1[0]:seg1[1]],frac)
            #     smh_volt2, smh_curr2 = diff_smh(volt[seg2[0]:seg2[1]],current[seg2[0]:seg2[1]],frac)
            #     smh_volt3, smh_curr3 = diff_smh(volt[seg3[0]:seg3[1]],current[seg3[0]:seg3[1]],frac)
            #     ax_cv.plot(smh_volt1, smh_curr1, smh_volt2, smh_curr2, smh_volt3, smh_curr3)
            # idx = np.arange(0,volt.size)  
            # print(idx.size)
            # print(current.size)
            # ax_cv.plot(idx,current)
            # frac = 0.09
            # diff_volt, diff_curr = diff_smh(idx,current,frac)
            # ax_cv.plot(idx,diff_curr*170)
            
            # diff2_curr = np.gradient(diff_curr,idx)
            
            # # diff2_volt, diff2_curr = diff_smh(idx,diff_curr,frac)
            # ax_cv.plot(idx, diff2_curr*20000)
            ########################################################################
            
            
            # ax_cv.plot(smh_volt1, smh_curr1, smh_volt2, smh_curr2)    