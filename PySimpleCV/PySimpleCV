#!/usr/bin/python3
import os
import sys
import numpy as np 
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg 
from matplotlib.figure import Figure
import PySimpleGUI as sg
import matplotlib 
from matplotlib.lines import Line2D
import pandas as pd
import shutil
matplotlib.use('TkAgg')
from PySimpleCV_main_func import battery_xls2df, get_CV_init, find_state_seq, get_battery_eff, cy_idx_state_range, CV_file2df, get_peak_CV, search_pattern, ir_compen_func, diffusion, reaction_rate, deflection, find_alpha, min_max_peak, check_val, switch_val, RDE_diffusion, RDE_kin_curr
# from PySimpleCV_main_func import *

if not sys.warnoptions:
    import warnings
    warnings.simplefilter("ignore")

matplotlib.rcParams['figure.dpi'] = 80

def About_PySimpleCV():
    [sg.popup('PySimpleCV written by Kavin Teenakul',
    'License: GPL v3',
    'https://github.com/kevinsmia1939/PySimpleCV',
    'Libraries used:',
    'NumPy - https://numpy.org/',
    'pandas - https://pandas.pydata.org/',
    'Matplotlib - https://matplotlib.org/',
    'PySimpleGUI - https://www.pysimplegui.org',
    'impedance.py - https://impedancepy.readthedocs.io/en/latest/',
    'statsmodels - https://www.statsmodels.org',
    
    'Abbreviation',
    'Jpa - Anodic peak current/current density',
    'Jpc - Cathodic peak current/current density',
    'Epa - Anodic peak potential',
    'Epc - Cathodic peak potential',
    'E\u00bd  - Half-wave potential',
    'ΔE\u209a - Peak-to-peak separation potential',
    'Nicholson method - Nicholson, R. S. Semiempirical Procedure for Measuring with Stationary Electrode Polarography Rates of Chemical Reactions Involving the Product of Electron Transfer. Anal. Chem. 1966, 38 (10), 1406.'
    )]

sg.theme('DarkBlue')

def draw_figure(canvas, figure): 
    figure_canvas_agg = FigureCanvasTkAgg(figure, canvas) 
    figure_canvas_agg.draw() 
    figure_canvas_agg.get_tk_widget().pack(side='top', fill='both', expand=1) 
    return figure_canvas_agg

# Generate layout for CV tab
cv_slider_size = (50,18)
cv_cv=[[sg.Canvas(key='-CANVAS_cv-')]]
cv_diff=[[sg.Canvas(key='-CANVAS_cv_D-')]]
cv_kin =[[sg.Canvas(key='-CANVAS_cv_k-')]]

cv_open_menu = ["Menu",["VersaSTAT4 (.par)", "CorrWare (.cor)", "CSV (.csv)", "text (.txt)"]]
rde_open_menu = ["Menu",["VersaSTAT4 (.par)", "CorrWare (.cor)", "CSV (.csv)", "text (.txt)"]]
cv_peak_mode = ["max","min","deflection"]
         
cv_settings = [
    [sg.ButtonMenu("Add/Open CV file",cv_open_menu,key='cv_open_menu'),sg.Button("Load saved CV files", key='cv_load_cv'),sg.Combo(values=(), default_value='', readonly=False, key='cv_combo_cv', enable_events=True, size=(30,15)),sg.Button("Delete CV File", disabled=True)],
    [sg.Text('.csv file with Voltage on 1st colume and current on 2nd column separated by comma')],
    [sg.Checkbox('Switch anodic and cathodic current', default=False, key='inv_jpa_jpc', disabled=True, enable_events=True)],
    [sg.Text('iR compensation'),sg.Input(default_text=('0'), key='ir_compen',size=(8,5),disabled=True, enable_events=True),sg.Text('Ω'),sg.Text('Electrode area'),sg.Input(default_text=('1'), key='elec_area',size=(8,5),disabled=True, enable_events=True),sg.Text('cm\u00b2'),
     sg.Text('Scan rate'),sg.Input(default_text=('0'), key='scan_rate',size=(8,5),disabled=True, enable_events=True),sg.Text('V/s')],
    [sg.Text('Trim CV plot start'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_s', disable_number_display=True, enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_cutval_s_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('Trim CV plot end'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_e', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_cutval_e_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('Start 1'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpa_lns', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_jpa_lns_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('End 1'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpa_lne', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_jpa_lne_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('Start 2'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpc_lns', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_jpc_lns_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('End 2'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpc_lne', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_jpc_lne_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('Search range'),sg.Slider(range=(1, 100), size=cv_slider_size, orientation='h', key='peak_range', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='peak_range_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('Peak position 1'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='peak_pos', enable_events=True, disabled=True), sg.Combo(values=('max','min','exact','deflection'), default_value='max', readonly=True, key='peak_mode_1', enable_events=True, size=(7,15)),sg.Text('position'), sg.Input(default_text=('0'), key='peak_pos_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('Peak position 2'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='trou_pos', enable_events=True, disabled=True), sg.Combo(values=('max','min','exact','deflection'), default_value='min', readonly=True, key='peak_mode_2', enable_events=True, size=(7,15)),sg.Text('position'), sg.Input(default_text=('0'), key='trou_pos_pos',size=(6,5),disabled=True, enable_events=True)],
    
    [sg.Frame('Nicholson Method',[   
    [sg.Checkbox('Nicholson method (if baseline cannot be determine)', default=False, key='nicholson_cb', enable_events=True, disabled=True)],
    [sg.Text('Switching potential current (jps0)'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='idx_jsp0', enable_events=True, disabled=True),sg.Text('', key='jsp0_cv_volt'),sg.Text('V'),sg.Text('position'),sg.Input(default_text=('0'), key='idx_jsp0_pos',size=(6,5),disabled=True, enable_events=True)],
    ], key='-frame_nicholson-')],
    
    [sg.Frame('Diffusion Coefficienct and rate of reaction',[   
    [sg.Text('Bulk concentration'),sg.Input(default_text=('0'), key='bulk_conc_cv',size=(15,5),disabled=True, enable_events=True),sg.Text('mol/cm\u00b3'),sg.Text('Number of electrons'),sg.Input(default_text=('1'), key='elec_n_cv',size=(15,5),disabled=True, enable_events=True)],
    [sg.Text('Average anodic alpha'),sg.Input(text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(), key='alpha_ano',size=(15,5),disabled=True, enable_events=True),sg.Text('Average cathodic alpha'),sg.Input(text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(), key='alpha_cat',size=(15,5),disabled=True, enable_events=True)],
    [sg.Text('Ano rev D (cm\u00b2/s)'),sg.Input('', key='d_rev_jpa', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True),sg.Text('Cat rev D (cm\u00b2/s)'),sg.Input('', key='d_rev_jpc', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True)],
    [sg.Text('Ano irr D (cm\u00b2/s)'),sg.Input('', key='d_irr_jpa', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True),sg.Text('Cat irr D (cm\u00b2/s)'),sg.Input('', key='d_irr_jpc', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True)],
    [sg.Text('Ano k (cm/s)'),sg.Input('', key='k_jpa', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True),sg.Text('Cat k (cm/s)'),sg.Input('', key='k_jpc', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True)],
    ], key='-frame_D_k-')],
    
    [sg.Button('Save parameters', key='save_cv_param'),sg.Button('Save plot', key='save_cv'),sg.Button('Export CV data'),sg.Button('About PySimpleCV'),sg.Button('Exit', key='exit')]
]
cv_D_k_tab = sg.TabGroup([[sg.Tab('CV', cv_cv, key='cv_cv_layout_key'), sg.Tab('Diffusion', cv_diff, key='cv_diff_layout_key'),sg.Tab('Kinetics', cv_kin, key='cv_kin_layout_key')]], enable_events=True)
             
cv_layout = [
            [sg.Checkbox('Plot Jp vs √scanrate for diffusion', default=False, key='enable_d', disabled=False, enable_events=True),sg.Checkbox('Plot Jp vs Ep-E0 for kinetic', default=False, key='enable_k', disabled=False, enable_events=True)],
            [cv_D_k_tab,sg.Column(cv_settings)],
            [sg.Multiline('',size=(155,8), disabled=True, key = 'cv_results_dis', font=('DejaVu Sans Mono', 12), no_scrollbar=False, horizontal_scroll=True)],  
            ]

cv_ecsa1 =[[sg.Canvas(key='-CANVAS_cv_ecsa-')]]
cv_ecsa2 = [
    [sg.Text('Create a rectangle area under the CV plot to calculate the electrochemical active surface area (ECSA) with gas absorption')],
    [sg.ButtonMenu("Add/Open CV file",cv_open_menu,key='cv_open_menu_ecsa'),sg.Button("Load saved CV config", key='cv_load_ecsa'),sg.Combo(values=(), default_value='', readonly=False, key='cv_combo_ecsa', enable_events=True, size=(30,15)),sg.Button("Delete CV File", disabled=True)],
    [sg.Text('.csv file with Voltage on 1st colume and current on 2nd column separated by comma')],
    [sg.Text('iR compensation'),sg.Input(default_text=('0'), key='ir_compen_ecsa',size=(15,5),disabled=True, enable_events=True),sg.Text('Ω'),sg.Text('Electrode area'), sg.Input(default_text=('1'), key='elec_area_ecsa',size=(15,5),disabled=True, enable_events=True),sg.Text('cm\u00b2'),
     sg.Text('Scan rate'),sg.Input(default_text=('0'), key='scan_rate_ecsa',size=(15,5),disabled=True, enable_events=True),sg.Text('V')],
    [sg.Text('Trim CV plot start'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_s_ecsa', disable_number_display=True, enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_cutval_s_ecsa_pos',size=(10,5),disabled=True, enable_events=True)],
    [sg.Text('Trim CV plot end'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_e_ecsa', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_cutval_e_ecsa_pos',size=(10,5),disabled=True, enable_events=True)],
    [sg.Text('Vertical Line'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_v_ln_ecsa', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_v_ln_ecsa_pos',size=(10,5),disabled=True, enable_events=True)],
    [sg.Text('Horizontal Line'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_h_ln_ecsa', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_h_ln_ecsa_pos',size=(10,5),disabled=True, enable_events=True)],
    [sg.Text('Peak search range'),sg.Slider(range=(1, 100), size=cv_slider_size, orientation='h', key='peak_range_ecsa', enable_events=True, disabled=False),sg.Text('position'), sg.Input(default_text=('0'), key='peak_range_ecsa_pos',size=(10,5),disabled=True, enable_events=True)],
    [sg.Text('Area: Voltage x current'),sg.Input(text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(), key='VA_ecsa',size=(15,5),disabled=True, enable_events=True)]
    ]

cv_ecsa_layout = [[sg.Column(cv_ecsa1),sg.Column(cv_ecsa2)]]

rde1 =[[sg.Canvas(key='-CANVAS_rde-')]]
rde1_D =[[sg.Canvas(key='-CANVAS_rde_D-')]]
rde1_kin_curr =[[sg.Canvas(key='-CANVAS_rde_kin_curr-')]]
rde2 = [
    [sg.Text('Rotating Disc Electrode, use slider to find limiting current (Jl)')],
    [sg.ButtonMenu("Add/Open LSV file",rde_open_menu,key='rde_open_menu'),sg.Button("Load saved LSV config", key='rde_load'),sg.Combo(values=(), default_value='', readonly=False, key='rde_combo', enable_events=True, size=(30,15)),sg.Button("Delete LSV File", disabled=True)],
    [sg.Text('.csv file with Voltage on 1st colume and current on 2nd column separated by comma')],
    [sg.Text('iR compensation'),sg.Input(default_text=('0'), key='ir_compen_lsv',size=(10,5),disabled=True, enable_events=True),sg.Text('Ω'),
     sg.Text('Angular velocity'),sg.Input(default_text=('0'), key='rde_ror',size=(10,5),disabled=True, enable_events=True),sg.Combo(values=('RPM','rad/s'), default_value='RPM', readonly=True, key='rde_ror_unit', enable_events=True)],
    [sg.Text('Trim LSV plot start'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_s_lsv', disable_number_display=True, enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_cutval_s_lsv_pos',size=(10,5),disabled=True, enable_events=True)],
    [sg.Text('Trim LSV plot end'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_e_lsv', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_cutval_e_lsv_pos',size=(10,5),disabled=True, enable_events=True)],
    [sg.Text('Average Start'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_avg_s_lsv', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_avg_s_lsv_pos',size=(10,5),disabled=True, enable_events=True)],
    [sg.Text('Average End'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_avg_e_lsv', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_avg_e_lsv_pos',size=(10,5),disabled=True, enable_events=True)],
    
    [sg.Frame('Diffusion Coefficienct Calculation',[   
    [sg.Text('Number of electrons'),sg.Input(default_text=('1'), key='elec_n_rde',size=(3,5),disabled=True, enable_events=True),sg.Text('Electrode area'), sg.Input(default_text=('1'), key='elec_area_rde',size=(5,5),disabled=True, enable_events=True),sg.Text('cm\u00b2'),sg.Text('',key='kinvis_rde_err',enable_events=True)],
    [sg.Text('Kinematic viscosity'),sg.Input(default_text=('1'), key='kinvis_rde',size=(10,5),disabled=True, enable_events=True),sg.Text('cm\u00b2/s'),sg.Text('Bulk concentration'),sg.Input(default_text=('0'), key='bulk_conc_rde',size=(10,5),disabled=True, enable_events=True),sg.Text('mol/cm\u00b3')],
    [sg.Text('Diffusion (cm\u00b2/s)'),sg.Input('', key='rde_D', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(20,5),disabled=True, enable_events=True),sg.Text('Kinetic Current (A)'),sg.Input('', key='rde_kin_curr', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(20,5),disabled=True, enable_events=True)],
    ], key='-frame_rde_D-')]  
    ]

rde_D_tab = sg.TabGroup([[sg.Tab('RDE', rde1, key='rde_layout_key'), sg.Tab('Diffusion', rde1_D , key='rde_D_layout_key'), sg.Tab('Kinetic Current', rde1_kin_curr , key='rde_kin_curr_layout_key')]], enable_events=True)

rde_layout = [
    [rde_D_tab,sg.Column(rde2)],
    [sg.Multiline('',size=(155,8), disabled=True, key = 'rde_results_dis', font=('DejaVu Sans Mono', 12), no_scrollbar=False, horizontal_scroll=True)], 
    ]

# Generate layout for battery cycling tab.
bat_col1=[[sg.Canvas(key='-CANVAS_bat-')]]
bat_col2 = [
    [sg.Button("Open battery file"),sg.Text('.xls files'),
     sg.Checkbox('Voltage', default=True, key='cb_cv_volt', disabled=True, enable_events=True), 
     sg.Checkbox('Current', default=True, key='cb_current', disabled=True, enable_events=True),
     sg.Checkbox('Efficiencies', default=True, key='cb_eff', disabled=True, enable_events=True),
     sg.Checkbox('Capacities', default=True, key='cb_cap', disabled=True, enable_events=True)],
    [sg.Text('Battery file:'), sg.Text('No Battery file selected', key = 'bat_file_use')],
    [sg.Text('Average Voltage efficiency='),sg.Text('', key = 'output_ve'),sg.Text('%')],
    [sg.Text('Average coulombic efficiency='), sg.Text('', key = 'output_ce'),sg.Text('%')],
    [sg.Text('Average energy efficiency='), sg.Text('', key = 'output_ee'),sg.Text('%')],
    [sg.Text('Total number of cycles='), sg.Text('', key= 'tot_cycle')],
    [sg.Text('Voltage, current, energy efficiency(%) for each row of cycle, press ctrl+c to copy')],
    [sg.Text('To copy nicely to spreadsheet software, select space as delimiter and merge delimters.')],
    [sg.Multiline('',size=(90,35), disabled=True, key = 'output_arr')],
    [sg.Text('Cycle start'), sg.Slider(range=(0, 0), size=(50, 8), orientation='h', key='cycle_start', enable_events=True, disabled=False)],
    [sg.Text('Cycle end'), sg.Slider(range=(1, 1), size=(50, 8), orientation='h', key='cycle_end', enable_events=True, disabled=False)],
    [sg.Button('Clear plot',key='bat_clear'),sg.Button('Save plot', key='save_bat'), sg.Button('Exit', key='exit_2')]
    ]          
bat_layout = [[sg.Column(bat_col1),sg.Column(bat_col2)]]

layout = sg.TabGroup([[sg.Tab('CV', cv_layout, key='cv_layout_key'),sg.Tab('CV ECSA', cv_ecsa_layout, key='cv_ecsa_layout_key'),sg.Tab('RDE', rde_layout, key='rde_layout_key'),sg.Tab('Battery Cycling', bat_layout, key='bat_layout_key')]], enable_events=True, expand_x=True, expand_y=True)
          
window = sg.Window('PySimpleCV', [[layout]], finalize=True, element_justification='center')

# window.maximize()
canvas_cv = window['-CANVAS_cv-'].tk_canvas
canvas_cv_D = window['-CANVAS_cv_D-'].tk_canvas
canvas_cv_k = window['-CANVAS_cv_k-'].tk_canvas
canvas_cv_ecsa = window['-CANVAS_cv_ecsa-'].tk_canvas
canvas_rde = window['-CANVAS_rde-'].tk_canvas
canvas_rde_D = window['-CANVAS_rde_D-'].tk_canvas
canvas_rde_kin_curr = window['-CANVAS_rde_kin_curr-'].tk_canvas
canvas_bat = window['-CANVAS_bat-'].tk_canvas

# Generate initial empty plot.
fig_cv = Figure(figsize=(9,9))
ax_cv = fig_cv.add_subplot(111)
ax_cv.set_xlabel("Voltage",fontsize=14)
ax_cv.set_ylabel("Current",fontsize=14)
ax_cv.grid()

fig_cv_D = Figure(figsize=(9,9))
ax_cv_D = fig_cv_D.add_subplot(111)
ax_cv_D.set_xlabel("Scan rate 1/2",fontsize=14)
ax_cv_D.set_ylabel("Jp",fontsize=14)
ax_cv_D.grid()

fig_cv_kin = Figure(figsize=(9,9))
ax_cv_kin = fig_cv_kin.add_subplot(111)
ax_cv_kin.set_xlabel("Ep - E0",fontsize=14)
ax_cv_kin.set_ylabel("Jp",fontsize=14)
ax_cv_kin.grid()

# tight layout push away y label
# fig_cv.tight_layout(pad=2)
fig_agg_cv = draw_figure(canvas_cv, fig_cv)
fig_agg_cv_D = draw_figure(canvas_cv_D, fig_cv_D)
fig_agg_cv_k = draw_figure(canvas_cv_k, fig_cv_kin)

fig_cv_ecsa = Figure(figsize=(9,9))
ax_cv_ecsa = fig_cv_ecsa.add_subplot(111)
ax_cv_ecsa.set_xlabel("Voltage",fontsize=14)
ax_cv_ecsa.set_ylabel("Current",fontsize=14)
ax_cv_ecsa.grid()
fig_agg_cv_ecsa = draw_figure(canvas_cv_ecsa, fig_cv_ecsa)

fig_rde = Figure(figsize=(9,9))
ax_rde = fig_rde.add_subplot(111)
ax_rde.set_xlabel("Voltage",fontsize=14)
ax_rde.set_ylabel("Current",fontsize=14)
ax_rde.grid()
fig_agg_rde = draw_figure(canvas_rde, fig_rde)

fig_rde_D = Figure(figsize=(9,9))
ax_rde_D = fig_rde_D.add_subplot(111)
ax_rde_D.set_xlabel("Rate of Rotation$^{1/2}$",fontsize=14)
ax_rde_D.set_ylabel("Current",fontsize=14)
ax_rde_D.grid()
fig_agg_rde_D = draw_figure(canvas_rde_D, fig_rde_D)

fig_rde_kin_curr = Figure(figsize=(9,9))
ax_rde_kin_curr = fig_rde_kin_curr.add_subplot(111)
ax_rde_kin_curr.set_xlabel("Rate of Rotation$^{-1/2}$",fontsize=14)
ax_rde_kin_curr.set_ylabel("Current$^{-1}$",fontsize=14)
ax_rde_kin_curr.grid()
fig_agg_rde_kin_curr = draw_figure(canvas_rde_kin_curr, fig_rde_kin_curr)

fig_bat = Figure(figsize=(10,10))
ax_bat_volt = fig_bat.add_subplot(111)
ax_bat_current = ax_bat_volt.twinx()
ax_bat_eff = ax_bat_volt.twinx()
ax_bat_cap = ax_bat_volt.twinx()
ax_bat_cycle = ax_bat_volt.twiny()
ax_bat_eff.spines.right.set_position(("axes", 1.11))
ax_bat_cap.spines.right.set_position(("axes", 1.21))
ax_bat_volt.set_ylabel("Voltage",fontsize=14)
ax_bat_current.set_ylabel("Current",fontsize=14)
ax_bat_eff.set_ylabel("Voltage/Coulombic/ Energy Efficiencies",fontsize=14)
ax_bat_cap.set_ylabel("Capacity",fontsize=14)
ax_bat_cycle.set_xlabel("Cycle",fontsize=14)
ax_bat_volt.set_xlabel("Time",fontsize=14)
# Create manual legend so we can put them in the same box
cv_volt_leg = Line2D([0], [0], label='Voltage', color='blue', linestyle='-')
current_leg = Line2D([0], [0], label='Current', color='red', linestyle='--')
VE_leg = Line2D([0], [0], label='VE', color='blue', marker='*', linestyle='None')
CE_leg = Line2D([0], [0], label='CE', color='red', marker='.', linestyle='None')
EE_leg = Line2D([0], [0], label='EE', color='green', marker='^', linestyle='None')
cap_leg = Line2D([0], [0], label='Capacity', color='orange', marker='s', linestyle='None')
bat_legend = ax_bat_volt.legend(handles=[cv_volt_leg,current_leg,VE_leg,CE_leg,EE_leg,cap_leg],ncol=3, bbox_to_anchor=(0.5,-0.25),loc='lower center',fontsize=15, markerscale=3)
for legobj in bat_legend.legendHandles:
    legobj.set_linewidth(3)
    
ax_bat_cycle.grid()
ax_bat_volt.grid(axis='y')
fig_bat.tight_layout()
fig_agg_bat = draw_figure(canvas_bat, fig_bat)

cycle_start = 1
cycle_end = 1

def clear_battery_plot():
    # function to clear the plot.
    # Reset scrolls and checkboxes
    window['cb_cv_volt'].Update(False)
    window['cb_current'].Update(False)
    window['cb_eff'].Update(False)
    window['cb_cv_volt'].Update(disabled=True)
    window['cb_current'].Update(disabled=True)
    window['cb_eff'].Update(disabled=True)
    window['cycle_start'].Update(range=(0,0))
    window['cycle_end'].Update(range=(1,1))
    window['cycle_start'].Update(disabled=True)
    window['cycle_end'].Update(disabled=True)  
    # Remove existing plot.
    ax_bat_current.cla()
    ax_bat_volt.cla()
    ax_bat_eff.cla()
    ax_bat_cap.cla()
    ax_bat_cycle.cla()
    #Redraw Efficiency axis and labels.
    ax_bat_eff.spines.right.set_position(("axes", 1.11))
    ax_bat_cap.spines.right.set_position(("axes", 1.21))
    ax_bat_volt.set_ylabel("Voltage",fontsize=14)
    ax_bat_current.set_ylabel("Current",fontsize=14) 
    ax_bat_eff.set_ylabel("Voltage/Coulombic/ Energy Efficiencies",fontsize=14)
    ax_bat_cap.set_ylabel("Capacity",fontsize=14)
    ax_bat_cycle.set_xlabel("Cycle",fontsize=14)
    ax_bat_volt.set_xlabel("Time",fontsize=14)
    # Move legend to correct position
    ax_bat_current.yaxis.set_label_position("right")
    ax_bat_eff.yaxis.set_label_position("right")
    ax_bat_cap.yaxis.set_label_position("right")
    ax_bat_cycle.xaxis.set_label_position("top")
    # Create manual legend so we can put them in the same box
    cv_volt_leg = Line2D([0], [0], label='Voltage', color='blue', linestyle='-')
    current_leg = Line2D([0], [0], label='Current', color='red', linestyle='--')
    VE_leg = Line2D([0], [0], label='VE', color='blue', marker='*', linestyle='None')
    CE_leg = Line2D([0], [0], label='CE', color='red', marker='.', linestyle='None')
    EE_leg = Line2D([0], [0], label='EE', color='green', marker='^', linestyle='None')
    ax_bat_volt.legend(handles=[cv_volt_leg,current_leg,VE_leg,CE_leg,EE_leg],ncol=5, bbox_to_anchor=(0.5,-0.25),loc='lower center')
    ax_bat_cycle.grid()
    fig_agg_bat.draw()
    
def disable_slider(bool):
    window['sl_cutval_s'].Update(disabled=bool)
    window['sl_cutval_e'].Update(disabled=bool)
    window['sl_jpa_lns'].Update(disabled=bool)
    window['sl_jpa_lne'].Update(disabled=bool)
    window['sl_jpc_lns'].Update(disabled=bool)
    window['sl_jpc_lne'].Update(disabled=bool)
    window['peak_range'].Update(disabled=bool)
    window['peak_pos'].Update(disabled=bool)
    window['trou_pos'].Update(disabled=bool)
    window['inv_jpa_jpc'].Update(disabled=bool)
    window['peak_mode_1'].Update(disabled=bool)
    window['peak_mode_2'].Update(disabled=bool)
    window['nicholson_cb'].Update(disabled=bool)
    window['idx_jsp0'].Update(disabled=bool)
    window['Delete CV File'].Update(disabled=bool)
    window['ir_compen'].Update(disabled=bool)
    window['elec_area'].Update(disabled=bool)
    window['scan_rate'].Update(disabled=bool)
    window['bulk_conc_cv'].Update(disabled=bool)
    window['elec_n_cv'].Update(disabled=bool)
    
    window['sl_cutval_s_pos'].Update(disabled=bool)
    window['sl_cutval_e_pos'].Update(disabled=bool)
    window['sl_jpa_lns_pos'].Update(disabled=bool)    
    window['sl_jpa_lne_pos'].Update(disabled=bool)
    window['sl_jpc_lns_pos'].Update(disabled=bool)
    window['sl_jpc_lne_pos'].Update(disabled=bool)
    window['peak_range_pos'].Update(disabled=bool)
    window['peak_pos_pos'].Update(disabled=bool)
    window['trou_pos_pos'].Update(disabled=bool)
    window['idx_jsp0_pos'].Update(disabled=bool)

    window['sl_cutval_s_ecsa'].Update(disabled=bool)
    window['sl_cutval_e_ecsa'].Update(disabled=bool)    
    window['sl_v_ln_ecsa'].Update(disabled=bool)
    window['sl_h_ln_ecsa'].Update(disabled=bool)
    window['peak_range_ecsa'].Update(disabled=bool)
    window['ir_compen_ecsa'].Update(disabled=bool)
    window['sl_cutval_s_ecsa_pos'].Update(disabled=bool)
    window['sl_cutval_e_ecsa_pos'].Update(disabled=bool)
    window['sl_v_ln_ecsa_pos'].Update(disabled=bool)
    window['sl_h_ln_ecsa_pos'].Update(disabled=bool)
    window['peak_range_ecsa_pos'].Update(disabled=bool)

def disable_slider_lsv(bool):
    window['sl_cutval_s_lsv'].Update(disabled=bool)
    window['sl_cutval_e_lsv'].Update(disabled=bool)
    window['sl_avg_s_lsv'].Update(disabled=bool)
    window['sl_avg_e_lsv'].Update(disabled=bool)
    window['sl_cutval_s_lsv_pos'].Update(disabled=bool)
    window['sl_cutval_e_lsv_pos'].Update(disabled=bool)
    window['sl_avg_s_lsv_pos'].Update(disabled=bool)
    window['sl_avg_e_lsv_pos'].Update(disabled=bool)
    window['ir_compen_lsv'].Update(disabled=bool)
    window['elec_area_rde'].Update(disabled=bool)
    window['bulk_conc_rde'].Update(disabled=bool)
    window['elec_n_rde'].Update(disabled=bool)
    window['kinvis_rde'].Update(disabled=bool)
    window['rde_ror'].Update(disabled=bool)

idx_intc_defl_list = []
curr_list = []
vm_curr_den_list = []
cv_volt_ir_list = []

vm_path_list = []
vm_name_list = []
vm_size_list = []
vm_volt_list = []
vm_curr_list = []
vm_curr_den_list = []
vm_volt_ir_list = []

cv_path_list = []
cv_name_list = []
cv_size_list = []
vm_volt_list = []
cv_curr_list = []

lsv_path_list = []
lsv_name_list = []
lsv_size_list = []
lsv_volt_list = []
lsv_curr_list = []
#                            0         1         2         3       4         5      6           7         8          9          10           11          12           13        14          15        16            17             18              19        20         21        22           23               24            25            26           27            28                 29             30
#                            file name,file format, cutval_s, cutval_e, jpa_lns, jpa_lne, jpc_lns, jpc_lne, peak_pos, trou_pos, peak_range, ir_compen, peak_mode_1, peak_mode_2,elec_area, idx_jsp0, inv_jpa_jpc, scan_rate, nicholson_cb, cutval_s_ecsa, cutval_e_ecsa, v_ln_ecsa, h_ln_ecsa, peak_range_ecsa, cutval_s_rde, cutval_e_rde, sl_avg_s_lsv,sl_avg_e_lsv, rde rotation rate, ir_compen_lsv, rde_ror_unit
fitting_default = np.array([["",       "",          0,        0,        0,       0,       0,       0,       1,        1,        100,        0.,        "max",       "min",      1.,        0,        0,           0.,        0,            0,             0,             0,         0,         1,               0,            0,            0,           0,            0.,                0.,            "RPM"]], dtype=object)
fitting_save_array = np.zeros((1,fitting_default.size), dtype=object)

vm_name_idx_old = -1 #set to -1 so that vm_name_idx != vm_name_idx_old will trigger the first time
ir_compen_old = 0
elec_area_old = 1

ir_compen_lsv_old = 0
elec_area_lsv_old = 1

cv_results = pd.DataFrame(columns =  ["file_name", "scan_rate", "Jpa", "Jpc", "Jpc0", "Epa", "Epc", "Jpa/Jpc", "E\u00bd", "ΔE\u209a", "alpha_ano", "alpha_cat"])
rde_results = pd.DataFrame(columns =  ["file_name", "Rotation", "Unit", "Lim curr"])
while True:
    event, values = window.read()
    # print(event)
    # print(values)
    # print(values[1]) #This print active tab
    if event in (sg.WIN_CLOSED,'exit','exit_2'):
        try:
            shutil.rmtree(temp_path) # Delete temporary files from loading CV tar file.
        except NameError:
            pass
        break
    
    if event == 'About PySimpleCV':
            About_PySimpleCV()
            continue

    if event in ('cv_load_cv', 'cv_load_ecsa', 'rde_load'):
        load_cv_dir = sg.popup_get_file('', no_window=True, file_types=(("TXT Files", "*.txt"), ("All Files", "*.*")))
        if load_cv_dir is None or load_cv_dir == '' or load_cv_dir == ():
            continue
        if not load_cv_dir.endswith('.txt'):
           sg.popup("Wrong file extension, is it .txt?", keep_on_top=True)
           continue
       
        if not load_cv_dir.endswith('.txt'):
           sg.popup("Wrong file extension, is it .txt?", keep_on_top=True)
           continue         
        directory, filename = os.path.split(load_cv_dir)
        filename_without_extension, _ = os.path.splitext(filename)
        
        if event in ('cv_load_cv', 'cv_load_ecsa'):
            results_filename = f"{filename_without_extension}_cv_results.ods"
        elif event == 'rde_load':
            results_filename = f"{filename_without_extension}_rde_results.ods"
        cv_result_path = os.path.join(directory, results_filename)
        if load_cv_dir is None or load_cv_dir == '' or load_cv_dir == ():
            continue
        try:
            # cv_save_dtypes = [('col1', 'U100'), ('col2', 'U100'), ('col3', int), ('col4', int), ('col5', int), ('col6', int), ('col7', int), ('col8', int), ('col9', int), ('col10', int), ('col11', int), ('col12', float), ('col13', 'U100'), ('col14', 'U100'), ('col15', float), ('col16', int), ('col17', int), ('col18', int), ('col19', int), ('col20', int), ('col21', float), ('col22', int), ('col23', int), ('col24', int), ('col25', int), ('col26', int), ('col27', int), ('col28', int), ('col29', float), ('col30', float), ('col31', 'U100')]
            fitting_save_array = np.loadtxt(load_cv_dir,dtype=object, delimiter=',')
            df_save = pd.DataFrame(fitting_save_array,columns=['file name','file format', 'cutval_s', 'cutval_e', 'jpa_lns', 'jpa_lne', 'jpc_lns', 'jpc_lne', 'peak_pos', 'trou_pos', 'peak_range', 'ir_compen', 'peak_mode_1', 'peak_mode_2','elec_area', 'idx_jsp0', 'inv_jpa_jpc', 'scan_rate', 'nicholson_cb', 'cutval_s_ecsa', 'cutval_e_ecsa', 'v_ln_ecsa', 'h_ln_ecsa', 'peak_range_ecsa', 'cutval_s_rde', 'cutval_e_rde', 'sl_avg_s_lsv','sl_avg_e_lsv', 'rde rotation rate', 'ir_compen_lsv', 'rde_ror_unit'])
            # for i in fitting_save_array:
            #     print(i,"$#$$")
            #     cv_save_dtypes = [('col1', 'U100'), ('col2', 'U100'), ('col3', int), ('col4', int), ('col5', int), ('col6', int), ('col7', int), ('col8', int), ('col9', int), ('col10', int), ('col11', int), ('col12', float), ('col13', 'U100'), ('col14', 'U100'), ('col15', float), ('col16', int), ('col17', int), ('col18', int), ('col19', int), ('col20', int), ('col21', float), ('col22', int), ('col23', int), ('col24', int), ('col25', int), ('col26', int), ('col27', int), ('col28', int), ('col29', float), ('col30', float), ('col31', 'U100')]
            #     eer = np.array((i),dtype=cv_save_dtypes)
            #     print(eer,"#######")
            # def custom_convert(value):
            #     try:
            #         # Try to convert the value to an integer
            #         return float(value)
            #     except ValueError:
            #         return value
            
            # # Your data as a list of tuples
            # # data_list = [('0', '0', '0', '1.3', '100', '2.5', '3.7')]
            
            # # Convert the list of tuples to a 2D NumPy array
            # # data_array = np.array(data_list)
            
            # # Apply the custom conversion function to each element of the array
            # fitting_save_array = np.vectorize(custom_convert)(fitting_save_array)
            
            print(df_save)
            file_name_load_mult = df_save['file name'][1]
            print(file_name_load_mult)
            stop
            # fitting_save_array_x = np.array(fitting_save_array)
            # print(fitting_save_array_x,"&&&&&&&&&7")
            
            # def str_to_bool(s):
            #     return s.lower() == 'true'
            
            # # Apply the conversion function to the appropriate column(s)
            # # Assuming the boolean values are in column 19 (0-based index)
            # fitting_save_array[:, 19] = np.vectorize(str_to_bool)(fitting_save_array[:, 19])
            
            # print(fitting_save_array,"JKKKKKKKKKKKKkkk")
            # print(fitting_save_array.type,"UUUUUUUU")
            # test1 = np.array(fitting_save_array[1])
            # print(test1)
            # print(type(test1))
            # print(fitting_save_array[:,1],"YYYYYYYY")
            # This load bool and int as string
            
            cv_results = pd.read_excel(cv_result_path, index_col=0) #Use first column as index
            
            file_name_load_mult = fitting_save_array[1:,0]
            file_form_load_mult = fitting_save_array[1:,1]
            
            
            for i in np.arange(0,len(file_name_load_mult)):
                vm_file = file_name_load_mult[i]
                file_format = file_form_load_mult[i]
                vm_name = os.path.basename(vm_file) #Get file name
                df_vm, file_scan_rate = CV_file2df(vm_file, file_format)       
                vm_size, vm_volt, vm_curr = get_CV_init(df_vm)
                vm_path_list.append(vm_file) #Create 2D array of CVs so we can select, plot, and analyze data based on index
                vm_name_list.append(vm_name)
                vm_volt_list.append(vm_volt)
                vm_curr_list.append(vm_curr)
                
                vm_volt_ir_list.append(vm_volt) #Append cv_volt to ir compensated cv_volt, this is like ir=0
                vm_curr_den_list.append(vm_curr) # This is like elec_area = 1
                vm_size_list.append(vm_size)
                
                if event == 'cv_load_cv':
                    # deflection and Peak detection
                    _, idx_intc_defl = deflection(vm_size,vm_volt,vm_curr)
                    idx_intc_defl_list.append(idx_intc_defl)
    
                window['cv_combo_cv'].Update(values=vm_name_list) # Update combo list of CVs
                window['cv_combo_cv'].Update(vm_name) # Update default combo display
                values['cv_combo_cv'] = vm_name
                window['cv_combo_ecsa'].Update(values=vm_name_list) # Update combo list of CVs
                window['cv_combo_ecsa'].Update(vm_name) # Update default combo display
                values['cv_combo_ecsa'] = vm_name
                disable_slider(False)
                cv_select = vm_name    
                vm_name_idx = vm_name_list.index(cv_select)
        except FileNotFoundError as file_not_found_error:
            sg.popup('CV file not found, maybe missing file was moved',file_not_found_error, keep_on_top=True)
            continue
             
        cv_volt = vm_volt_list[vm_name_idx]
        cv_curr = vm_curr_list[vm_name_idx]
        print(vm_name_idx)
        print(vm_size_list)
        cv_size = vm_size_list[vm_name_idx]
        
        idx_arr = np.arange(0,cv_size)
        idx_defl_points = np.array(idx_intc_defl_list[vm_name_idx])       
        window['sl_cutval_s'].Update(range=(0,cv_size-1))
        window['sl_cutval_e'].Update(range=(0,cv_size-1))
        window['sl_jpa_lns'].Update(range=(0,cv_size-1))
        window['sl_jpa_lne'].Update(range=(0,cv_size-1))
        window['sl_jpc_lns'].Update(range=(0,cv_size-1))
        window['sl_jpc_lne'].Update(range=(0,cv_size-1))
        window['peak_range'].Update(range=(1, 100))
        window['peak_pos'].Update(range=(1, cv_size-1))
        window['trou_pos'].Update(range=(1, cv_size-1))
        window['idx_jsp0'].Update(range=(1, cv_size-1))
        
    if event in ('cv_open_menu', 'cv_open_menu_ecsa', 'rde_open_menu'):
        # vm = voltammogram
        if values['cv_open_menu'] == "VersaSTAT4 (.par)" or values['cv_open_menu_ecsa'] == "VersaSTAT4 (.par)" or values['rde_open_menu'] == "VersaSTAT4 (.par)":              
            file_format = "VersaSTAT"
            vm_file_new = sg.popup_get_file('Choose VersaSTAT4 CV file',multiple_files=True)
            if vm_file_new is None or vm_file_new == '' or vm_file_new == ():
                continue
            if not vm_file_new.endswith('.par'):
               sg.popup("Wrong file extension, is it .par?", keep_on_top=True)
               continue 
        elif values['cv_open_menu'] == "CorrWare (.cor)" or values['cv_open_menu_ecsa'] == "CorrWare (.cor)" or values['rde_open_menu'] == "CorrWare (.cor)":
            file_format = "CorrWare"
            vm_file_new = sg.popup_get_file('Choose CorrWare CV file',multiple_files=True)
            if vm_file_new is None or vm_file_new == '' or vm_file_new == ():
                continue
            if not vm_file_new.endswith('.cor'):
               sg.popup("Wrong file extension, is it .cor?", keep_on_top=True)
               continue
        elif values['cv_open_menu'] == "CSV (.csv)" or values['cv_open_menu_ecsa'] == "CSV (.csv)" or values['rde_open_menu'] == "CSV (.csv)":
            file_format = "CSV"
            vm_file_new = sg.popup_get_file('Choose CSV CV file',multiple_files=True)
            if vm_file_new is None or vm_file_new == '' or vm_file_new == ():
                continue
            if not vm_file_new.endswith('.csv'):
               sg.popup("Wrong file extension, is it .csv?", keep_on_top=True)
               continue 
        elif values['cv_open_menu'] == "text (.txt)" or values['cv_open_menu_ecsa'] == "text (.txt)" or values['rde_open_menu'] == "text (.txt)":
            file_format = "text"
            vm_file_new = sg.popup_get_file('Choose text CV file',multiple_files=True)
            if vm_file_new is None or vm_file_new == '' or vm_file_new == ():
                continue
            if not vm_file_new.endswith('.txt'):
               sg.popup("Wrong file extension, is it .txt?", keep_on_top=True)
               continue 
            
        vm_file_multiple = vm_file_new     
        for vm_file in vm_file_multiple.split(';'):      
            vm_name = os.path.basename(vm_file) #Get file name
            df_vm, file_scan_rate = CV_file2df(vm_file, file_format)       
            vm_size, vm_volt, vm_curr = get_CV_init(df_vm)
            vm_path_list.append(vm_file) #Create 2D array of CVs so we can select, plot, and analyze data based on index
            vm_name_list.append(vm_name)
            vm_volt_list.append(vm_volt)
            vm_curr_list.append(vm_curr)
            vm_volt_ir_list.append(vm_volt) #Append cv_volt to ir compensated cv_volt, this is like ir=0
            vm_curr_den_list.append(vm_curr) # This is like elec_area = 1
            vm_size_list.append(vm_size)
            
            if event == 'cv_open_menu':
                # deflection and Peak detection
                _, idx_intc_defl = deflection(vm_size,vm_volt,vm_curr)
                idx_intc_defl_list.append(idx_intc_defl)
            
            ###############################################################################
            # Add new value from the CV file to save data array
            fitting_default[:,0] = vm_file
            fitting_default[:,1] = file_format
            fitting_default[:,3] = vm_size
            # fitting_default[:,4] = int(cv_size/10)
            ###############################################################################
            
            vm_select = vm_name    
            vm_name_idx = vm_name_list.index(vm_select)

            if event == 'cv_open_menu':
                fitting_default[:,3] = vm_size
                fitting_default[:,17] = file_scan_rate  #Trim end
                window['cv_combo_cv'].Update(values=vm_name_list) # Update combo list of CVs
                window['cv_combo_cv'].Update(vm_name) # Update default combo display
                values['cv_combo_cv'] = vm_name
                cv_results.loc[vm_name_idx] = [vm_select, file_scan_rate, '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
            elif event == 'cv_open_menu_ecsa':
                fitting_default[:,17] = file_scan_rate
                fitting_default[:,20] = vm_size #Trim end
                window['cv_combo_ecsa'].Update(values=vm_name_list) # Update combo list of CVs
                window['cv_combo_ecsa'].Update(vm_name) # Update default combo display
                values['cv_combo_ecsa'] = vm_name
                cv_results.loc[vm_name_idx] = [vm_select, file_scan_rate, '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
            elif event == 'rde_open_menu':
                fitting_default[:,25] = vm_size #Trim end
                window['rde_combo'].Update(values=vm_name_list) # Update combo list of CVs
                window['rde_combo'].Update(vm_name) # Update default combo display
                values['rde_combo'] = vm_name
                rde_results.loc[vm_name_idx] = [vm_select, '0', 'RPM','0']       
            fitting_save_array = np.append(fitting_save_array,fitting_default,axis=0)  
        
        fitting_save_array = np.delete(fitting_save_array, (0), axis=0)
        print(fitting_save_array)
        vm_volt = vm_volt_list[vm_name_idx]
        vm_curr = vm_curr_list[vm_name_idx]
        vm_size = vm_size_list[vm_name_idx]
        
        if event in ('cv_open_menu', 'cv_open_menu_ecsa'):
            disable_slider(False)
            
        if event == 'cv_open_menu':
            idx_arr = np.arange(0,vm_size)
            idx_defl_points = np.array(idx_intc_defl_list[vm_name_idx])
            
        elif event == 'rde_open_menu':
            disable_slider_lsv(False)


    if event in ('cv_open_menu','cv_load_cv', 'cv_combo_cv'): #Change combo also update slider range
        cv_select = values['cv_combo_cv']
        if values['cv_combo_cv'] == '': #Prevent error when combo box value is empty
            vm_name_idx = 0
        else:
            vm_name_idx = vm_name_list.index(cv_select)  
        cv_volt = vm_volt_list[vm_name_idx]
        cv_curr = vm_curr_list[vm_name_idx]
        cv_size = vm_size_list[vm_name_idx]
        idx_arr = np.arange(0,vm_size)
        idx_defl_points = np.array(idx_intc_defl_list[vm_name_idx]) 
        window['sl_cutval_s'].Update(range=(0,cv_size-1))
        window['sl_cutval_e'].Update(range=(0,cv_size-1))
        window['sl_jpa_lns'].Update(range=(0,cv_size-1))
        window['sl_jpa_lne'].Update(range=(0,cv_size-1))
        window['sl_jpc_lns'].Update(range=(0,cv_size-1))
        window['sl_jpc_lne'].Update(range=(0,cv_size-1))
        window['peak_range'].Update(range=(1, int(0.05*vm_size)))
        window['peak_pos'].Update(range=(1, cv_size-1))
        window['trou_pos'].Update(range=(1, cv_size-1))
        window['idx_jsp0'].Update(range=(1, cv_size-1))
        if vm_name_idx != vm_name_idx_old: #If the option index change (combo box change), update slider
            vm_name_idx_old = vm_name_idx                    
            # Restore saved values
            cutval_s_save = int(fitting_save_array[vm_name_idx+1,2])
            cutval_e_save = int(fitting_save_array[vm_name_idx+1,3])
            jpa_lns_save = int(fitting_save_array[vm_name_idx+1,4])
            jpa_lne_save = int(fitting_save_array[vm_name_idx+1,5])
            jpc_lns_save = int(fitting_save_array[vm_name_idx+1,6])
            jpc_lne_save = int(fitting_save_array[vm_name_idx+1,7])
            peak_pos_save = int(fitting_save_array[vm_name_idx+1,8])
            trou_pos_save = int(fitting_save_array[vm_name_idx+1,9])
            peak_range_save = int(fitting_save_array[vm_name_idx+1,10])
            ir_compen_save = float(fitting_save_array[vm_name_idx+1,11])
            peak_mode_1_save = str(fitting_save_array[vm_name_idx+1,12])
            peak_mode_2_save = str(fitting_save_array[vm_name_idx+1,13])
            elec_area_save = float(fitting_save_array[vm_name_idx+1,14])
            idx_jsp0_save = int(fitting_save_array[vm_name_idx+1,15])
            inv_jpa_jpc_save = int(fitting_save_array[vm_name_idx+1,16])
            scan_rate_save = float(fitting_save_array[vm_name_idx+1,17])
            nicholson_cb_save = int(fitting_save_array[vm_name_idx+1,18])
            print(fitting_save_array,"PPPPPPPPPPPPP")
            # Put slider to previous position, this is just what is shown not real value
            window['sl_cutval_s'].Update(cutval_s_save)
            window['sl_cutval_e'].Update(cutval_e_save)           
            window['sl_jpa_lns'].Update(jpa_lns_save)
            window['sl_jpa_lne'].Update(jpa_lne_save)
            window['sl_jpc_lns'].Update(jpc_lns_save)
            window['sl_jpc_lne'].Update(jpc_lne_save)
            window['peak_pos'].Update(peak_pos_save)
            window['trou_pos'].Update(trou_pos_save)
            window['peak_range'].Update(peak_range_save)
            window['ir_compen'].Update(ir_compen_save)
            window['peak_mode_1'].Update(peak_mode_1_save)
            window['peak_mode_2'].Update(peak_mode_2_save)
            window['elec_area'].Update(elec_area_save)
            window['idx_jsp0'].Update(idx_jsp0_save)
            window['inv_jpa_jpc'].Update(inv_jpa_jpc_save)
            window['scan_rate'].Update(scan_rate_save)
            window['nicholson_cb'].Update(nicholson_cb_save)
            # Put actual value             
            values['sl_cutval_s'] = cutval_s_save
            values['sl_cutval_e'] = cutval_e_save           
            values['sl_jpa_lns'] = jpa_lns_save
            values['sl_jpa_lne'] = jpa_lne_save
            values['sl_jpc_lns'] = jpc_lns_save
            values['sl_jpc_lne'] = jpc_lne_save
            values['peak_pos'] = peak_pos_save
            values['trou_pos'] = trou_pos_save
            values['peak_range'] = peak_range_save
            values['ir_compen'] = ir_compen_save
            values['peak_mode_1'] = peak_mode_1_save
            values['peak_mode_2'] = peak_mode_2_save
            values['elec_area'] = elec_area_save
            values['idx_jsp0'] = idx_jsp0_save
            values['inv_jpa_jpc'] = inv_jpa_jpc_save
            values['scan_rate'] = scan_rate_save
            values['nicholson_cb'] = nicholson_cb_save            
            # Assign the value from saved data
            cutval_s = cutval_s_save
            cutval_e = cutval_e_save
            jpa_lns = jpa_lns_save
            jpa_lne = jpa_lne_save
            jpc_lns = jpc_lns_save
            jpc_lne = jpc_lne_save
            peak_pos = peak_pos_save
            trou_pos = trou_pos_save
            peak_range = peak_range_save
            ir_compen = ir_compen_save
            peak_mode_1 = peak_mode_1_save
            peak_mode_2 = peak_mode_2_save
            elec_area = elec_area_save
            idx_jsp0 = idx_jsp0_save
            inv_jpa_jpc = inv_jpa_jpc_save
            scan_rate = scan_rate_save
            print(nicholson_cb_save)
            nicholson_cb = nicholson_cb_save
            
    if event in ('cv_open_menu', 'cv_load_cv', 'ir_compen', 'elec_area','inv_jpa_jpc', 'sl_cutval_s', 'sl_cutval_e', 'sl_jpa_lns', 'sl_jpa_lne',  'sl_jpc_lns', 'sl_jpc_lne', 'peak_range', 'peak_pos', 'trou_pos', 'sl_cutval_s_pos', 'sl_cutval_e_pos', 'sl_jpa_lns_pos', 'sl_jpa_lne_pos',  'sl_jpc_lns_pos', 'sl_jpc_lne_pos', 'peak_range_pos', 'peak_pos_pos', 'trou_pos_pos', 'nicholson_cb', 'idx_jsp0', 'idx_jsp0_pos', 'scan_rate', 'bulk_conc_cv', 'elec_n_cv', 'enable_d', 'enable_k','peak_mode_1', 'peak_mode_2'):
        cutval_s = int(values['sl_cutval_s'])
        cutval_e = int(values['sl_cutval_e'])        
        jpa_lns = int(values['sl_jpa_lns'])
        jpa_lne = int(values['sl_jpa_lne'])
        jpc_lns = int(values['sl_jpc_lns'])
        jpc_lne = int(values['sl_jpc_lne'])
        peak_pos = int(values['peak_pos'])
        trou_pos = int(values['trou_pos'])
        peak_range = int(values['peak_range'])
        peak_mode_1 = str(values['peak_mode_1'])
        peak_mode_2 = str(values['peak_mode_2'])
        idx_jsp0 = int(values['idx_jsp0'])
        inv_jpa_jpc = int(values['inv_jpa_jpc'])
        nicholson_cb = int(values['nicholson_cb'])
        # Make sure that proper number format is used
        ir_compen = check_val(values['ir_compen'], "float", 0)
        scan_rate = check_val(values['scan_rate'], "float", 0)
        elec_area = check_val(values['elec_area'], "float", 1)    
        bulk_conc_cv = check_val(values['bulk_conc_cv'], "float", 0) 
        elec_n_cv = check_val(values['elec_n_cv'], "int", 1) 
        
        
        cutval_s_pos = check_val(values['sl_cutval_s_pos'], "int", 1)
        cutval_e_pos = check_val(values['sl_cutval_e_pos'], "int", 1)  
        jpa_lns_pos = check_val(values['sl_jpa_lns_pos'], "int", 1)
        jpa_lne_pos = check_val(values['sl_jpa_lne_pos'], "int", 1)  
        jpc_lns_pos = check_val(values['sl_jpc_lns_pos'], "int", 1)  
        jpc_lne_pos = check_val(values['sl_jpc_lne_pos'], "int", 1)  
        peak_range_pos = check_val(values['peak_range_pos'], "int", 1)  
        peak_pos_pos = check_val(values['peak_pos_pos'], "int", 1) 
        trou_pos_pos = check_val(values['trou_pos_pos'], "int", 1)
        idx_jsp0_pos = check_val(values['idx_jsp0_pos'], "int", 1)
        
        if event == 'sl_cutval_s':
            window['sl_cutval_s_pos'].Update(cutval_s)
        elif event == 'sl_cutval_s_pos':
            window['sl_cutval_s'].Update(cutval_s_pos)
            cutval_s = cutval_s_pos
            
        elif event == 'sl_cutval_e':
            window['sl_cutval_e_pos'].Update(cutval_e)
        elif event == 'sl_cutval_e_pos':
            window['sl_cutval_e'].Update(cutval_e_pos)
            cutval_e = cutval_e_pos
        
        elif event == 'sl_jpa_lns':
            window['sl_jpa_lns_pos'].Update(jpa_lns)
        elif event == 'sl_jpa_lns_pos':
            window['sl_jpa_lns'].Update(jpa_lns)
            jpa_lns = jpa_lns_pos
            
        elif event == 'sl_jpa_lne':
            window['sl_jpa_lne_pos'].Update(jpa_lne)
        elif event == 'sl_jpa_lne_pos':
            window['sl_jpa_lne'].Update(jpa_lne)
            jpa_lne = jpa_lne_pos
            
        elif event == 'sl_jpc_lns':
            window['sl_jpc_lns_pos'].Update(jpc_lns)
        elif event == 'sl_jpc_lns_pos':
            window['sl_jpc_lns'].Update(jpc_lns)
            jpc_lns = jpc_lns_pos
            
        elif event == 'sl_jpc_lne':
            window['sl_jpc_lne_pos'].Update(jpc_lne)
        elif event == 'sl_jpc_lne_pos':
            window['sl_jpc_lne'].Update(jpc_lne)
            jpc_lne = jpc_lne_pos
            
        elif event == 'peak_range':
            window['peak_range_pos'].Update(peak_range)
        elif event == 'peak_range_pos':
            window['peak_range'].Update(peak_range_pos)
            peak_range = peak_range_pos     
            
        elif event == 'peak_pos':
            window['peak_pos_pos'].Update(peak_pos)
        elif event == 'peak_pos_pos':
            window['peak_pos'].Update(peak_pos_pos)
            peak_pos = peak_pos_pos     
            
        elif event == 'trou_pos':
            window['trou_pos_pos'].Update(trou_pos)
        elif event == 'trou_pos_pos':
            window['trou_pos'].Update(trou_pos_pos)
            trou_pos = trou_pos_pos   
            
        elif event == 'idx_jsp0':
            window['idx_jsp0_pos'].Update(idx_jsp0)
        elif event == 'idx_jsp0_pos':
            window['idx_jsp0'].Update(idx_jsp0_pos)
            idx_jsp0 = idx_jsp0_pos      
        cutval_s,cutval_e = switch_val(cutval_s,cutval_e)
        jpa_lns,jpa_lne = switch_val(jpa_lns,jpa_lne)
        jpc_lns,jpc_lne = switch_val(jpc_lns,jpc_lne)
        
        fitting_save_cv = np.array([cutval_s, cutval_e, jpa_lns, jpa_lne, jpc_lns, jpc_lne, peak_pos, trou_pos, peak_range, ir_compen, peak_mode_1, peak_mode_2,elec_area, idx_jsp0, inv_jpa_jpc, scan_rate, nicholson_cb], dtype=object)
        
        fitting_save_array[vm_name_idx+1][2:19] = fitting_save_cv
        if ir_compen != ir_compen_old:
            ir_compen_old = ir_compen
            volt_compen_cv = ir_compen_func(cv_volt,cv_curr,ir_compen)
            # Overwrite cv_volt and curr with ir compen
            vm_volt_ir_list[vm_name_idx] = volt_compen_cv
        else:
            volt_compen_cv = vm_volt_ir_list[vm_name_idx]
        
        if elec_area != elec_area_old:
            elec_area_old = elec_area
            cv_curr_den = cv_curr/elec_area
            # Overwrite cv_curr with cv_curr density
            vm_curr_den_list[vm_name_idx] = cv_curr_den
        else:
            cv_curr_den = vm_curr_den_list[vm_name_idx]
    
        if peak_mode_1 == 'deflection':
            peak_pos = idx_defl_points[np.abs(idx_defl_points - peak_pos).argmin()]
            peak_pos = int(peak_pos)
        if peak_mode_2 == 'deflection':
            trou_pos = idx_defl_points[np.abs(idx_defl_points - trou_pos).argmin()]
            trou_pos = int(trou_pos)
            
        ax_cv.cla() ###### Clear plot before redraw    
        if nicholson_cb == 0:
            low_range_a, high_range_a, peak_cv_volt, peak_curr_a, jpa, jpa_poly1d = get_peak_CV(peak_mode_1,cv_size, cv_volt, cv_curr, peak_range, peak_pos, jpa_lns, jpa_lne)
            low_range_c, high_range_c, trou_cv_volt, peak_curr_c, jpc, jpc_poly1d = get_peak_CV(peak_mode_2,cv_size, cv_volt, cv_curr, peak_range, trou_pos, jpc_lns, jpc_lne)                
            
            # Find alpha
            ep12_jpa, jp12_jpa, alpha_jpa = find_alpha(volt_compen_cv,cv_curr_den,jpa_lns,peak_pos,jpa_poly1d,jpa,peak_cv_volt)
            ep12_jpc, jp12_jpc, alpha_jpc = find_alpha(volt_compen_cv,cv_curr_den,jpc_lns,trou_pos,jpc_poly1d,jpc,trou_cv_volt)
            
            ax_cv.plot(ep12_jpa,jp12_jpa,'x')
            ax_cv.plot(ep12_jpc,jp12_jpc,'x')
            
            # Find estimate standard electrode potential (E1/2~E0)
            E1_2 = (trou_cv_volt+peak_cv_volt)/2
            # Find peak-peak separation Voltage
            delta_e = np.abs(trou_cv_volt-peak_cv_volt)
            
            ax_cv.plot(E1_2,0,"D", markersize = 6)
            
            
            ax_cv.plot((volt_compen_cv[low_range_a],volt_compen_cv[high_range_a]),(cv_curr_den[low_range_a],cv_curr_den[high_range_a]),"|", markersize = 10)
            ax_cv.plot((volt_compen_cv[low_range_c],volt_compen_cv[high_range_c]),(cv_curr_den[low_range_c],cv_curr_den[high_range_c]),"|", markersize = 10)
        
            ax_cv.plot(volt_compen_cv[jpa_lns:jpa_lne],cv_curr_den[jpa_lns:jpa_lne],linewidth=2,linestyle='-', color='red')
            ax_cv.arrow(peak_cv_volt,jpa_poly1d(peak_cv_volt),0,jpa,linewidth=0.2,head_width=0.005, head_length=0.0003 ,color='r', length_includes_head=True)
            ax_cv.plot(np.array([volt_compen_cv[jpa_lns],peak_cv_volt]),np.array([jpa_poly1d(volt_compen_cv[jpa_lns]),jpa_poly1d(peak_cv_volt)]),'--', color='red')
            
            ax_cv.plot(volt_compen_cv[jpc_lns:jpc_lne],cv_curr_den[jpc_lns:jpc_lne],linewidth=2,linestyle='-',color='blue')
            ax_cv.arrow(trou_cv_volt,jpc_poly1d(trou_cv_volt),0,jpc,linewidth=0.2,head_width=0.005, head_length=0.0003, color='b', length_includes_head=True)
            ax_cv.plot(np.array([volt_compen_cv[jpc_lns],trou_cv_volt]),np.array([jpc_poly1d(volt_compen_cv[jpc_lns]),jpc_poly1d(trou_cv_volt)]),'--', color='blue')
            jpc0 = 0 #Only with Nicholson method
            jpc = np.abs(jpc) # Report positive value
        elif nicholson_cb == 1:
            if values['inv_jpa_jpc'] == True: 
                jp1_text = 'jpc'
                jp2_text = 'jpa0'
            else:
                jp1_text = 'jpa'
                jp2_text = 'jpc0'
            jpc0_lns = jpa_lns
            jpc0_lne = jpa_lne
            
            low_range_a, high_range_a, peak_cv_volt, peak_curr_a, jpa, jpa_poly1d = get_peak_CV(peak_mode_1,cv_size, cv_volt, cv_curr, peak_range, peak_pos, jpa_lns, jpa_lne)
            low_range_c, high_range_c, trou_cv_volt, peak_curr_c, jpc0, _ = get_peak_CV(peak_mode_2,cv_size, cv_volt, cv_curr, peak_range, trou_pos, jpa_lns, jpa_lne)
            # Find estimate standard electrode potential (E1/2~E0)
            E1_2 = (peak_cv_volt+trou_cv_volt)/2
            # Find peak-peak separation Voltage
            delta_e = np.abs(trou_cv_volt-peak_cv_volt)
            ax_cv.plot(E1_2,0,"D", markersize = 6)
        
            ax_cv.plot((volt_compen_cv[low_range_a],volt_compen_cv[high_range_a]),(cv_curr_den[low_range_a],cv_curr_den[high_range_a]),"|", markersize = 10)
            ax_cv.plot((volt_compen_cv[low_range_c],volt_compen_cv[high_range_c]),(cv_curr_den[low_range_c],cv_curr_den[high_range_c]),"|", markersize = 10)
        
            ax_cv.plot(np.array([volt_compen_cv[jpa_lns],peak_cv_volt]),np.array([jpa_poly1d(volt_compen_cv[jpa_lns]),jpa_poly1d(peak_cv_volt)]),'--', color='green') #Peak
            ax_cv.plot(np.array([volt_compen_cv[jpa_lns],trou_cv_volt]),np.array([jpa_poly1d(volt_compen_cv[jpa_lns]),jpa_poly1d(trou_cv_volt)]),'--', color='green') #Peak    
            ax_cv.arrow(trou_cv_volt,jpa_poly1d(trou_cv_volt),0,jpc0,linewidth=0.2,head_width=0.005, head_length=0.0003 ,color='green', length_includes_head=True) #jpc0 
            ax_cv.arrow(peak_cv_volt,jpa_poly1d(peak_cv_volt),0,jpa,linewidth=0.2,head_width=0.005, head_length=0.0003, color='black', length_includes_head=True) #jpa
    
            jsp0_cv_volt = volt_compen_cv[idx_jsp0]
            jsp0 = cv_curr_den[idx_jsp0]-jpa_poly1d(jsp0_cv_volt)
            ax_cv.plot(np.array([volt_compen_cv[jpa_lns],volt_compen_cv[idx_jsp0]]),np.array([jpa_poly1d(volt_compen_cv[jpa_lns]),jpa_poly1d(jsp0_cv_volt)]),'--', color='green') #jsp0
            ax_cv.plot(volt_compen_cv[jpa_lns:jpa_lne],cv_curr_den[jpa_lns:jpa_lne],linewidth=3,linestyle='-', color='blue')
            ax_cv.arrow(volt_compen_cv[idx_jsp0],jpa_poly1d(jsp0_cv_volt),0,jsp0,linewidth=0.2,head_width=0.005, head_length=0.0003, color='b', length_includes_head=True) #jsp0
            
            ax_cv.text(peak_cv_volt,jpa_poly1d(peak_cv_volt), jp1_text, fontsize=10)
            ax_cv.text(trou_cv_volt,jpa_poly1d(trou_cv_volt), jp2_text, fontsize=10)
            ax_cv.text(volt_compen_cv[idx_jsp0],jpa_poly1d(jsp0_cv_volt), 'jsp0', fontsize=10)
            
            jpa = np.abs(jpa)
            jpc0 = np.abs(jpc0)
            jsp0 = np.abs(jsp0)
            # Nicholson, R. S. Semiempirical Procedure for Measuring with
            # Stationary Electrode Polarography Rates of Chemical Reactions
            # Involving the Product of Electron Transfer. Anal. Chem. 1966, 38
            # (10), 1406.
            jpc = np.abs(jpa*((jpc0/jpa)+((0.485*np.abs(jsp0))/jpa)+0.086))
            window['jsp0_cv_volt'].Update(jsp0_cv_volt)            
            # invert jpa and jpc or not
        if values['inv_jpa_jpc'] == True:
            jpa, jpc = jpc, jpa
            alpha_jpa, alpha_jpc = alpha_jpc, alpha_jpa
                
        # Plot lines
        vm_volt_list_len = len(vm_volt_list)
        for j in np.arange(0,vm_volt_list_len):
            cutval_s_all = int(fitting_save_array[j+1,2])
            cutval_e_all = int(fitting_save_array[j+1,3])
            ax_cv.plot(np.array(vm_volt_ir_list[j][cutval_s_all:cutval_e_all]).T, np.array(vm_curr_den_list[j][cutval_s_all:cutval_e_all]).T, '-', color='black',linewidth=1)
        
        if peak_mode_1 == "deflection" or peak_mode_2 == "deflection":
            clip_defl = idx_defl_points[(idx_defl_points >= cutval_s) & (idx_defl_points <= cutval_e)]
            cv_volt_defl = np.interp([clip_defl], idx_arr, volt_compen_cv)
            curr_defl = np.interp([clip_defl], idx_arr, cv_curr_den)
            ax_cv.plot(cv_volt_defl,curr_defl,'.',color='green')
        ax_cv.grid()
        ax_cv.set_xlabel("Voltage")
        ax_cv.set_ylabel("Current")       
        fig_agg_cv.draw()

        cv_results.loc[vm_name_idx] = [cv_select, scan_rate, jpa, jpc, jpc0, peak_cv_volt, trou_cv_volt, jpa/jpc, E1_2, delta_e, alpha_jpa, alpha_jpc]
        cv_results = cv_results.sort_index()
        window['cv_results_dis'].Update(cv_results.to_string(index=False))
            

        
        alpha_ano = np.average(np.asarray(cv_results.loc[:,'alpha_ano'].to_numpy(), dtype=float))
        alpha_cat = np.average(np.asarray(cv_results.loc[:,'alpha_cat'].to_numpy(), dtype=float))
        window['alpha_ano'].Update(alpha_ano)
        window['alpha_cat'].Update(alpha_cat)    

        if values['enable_d'] == True and values[0] == 'cv_diff_layout_key':
            jpc_arr = np.asarray(cv_results.loc[:,'Jpc'].to_numpy(), dtype=float)
            jpa_arr = np.asarray(cv_results.loc[:,'Jpa'].to_numpy(), dtype=float)
            scan = np.array([float(value) for value in cv_results['scan_rate']])
            # Plot peak cv_curr vs scan rate^1/2 to find diffusion coefficient
            ax_cv_D.cla()
            try:
                sqrt_scan_ano, jpa_fit ,D_irr_a ,D_rev_a ,r2_ano = diffusion(scan,jpa_arr,alpha_ano,bulk_conc_cv,elec_n_cv)
                sqrt_scan_cat, jpc_fit ,D_irr_c ,D_rev_c ,r2_cat = diffusion(scan,jpc_arr,alpha_cat,bulk_conc_cv,elec_n_cv)
                ax_cv_D.plot(sqrt_scan_ano,jpa_fit,'-',color='red')
                ax_cv_D.plot(sqrt_scan_cat,jpc_fit,'-',color='blue')
                window['d_rev_jpa'].Update(f"{D_rev_a:e}")
                window['d_rev_jpc'].Update(f"{D_rev_c:e}")
                window['d_irr_jpa'].Update(f"{D_irr_a:e}")
                window['d_irr_jpc'].Update(f"{D_irr_c:e}")
            except SystemError:
                pass
            ax_cv_D.plot(sqrt_scan_ano,jpa_arr,'o',color='red',label='Jpa')
            ax_cv_D.plot(sqrt_scan_cat,jpc_arr,'o',color='blue',label='Jpc')
            ax_cv_D.set_xlabel("Scan rate 1/2")
            ax_cv_D.set_ylabel("Jp")
            fig_cv_D.legend()
            fig_agg_cv_D.draw()
        #Find kinetic parameter
        if values['enable_k'] == True and values[0] == 'cv_kin_layout_key':
            jpc_arr = np.asarray(cv_results.loc[:,'Jpc'].to_numpy(), dtype=float)
            jpa_arr = np.asarray(cv_results.loc[:,'Jpa'].to_numpy(), dtype=float)
            e_e0_arr = (np.array([float(value) for value in cv_results['ΔE\u209a']]))/2
            ax_cv_kin.cla()
            try: 
                lnjpa, lnjpa_fit, k0_a, alpha_cat_a, alpha_ano_a, r2_a = reaction_rate(e_e0_arr,jpa_arr,bulk_conc_cv,elec_n_cv)
                lnjpc, lnjpc_fit, k0_c, alpha_cat_c, alpha_ano_c, r2_c = reaction_rate(e_e0_arr,jpc_arr,bulk_conc_cv,elec_n_cv)
                ax_cv_kin.plot(e_e0_arr,lnjpa_fit,'-',color='red')
                ax_cv_kin.plot(e_e0_arr,lnjpc_fit,'-',color='blue')
                window['k_jpa'].Update(f"{k0_a:e}")
                window['k_jpc'].Update(f"{k0_c:e}")
            except SystemError:
                pass            
            ax_cv_kin.plot(e_e0_arr,lnjpa,'o',color='red',label='Jpa')
            ax_cv_kin.plot(e_e0_arr,lnjpc,'o',color='blue',label='Jpc')
            ax_cv_kin.set_xlabel("Ep - E0")
            ax_cv_kin.set_ylabel("Jp")
            fig_cv_kin.legend()
            fig_agg_cv_k.draw()
            
    if event == 'Export CV data':
        cv_data_path = sg.popup_get_file('', save_as=True, no_window=True, file_types=(("ODS Files", "*.ods"), ("All Files", "*.*")))
        # Find the maximum length among all arrays
        cv_max_length = max(len(x) for x in vm_volt_list + vm_curr_list)     
        # Create dictionaries with padding to max_length
        cv_data = {}
        for i, (x, y) in enumerate(zip(vm_volt_list, vm_curr_list), start=1):
            padded_x = np.pad(x.astype(float), (0, cv_max_length - len(x)), constant_values=np.nan)
            padded_y = np.pad(y.astype(float), (0, cv_max_length - len(y)), constant_values=np.nan)
            cv_data[f'{vm_name_list[i-1]}_cv_volt_{i}'] = padded_x
            cv_data[f'{vm_name_list[i-1]}_curr_{i}'] = padded_y     
        cv_data_dir, filename = os.path.split(cv_data_path)
        filename_without_extension, _ = os.path.splitext(filename)
        results_filename = f"{filename_without_extension}_cv_results.ods"
        cv_data_path = os.path.join(cv_data_dir, results_filename)
        pd.DataFrame(cv_data).to_excel(cv_data_path, index=True)        

    if event == 'save_cv_param':
        cv_param = sg.popup_get_file('', save_as=True, no_window=True, file_types=(("TXT Files", "*.txt"), ("All Files", "*.*")))
        cv_param_dir, filename = os.path.split(cv_param)
        filename_without_extension, _ = os.path.splitext(filename)
        results_filename = f"{filename_without_extension}_cv_results.ods"
        cv_result_path = os.path.join(cv_param_dir, results_filename)

        np.savetxt(cv_param, fitting_save_array, delimiter=',', fmt='%s')
        cv_results.to_excel(cv_result_path, index=True)

        #====================================================================================#
        #======================================CV ECSA ======================================#
        #====================================================================================#
        
    if event in ('cv_open_menu_ecsa', 'cv_load_ecsa','cv_combo_ecsa'):
        cv_select = values['cv_combo_ecsa']
        if values['cv_combo_ecsa'] == '': #Prevent error when combo box value is empty
            vm_name_idx = 0
        else:
            vm_name_idx = vm_name_list.index(cv_select)
        cv_volt = vm_volt_list[vm_name_idx]
        cv_curr = vm_curr_list[vm_name_idx]
        cv_size = vm_size_list[vm_name_idx]
        idx_arr = np.arange(0,cv_size)
        idx_defl_points = np.array(idx_intc_defl_list[vm_name_idx]) 
        window['sl_cutval_s_ecsa'].Update(range=(0,cv_size-1))
        window['sl_cutval_e_ecsa'].Update(range=(0,cv_size-1))
        window['sl_v_ln_ecsa'].Update(range=(0,cv_size-1))
        window['sl_h_ln_ecsa'].Update(range=(0,cv_size-1))
        window['peak_range_ecsa'].Update(range=(1,int(0.05*vm_size)))  
        
        if vm_name_idx != vm_name_idx_old: #If the option index change (combo box change), update slider
            vm_name_idx_old = vm_name_idx                    
            # Restore saved values        
            cutval_s_ecsa_save = int(fitting_save_array[vm_name_idx+1,19])
            cutval_e_ecsa_save = int(fitting_save_array[vm_name_idx+1,20])               
            v_ln_ecsa_save = int(fitting_save_array[vm_name_idx+1,21])
            h_ln_ecsa_save = int(fitting_save_array[vm_name_idx+1,22])
            peak_range_ecsa_save = int(fitting_save_array[vm_name_idx+1,23])
            # Put slider to previous position
            window['sl_cutval_s_ecsa'].Update(cutval_s_ecsa_save)
            window['sl_cutval_e_ecsa'].Update(cutval_e_ecsa_save)
            window['sl_v_ln_ecsa'].Update(v_ln_ecsa_save)
            window['sl_h_ln_ecsa'].Update(h_ln_ecsa_save)
            window['peak_range_ecsa'].Update(peak_range_ecsa_save)  
            window['sl_cutval_s_ecsa_pos'].Update(cutval_s_ecsa_save)
            window['sl_cutval_e_ecsa_pos'].Update(cutval_e_ecsa_save)
            window['sl_v_ln_ecsa_pos'].Update(v_ln_ecsa_save)                   
            window['sl_h_ln_ecsa_pos'].Update(h_ln_ecsa_save)
            window['peak_range_ecsa_pos'].Update(h_ln_ecsa_save)
            # Put actual value    
            values['sl_cutval_s_ecsa'] = cutval_s_ecsa_save
            values['sl_cutval_e_ecsa'] = cutval_e_ecsa_save
            values['sl_v_ln_ecsa'] = v_ln_ecsa_save
            values['sl_h_ln_ecsa'] = h_ln_ecsa_save
            values['peak_range_ecsa'] = peak_range_ecsa_save
            values['sl_cutval_s_ecsa_pos'] = cutval_s_ecsa_save
            values['sl_cutval_e_ecsa_pos'] = cutval_e_ecsa_save
            values['sl_v_ln_ecsa_pos'] = v_ln_ecsa_save          
            values['sl_h_ln_ecsa_pos'] = h_ln_ecsa_save
            values['peak_range_ecsa_pos'] = h_ln_ecsa_save
            
            # Assign the value from saved data
            cutval_s_ecsa = cutval_s_ecsa_save
            cutval_e_ecsa = cutval_e_ecsa_save
            v_ln_ecsa = v_ln_ecsa_save
            h_ln_ecsa = h_ln_ecsa_save
            cutval_s_ecsa_pos = cutval_s_ecsa_save
            cutval_e_ecsa_pos = cutval_e_ecsa_save
            v_ln_ecsa_pos = v_ln_ecsa_save
            h_ln_ecsa_pos = h_ln_ecsa_save
            peak_range_ecsa = peak_range_ecsa_save
        
    if event in ('cv_open_menu_ecsa', 'sl_v_ln_ecsa', 'sl_h_ln_ecsa', 'sl_cutval_s_ecsa', 'sl_cutval_e_ecsa', 'peak_range_ecsa', 'ir_compen_ecsa', 'sl_cutval_s_ecsa_pos', 'sl_cutval_e_ecsa_pos', 'sl_v_ln_ecsa_pos', 'sl_h_ln_ecsa_pos', 'peak_range_ecsa_pos'):
        cutval_s_ecsa = int(values['sl_cutval_s_ecsa'])
        cutval_e_ecsa = int(values['sl_cutval_e_ecsa'])
        v_ln_ecsa = int(values['sl_v_ln_ecsa'])
        h_ln_ecsa = int(values['sl_h_ln_ecsa'])  
        peak_range_ecsa = int(values['peak_range_ecsa'])
        # Make sure that proper number format is used
        ir_compen = check_val(values['ir_compen'], "float", 0)
        scan_rate = check_val(values['scan_rate'], "float", 0)
        elec_area = check_val(values['elec_area'], "float", 1)
        
        cutval_s_ecsa_pos = check_val(values['sl_cutval_s_ecsa_pos'], "int", 1)
        cutval_e_ecsa_pos = check_val(values['sl_cutval_e_ecsa_pos'], "int", 1)    
        v_ln_ecsa_pos = check_val(values['sl_v_ln_ecsa_pos'], "int", 1)
        h_ln_ecsa_pos = check_val(values['sl_h_ln_ecsa_pos'], "int", 1)   
        peak_range_ecsa_pos = check_val(values['peak_range_ecsa_pos'], "int", 1)
            
        if event == 'sl_cutval_s_ecsa':
            window['sl_cutval_s_ecsa_pos'].Update(cutval_s_ecsa)
        elif event == 'sl_cutval_s_ecsa_pos':
            window['sl_cutval_s_ecsa'].Update(cutval_s_ecsa_pos)
            cutval_s_ecsa = cutval_s_ecsa_pos
            
        elif event == 'sl_cutval_e_ecsa':
            window['sl_cutval_e_ecsa_pos'].Update(cutval_e_ecsa)
        elif event == 'sl_cutval_e_ecsa_pos':
            window['sl_cutval_e_ecsa'].Update(cutval_e_ecsa_pos)
            cutval_e_ecsa = cutval_e_ecsa_pos
        
        elif event == 'sl_v_ln_ecsa':
            window['sl_v_ln_ecsa_pos'].Update(v_ln_ecsa)
        elif event == 'sl_v_ln_ecsa_pos':
            window['sl_v_ln_ecsa'].Update(v_ln_ecsa_pos)
            v_ln_ecsa = v_ln_ecsa_pos
            
        elif event == 'sl_h_ln_ecsa':
            window['sl_h_ln_ecsa_pos'].Update(h_ln_ecsa)
        elif event == 'sl_h_ln_ecsa_pos':
            window['sl_h_ln_ecsa'].Update(h_ln_ecsa_pos)
            h_ln_ecsa = h_ln_ecsa_pos  
            
        elif event == 'peak_range_ecsa':
            window['peak_range_ecsa_pos'].Update(peak_range_ecsa)
        elif event == 'peak_range_ecsa_pos':
            window['peak_range_ecsa'].Update(peak_range_ecsa_pos)
            peak_range_ecsa = peak_range_ecsa_pos           
                      
        cutval_s_ecsa,cutval_e_ecsa = switch_val(cutval_s_ecsa,cutval_e_ecsa)

        fitting_save_ecsa = np.array([cutval_s_ecsa, cutval_e_ecsa, v_ln_ecsa, h_ln_ecsa, peak_range_ecsa], dtype=object) 
        fitting_save_array[vm_name_idx+1][19:24] = fitting_save_ecsa
        
        if ir_compen != ir_compen_old:
            ir_compen_old = ir_compen
            volt_compen_ecsa = ir_compen_func(cv_volt,cv_curr,ir_compen)
            # Overwrite cv_volt and curr with ir compen
            vm_volt_ir_list[vm_name_idx] = volt_compen_ecsa
        else:
            volt_compen_ecsa = vm_volt_ir_list[vm_name_idx]
        
        if elec_area != elec_area_old:
            elec_area_old = elec_area
            cv_curr_den = cv_curr/elec_area
            # Overwrite cv_curr with cv_curr density
            vm_curr_den_list[vm_name_idx] = cv_curr_den
        else:
            cv_curr_den = vm_curr_den_list[vm_name_idx]

        ax_cv_ecsa.cla() ###### Clear plot before redraw
        vm_volt_list_len = len(vm_volt_list)
        for j in np.arange(0,vm_volt_list_len):
            cutval_s_ecsa_all = int(fitting_save_array[j+1,19])
            cutval_e_ecsa_all = int(fitting_save_array[j+1,20])
            ax_cv_ecsa.plot(np.array(vm_volt_ir_list[j][cutval_s_ecsa_all:cutval_e_ecsa_all]).T, np.array(vm_curr_den_list[j][cutval_s_ecsa_all:cutval_e_ecsa_all]).T, '-', color='black',linewidth=2)
        
        search_mode = 'max' ######### Need new setting
        high_range_a, low_range_a, peak_cv_volt, peak_curr, peak_real_idx = min_max_peak(search_mode, cv_size, cv_volt, cv_curr, peak_range_ecsa, v_ln_ecsa)
        
        ax_cv_ecsa.plot((volt_compen_ecsa[low_range_a],volt_compen_ecsa[high_range_a]),(cv_curr_den[low_range_a],cv_curr_den[high_range_a]),"|", markersize = 10)
        
        ax_cv_ecsa.hlines(y=cv_curr_den[h_ln_ecsa], xmin=peak_cv_volt, xmax=volt_compen_ecsa[h_ln_ecsa], linewidth=2, color='r', linestyle='--')
        ax_cv_ecsa.vlines(x=peak_cv_volt, ymin=peak_curr, ymax=cv_curr_den[h_ln_ecsa], linewidth=2, color='r', linestyle='--')

        # Switch position for fill_between and np.trapz
        # b is always larger than a     
        a,b = switch_val(peak_real_idx,h_ln_ecsa)
            
        ax_cv_ecsa.fill_between(volt_compen_ecsa[a:b], cv_curr_den[h_ln_ecsa],cv_curr_den[a:b],color='orange')
        ax_cv_ecsa.grid()
        ax_cv_ecsa.set_xlabel("Voltage")
        ax_cv_ecsa.set_ylabel(cv_curr)  
        fig_agg_cv_ecsa.draw()

        cv_volt_ecsa = volt_compen_ecsa[a:b]
        curr_ecsa = cv_curr_den[a:b]

        cv_ecsa_area = abs(np.trapz(curr_ecsa,cv_volt_ecsa))
        sq_area = (cv_curr_den[h_ln_ecsa]) * abs(volt_compen_ecsa[h_ln_ecsa]-peak_cv_volt)
        VA_area = abs(cv_ecsa_area-sq_area)
        window['VA_ecsa'].Update(f"{VA_area:e}")

    if event == 'Delete CV File':
        del vm_curr_list[vm_name_idx]
        del vm_curr_den_list[vm_name_idx]
        del vm_name_list[vm_name_idx]
        del vm_path_list[vm_name_idx]
        del vm_size_list[vm_name_idx]
        del idx_intc_defl_list[vm_name_idx]
        del vm_volt_list[vm_name_idx]
        del vm_volt_ir_list[vm_name_idx]           
        fitting_save_array = np.delete(fitting_save_array,1+vm_name_idx,0)
        cv_results = cv_results.drop([vm_name_idx])
        cv_results.reset_index(inplace=True)
        cv_results = cv_results.drop('index',axis=1)      
        # If the deleted data is the last in the list, when delete, the vm_name_idx must be substract to refer to data below it.
        if len(vm_name_list)-1 < vm_name_idx: 
            vm_name_idx = vm_name_idx - 1
                
        if cv_results.empty: # If dataframe empty, just put nothing in display
            window['cv_results_dis'].Update('')
        else:
            window['cv_results_dis'].Update(cv_results.to_string(index=False))
        

        if len(vm_name_list) <= 0: # If CV all delete, make combo empty and disable slider
            window['cv_combo_cv'].Update()
            disable_slider(True)
            window['Delete CV File'].Update(disabled=True) # Disable delete button if empty
            window['cv_combo_cv'].Update('')
            values['cv_combo_cv'] = ''
            window['sl_cutval_s'].Update(range=(0,0))
            window['sl_cutval_e'].Update(range=(0,0))
            window['sl_jpa_lns'].Update(range=(0,0))
            window['sl_jpa_lne'].Update(range=(0,0))
            window['sl_jpc_lns'].Update(range=(0,0))
            window['sl_jpc_lne'].Update(range=(0,0))
            window['peak_range'].Update(range=(1,1))
            window['peak_pos'].Update(range=(1,1))
            window['trou_pos'].Update(range=(1,1))
            window['idx_jsp0'].Update(range=(1,1))     
            # Put slider to previous position, this is just what is shown not real value
            window['sl_cutval_s'].Update(int(0))
            window['sl_cutval_e'].Update(int(0))           
            window['sl_jpa_lns'].Update(int(0))
            window['sl_jpa_lne'].Update(int(0))
            window['sl_jpc_lns'].Update(int(0))
            window['sl_jpc_lne'].Update(int(0))
            window['peak_pos'].Update(int(0))
            window['trou_pos'].Update(int(0))
            window['peak_range'].Update(int(0))
            window['ir_compen'].Update(float(0))
            window['peak_mode_1'].Update(str(0))
            window['peak_mode_2'].Update(str(0))
            window['elec_area'].Update(float(0))
            window['idx_jsp0'].Update(int(0))
            window['inv_jpa_jpc'].Update(int(0))
            window['scan_rate'].Update(float(0))
            window['nicholson_cb'].Update(bool(0))
            # Put actual value             
            values['sl_cutval_s'] = 0
            values['sl_cutval_e'] = 0        
            values['sl_jpa_lns'] = 0
            values['sl_jpa_lne'] = 0
            values['sl_jpc_lns'] = 0
            values['sl_jpc_lne'] = 0
            values['peak_pos'] = 0
            values['trou_pos'] = 0
            values['peak_range'] = 1
            values['ir_compen'] = 0
            values['peak_mode_1'] = "max"
            values['peak_mode_2'] = "min"
            values['elec_area'] = 1
            values['idx_jsp0'] = 0
            values['inv_jpa_jpc'] = 0
            values['scan_rate'] = 0
            values['nicholson_cb'] = 0
            continue
        elif len(vm_name_list) >= 1:
            window['cv_combo_cv'].Update(vm_name_list)     
            cv_select = vm_name_list[vm_name_idx]
            window['cv_combo_cv'].Update(cv_select)
            values['cv_combo_cv'] = cv_select    
            window['cv_combo_cv'].Update(values=vm_name_list)       
            # Change Slider range
            cv_size = len(vm_volt_list[vm_name_idx])
            window['sl_cutval_s'].Update(range=(0,cv_size-1))
            window['sl_cutval_e'].Update(range=(0,cv_size-1))
            window['sl_jpa_lns'].Update(range=(0,cv_size-1))
            window['sl_jpa_lne'].Update(range=(0,cv_size-1))
            window['sl_jpc_lns'].Update(range=(0,cv_size-1))
            window['sl_jpc_lne'].Update(range=(0,cv_size-1))
            window['peak_range'].Update(range=(1, int(0.05*vm_size)))
            window['peak_pos'].Update(range=(1, cv_size-1))
            window['trou_pos'].Update(range=(1, cv_size-1))
            window['idx_jsp0'].Update(range=(1, cv_size-1))     
            # Put slider to previous position, this is just what is shown not real value
            window['sl_cutval_s'].Update(int(fitting_save_array[vm_name_idx+1,2]))
            window['sl_cutval_e'].Update(int(fitting_save_array[vm_name_idx+1,3]))           
            window['sl_jpa_lns'].Update(int(fitting_save_array[vm_name_idx+1,4]))
            window['sl_jpa_lne'].Update(int(fitting_save_array[vm_name_idx+1,5]))
            window['sl_jpc_lns'].Update(int(fitting_save_array[vm_name_idx+1,6]))
            window['sl_jpc_lne'].Update(int(fitting_save_array[vm_name_idx+1,7]))
            window['peak_pos'].Update(int(fitting_save_array[vm_name_idx+1,8]))
            window['trou_pos'].Update(int(fitting_save_array[vm_name_idx+1,9]))
            window['peak_range'].Update(int(fitting_save_array[vm_name_idx+1,10]))
            window['ir_compen'].Update(float(fitting_save_array[vm_name_idx+1,11]))
            window['peak_mode_1'].Update(str(fitting_save_array[vm_name_idx+1,12]))
            window['peak_mode_2'].Update(str(fitting_save_array[vm_name_idx+1,13]))
            window['elec_area'].Update(float(fitting_save_array[vm_name_idx+1,14]))
            window['idx_jsp0'].Update(int(fitting_save_array[vm_name_idx+1,15]))
            window['inv_jpa_jpc'].Update(int(fitting_save_array[vm_name_idx+1,16]))
            window['scan_rate'].Update(float(fitting_save_array[vm_name_idx+1,17]))
            window['nicholson_cb'].Update(int(fitting_save_array[vm_name_idx+1,18]))
            # Put actual value             
            values['sl_cutval_s'] = cutval_s_save
            values['sl_cutval_e'] = cutval_e_save           
            values['sl_jpa_lns'] = jpa_lns_save
            values['sl_jpa_lne'] = jpa_lne_save
            values['sl_jpc_lns'] = jpc_lns_save
            values['sl_jpc_lne'] = jpc_lne_save
            values['peak_pos'] = peak_pos_save
            values['trou_pos'] = trou_pos_save
            values['peak_range'] = peak_range_save
            values['ir_compen'] = ir_compen_save
            values['peak_mode_1'] = peak_mode_1_save
            values['peak_mode_2'] = peak_mode_2_save
            values['elec_area'] = elec_area_save
            values['idx_jsp0'] = idx_jsp0_save
            values['inv_jpa_jpc'] = inv_jpa_jpc_save
            values['scan_rate'] = scan_rate_save
            values['nicholson_cb'] = nicholson_cb_save  

    if event == 'save_cv':
        save_cv_loc = sg.popup_get_file('Create of choose a file (PNG) to save to', save_as=True)
        if save_cv_loc is None or save_cv_loc == '' or save_cv_loc == ():
            continue
        fig_cv.savefig(save_cv_loc)
        
        #====================================================================================#
        #=======================================RDE==========================================#
        #====================================================================================#
        
    if event in ('rde_open_menu','rde_load','rde_combo'): #Change combo also update slider range
        vm_select = values['rde_combo']
        if values['rde_combo'] == '': #Prevent error when combo box value is empty
            vm_name_idx = 0
        else:
            vm_name_idx = vm_name_list.index(vm_select)
        lsv_volt = vm_volt_list[vm_name_idx]
        lsv_curr = vm_curr_list[vm_name_idx]
        lsv_size = vm_size_list[vm_name_idx]
        idx_arr = np.arange(0,vm_size)

        window['sl_cutval_s_lsv'].Update(range=(0,lsv_size-1))
        window['sl_cutval_e_lsv'].Update(range=(0,lsv_size-1))
        window['sl_avg_s_lsv'].Update(range=(0,lsv_size-1))
        window['sl_avg_e_lsv'].Update(range=(0,lsv_size-1))
        if vm_name_idx != vm_name_idx_old: #If the option index change (combo box change), update slider
            vm_name_idx_old = vm_name_idx                    
            # Restore saved values
            cutval_s_lsv_save = int(fitting_save_array[vm_name_idx+1,24])
            cutval_e_lsv_save = int(fitting_save_array[vm_name_idx+1,25])
            avg_s_lsv_save = int(fitting_save_array[vm_name_idx+1,26])
            avg_e_lsv_save = int(fitting_save_array[vm_name_idx+1,27])        
            rde_ror_save = float(fitting_save_array[vm_name_idx+1,28])
            ir_compen_lsv_save = float(fitting_save_array[vm_name_idx+1,29])
            rde_ror_unit_save = str(fitting_save_array[vm_name_idx+1,30])
            # Put slider to previous position, this is just what is shown not real value
            window['sl_cutval_s_lsv'].Update(cutval_s_lsv_save)
            window['sl_cutval_e_lsv'].Update(cutval_e_lsv_save)           
            window['sl_avg_s_lsv'].Update(avg_s_lsv_save)
            window['sl_avg_e_lsv'].Update(avg_e_lsv_save)
            window['rde_ror'].Update(rde_ror_save)
            window['ir_compen_lsv'].Update(ir_compen_lsv_save)
            window['rde_ror_unit'].Update(rde_ror_unit_save)
            # Put actual value             
            values['sl_cutval_s_lsv'] = cutval_s_lsv_save
            values['sl_cutval_e_lsv'] = cutval_e_lsv_save           
            values['sl_avg_s_lsv'] = avg_s_lsv_save
            values['sl_avg_s_lsv'] = avg_e_lsv_save
            values['rde_ror'] = rde_ror_save
            values['ir_compen_lsv'] = ir_compen_lsv_save
            values['rde_ror_unit'] = rde_ror_unit_save
            # Assign the value from saved data
            cutval_s_lsv = cutval_s_lsv_save
            cutval_e_lsv = cutval_e_lsv_save
            avg_s_lsv = avg_s_lsv_save
            avg_e_lsv = avg_e_lsv_save
            rde_ror = rde_ror_save
            ir_compen_lsv = ir_compen_lsv_save
            rde_ror_unit = rde_ror_unit_save
      
    if event in ('rde_open_menu','rde_load', 'ir_compen_lsv', 'elec_area_rde', 'bulk_conc_rde','kinvis_rde','elec_n_rde','sl_cutval_s_lsv','sl_cutval_e_lsv', 'sl_avg_s_lsv', 'sl_avg_e_lsv','sl_cutval_s_lsv_pos','sl_cutval_e_lsv_pos', 'sl_avg_s_lsv_pos', 'sl_avg_e_lsv_pos', 'rde_ror','rde_ror_unit','rde_D_layout_key'):
        cutval_s_lsv = int(values['sl_cutval_s_lsv'])
        cutval_e_lsv = int(values['sl_cutval_e_lsv'])        
        avg_s_lsv = int(values['sl_avg_s_lsv'])
        avg_e_lsv = int(values['sl_avg_e_lsv'])
        rde_ror_unit = str(values['rde_ror_unit'])
        
        # Make sure that proper number format is used
        ir_compen_lsv = check_val(values['ir_compen_lsv'], "float", 0)
        elec_area_lsv = check_val(values['elec_area_rde'], "float", 1) 
        bulk_conc_rde = check_val(values['bulk_conc_rde'], "float", 0) 
        kinvis_rde = check_val(values['kinvis_rde'], "float", 1) 
        elec_n_rde = check_val(values['elec_n_rde'], "int", 1) 
        rde_ror = check_val(values['rde_ror'], "float", 0)
        cutval_s_lsv_pos = check_val(values['sl_cutval_s_lsv'], "int", 1)
        cutval_e_lsv_pos = check_val(values['sl_cutval_e_lsv'], "int", 1)  
        avg_s_lsv_pos = check_val(values['sl_avg_s_lsv'], "int", 1)
        avg_e_lsv_pos = check_val(values['sl_avg_e_lsv'], "int", 1)
        
        if elec_area_lsv <= 0 or kinvis_rde <= 0 or elec_n_rde <= 0:
            window['kinvis_rde_err'].Update("Err negative value")
        else: 
            window['kinvis_rde_err'].Update("")
            
        if event == 'sl_cutval_s_lsv':
            window['sl_cutval_s_lsv_pos'].Update(cutval_s_lsv)
        elif event == 'sl_cutval_s_lsv_pos':
            window['sl_cutval_s_lsv'].Update(cutval_s_lsv_pos)
            cutval_s_lsv = cutval_s_lsv_pos
            
        elif event == 'sl_cutval_e_lsv':
            window['sl_cutval_e_lsv_pos'].Update(cutval_e_lsv)
        elif event == 'sl_cutval_e_lsv_pos':
            window['sl_cutval_e_lsv'].Update(cutval_e_lsv_pos)
            cutval_e_lsv = cutval_e_lsv_pos
        
        elif event == 'sl_avg_s_lsv':
            window['sl_avg_s_lsv_pos'].Update(avg_s_lsv)
        elif event == 'sl_jpa_lns_pos':
            window['sl_jpa_lns'].Update(avg_s_lsv)
            avg_s_lsv = avg_s_lsv_pos
            
        elif event == 'sl_avg_e_lsv':
            window['sl_avg_e_lsv_pos'].Update(avg_e_lsv)
        elif event == 'sl_jpa_lne_pos':
            window['sl_jpa_lne'].Update(avg_e_lsv)
            avg_e_lsv = avg_e_lsv_pos
            
        cutval_s_lsv,cutval_e_lsv = switch_val(cutval_s_lsv,cutval_e_lsv)
        avg_s_lsv,avg_e_lsv = switch_val(avg_s_lsv,avg_e_lsv)
        
        fitting_save_rde = np.array([cutval_s_lsv,cutval_e_lsv,avg_s_lsv,avg_e_lsv,rde_ror,ir_compen_lsv,rde_ror_unit])       
        fitting_save_array[vm_name_idx+1][24:31] = fitting_save_rde
        
        if ir_compen_lsv != ir_compen_lsv_old:
            ir_compen_lsv_old = ir_compen_lsv
            volt_compen_lsv = ir_compen_func(lsv_volt,lsv_curr,ir_compen_lsv)
            # Overwrite cv_volt and curr with ir compen
            vm_volt_ir_list[vm_name_idx] = volt_compen_lsv
        else:
            volt_compen_lsv = vm_volt_ir_list[vm_name_idx]
        
        if elec_area_lsv != elec_area_lsv_old:
            elec_area_lsv_old = elec_area_lsv
            lsv_curr_den = lsv_curr/elec_area_lsv
            # Overwrite vm_curr with lsv_curr density
            vm_curr_den_list[vm_name_idx] = lsv_curr_den
        else:
            lsv_curr_den = vm_curr_den_list[vm_name_idx]
        
        vm_volt_list_len = len(vm_volt_list)
        ax_rde.cla() ###### Clear plot before redraw 
        for j in np.arange(0,vm_volt_list_len):
            cutval_s_lsv_all = int(fitting_save_array[j+1,24])
            cutval_e_lsv_all = int(fitting_save_array[j+1,25])
            ax_rde.plot(np.array(vm_volt_ir_list[j][cutval_s_lsv_all:cutval_e_lsv_all]).T, np.array(vm_curr_den_list[j][cutval_s_lsv_all:cutval_e_lsv_all]).T, '-', color='black',linewidth=1)
        
        lsv_curr_avg = np.average(lsv_curr_den[avg_s_lsv:avg_e_lsv])
        
        if values[1] == 'rde_layout_key':
            ax_rde.axhline(y=lsv_curr_avg, color='blue', linestyle='--',linewidth=3)
            ax_rde.plot(volt_compen_lsv[avg_s_lsv:avg_e_lsv],lsv_curr_den[avg_s_lsv:avg_e_lsv],linewidth=3,linestyle='-', color='blue')
            ax_rde.set_xlabel("Voltage")
            ax_rde.set_ylabel("Current")  
            ax_rde.grid()
            fig_agg_rde.draw()          

        rde_results.loc[vm_name_idx] = [vm_select, rde_ror, rde_ror_unit, lsv_curr_avg]
        rde_results = rde_results.sort_index()
        window['rde_results_dis'].Update(rde_results.to_string(index=False))
        
        rde_ror_arr = np.asarray(rde_results.loc[:,'Rotation'].to_numpy(), dtype=float)
        lim_curr_arr = np.asarray(rde_results.loc[:,'Lim curr'].to_numpy(), dtype=float)
        sqrt_ror, jl_fit ,diffusion ,rde_r2_D = RDE_diffusion(rde_ror_arr,lim_curr_arr,bulk_conc_rde,elec_n_rde,kinvis_rde)
        window['rde_D'].Update(diffusion)     
        inv_sqrt_ror, j_inv_fit, j_kin ,rde_r2_kin_curr = RDE_kin_curr(rde_ror_arr,lim_curr_arr)
        window['rde_kin_curr'].Update(j_kin)

        if values[1] == 'rde_D_layout_key':
            ax_rde_D.cla()
            ax_rde_D.plot(sqrt_ror,lim_curr_arr,'o',markersize=10)           
            ax_rde_D.plot(sqrt_ror,jl_fit,linewidth=3,linestyle='-', color='blue')
            ax_rde_D.grid()
            ax_rde_D.set_xlabel("Rate of Rotation$^1/2$",fontsize=14)
            ax_rde_D.set_ylabel("Current",fontsize=14)
            fig_agg_rde_D.draw() 
            
        if values[1] == 'rde_kin_curr_layout_key':
            ax_rde_kin_curr.cla()
            ax_rde_kin_curr.plot(inv_sqrt_ror,1/lim_curr_arr,'o',markersize=10)
            ax_rde_kin_curr.plot(inv_sqrt_ror,j_inv_fit,linewidth=3,linestyle='-', color='red')   
            ax_rde_kin_curr.grid()
            ax_rde_kin_curr.set_xlabel("Rate of Rotation$^{-1/2}$",fontsize=14)
            ax_rde_kin_curr.set_ylabel("Current$^{-1}$",fontsize=14)
            fig_agg_rde_kin_curr.draw()             

    if event == 'save_rde_param':
        rde_param = sg.popup_get_file('', save_as=True, no_window=True, file_types=(("TXT Files", "*.txt"), ("All Files", "*.*")))
        rde_param_dir, filename = os.path.split(rde_param)
        filename_without_extension, _ = os.path.splitext(filename)
        results_filename = f"{filename_without_extension}_rde_results.ods"
        rde_result_path = os.path.join(rde_param_dir, results_filename)

        np.savetxt(cv_param, fitting_save_array, delimiter=',', fmt='%s')
        rde_results.to_excel(rde_result_path, index=True)        

        #====================================================================================#
        #=======================================Battery======================================#
        #====================================================================================#
        
    if event == 'Open battery file':
        bat_file_new = sg.popup_get_file('Choose battery cycle file (.xls)')
        # If cancel, close the window, go back to beginning
        # If empty, use old file
        if bat_file_new is None or bat_file_new == '' or bat_file_new == ():
            continue
        try:
            clear_battery_plot()
            bat_file = bat_file_new
            df_bat, row_size, time_df, bat_volt_df, current_df, capacity_df, state_df = battery_xls2df(bat_file)

            # Voltage difference with current interrupt method between C_CC and R
            CIM_idx = search_pattern(list(state_df), ['C_CC','R'])
            CIM_cv_volt_drop_list = []
            for i in CIM_idx:
                CIM_cv_volt_drop = bat_volt_df[i]-bat_volt_df[i+1]
                CIM_cv_volt_drop_list.append(CIM_cv_volt_drop)              
            # Sequence information
            charge_CC_seq, discharge_CC_seq, rest_seq, charge_CV_seq, discharge_CV_seq = find_state_seq(state_df)
            VE_arr, CE_arr, EE_arr, charge_cap_arr, discharge_cap_arr, tot_cycle_number = get_battery_eff(row_size, time_df, bat_volt_df, current_df, capacity_df, state_df, charge_CC_seq, discharge_CC_seq)
            
            VE_avg = np.average(VE_arr[0:cycle_end])
            CE_avg = np.average(CE_arr[0:cycle_end])
            EE_avg = np.average(EE_arr[0:cycle_end])
            charge_cap_avg = np.average(charge_cap_arr[0:cycle_end])
            discharge_cap_avg = np.average(discharge_cap_arr[0:cycle_end]) 
            #For display table
            df_display=pd.DataFrame([charge_cap_arr,discharge_cap_arr,VE_arr,CE_arr,EE_arr]) # Create dataframe to display in multiline output
            df_display=df_display.T
            df_display.columns = ['Charge-Capacity','Discharge-Capacity','VE', 'CE', 'EE']
            df_display.index = df_display.index + 1 # Start index at 1 for nice looking
            
            window['cycle_end'].Update(disabled=False)
            window['cycle_start'].Update(disabled=False)
            window['cb_cv_volt'].Update(disabled=False)
            window['cb_current'].Update(disabled=False)
            window['cb_eff'].Update(disabled=False)
            window['cb_cap'].Update(disabled=False)
            window['cb_cv_volt'].Update(True)
            window['cb_current'].Update(True)
            window['cb_eff'].Update(True)
            window['cycle_start'].Update(range=(0,tot_cycle_number-1))
            window['cycle_end'].Update(range=(1,tot_cycle_number))
            window['bat_file_use'].Update(bat_file)
            window['output_arr'].Update(df_display.to_string()) # Make sure to print all lines
            window['tot_cycle'].Update(tot_cycle_number) 
            window['output_ve'].Update(np.round(VE_avg,3))
            window['output_ce'].Update(np.round(CE_avg,3))
            window['output_ee'].Update(np.round(EE_avg,3))
            
            cv_volt_line, = ax_bat_volt.plot(time_df, bat_volt_df, '-', label='Voltage', color='blue')
            current_line, = ax_bat_current.plot(time_df, current_df, '--', label='Current', color='red')
            
            cycle_idx = (charge_CC_seq)[:,1]

            cycle_idx = cycle_idx[0:min((charge_CC_seq)[:,1].size,(discharge_CC_seq)[:,1].size)]
            time_cycle = time_df[cycle_idx]
            VE_marker, = ax_bat_eff.plot(time_df[cycle_idx], VE_arr, '*',color='blue',label='VE', markersize=8)
            CE_marker, = ax_bat_eff.plot(time_df[cycle_idx], CE_arr, '.',color='red',label='CE', markersize=8)
            EE_marker, = ax_bat_eff.plot(time_df[cycle_idx], EE_arr, '^',color='green',label='EE', markersize=4)              
            charge_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], charge_cap_arr, 's',color='orange',label='capacity', markersize=4)
            dis_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], discharge_cap_arr, 'x',color='brown',label='capacity', markersize=4)
            CIM_marker, = ax_bat_volt.plot(time_df[cycle_idx], np.array(CIM_cv_volt_drop_list)/0.65, 'o',color='blue',label='CIM', markersize=4)
            
            ax_bat_volt.autoscale()
            ax_bat_current.autoscale()
            ax_bat_eff.autoscale()
            ax_bat_cap.autoscale()
            # Set limit and ticks of bat_cycle
            # Match cycle scale to time scale and plot efficiency.
            cycle_plot = np.arange(0,tot_cycle_number,10)
            ax_bat_cycle.set_xticks(cycle_plot)
            ax_bat_cycle.set_xlim(left=0,right=tot_cycle_number)
            
            # Set limit for efficiencies
            ax_bat_eff.set_ylim(0,100)
            
            ax_bat_volt.set_xlim(left=0,right=max(time_df))

            ax_bat_cycle.grid()
            ax_bat_volt.grid(axis='y')
            fig_agg_bat.draw()
        except Exception as file_error:
            sg.popup(file_error, keep_on_top=True)
    if event == 'cb_eff':
        if values['cb_eff'] == False:
            VE_marker.remove()
            CE_marker.remove()
            EE_marker.remove()
        else:
            VE_marker, = ax_bat_eff.plot(time_df[cycle_idx], VE_arr, '*',color='blue',label='VE', markersize=8)
            CE_marker, = ax_bat_eff.plot(time_df[cycle_idx], CE_arr, '.',color='red',label='CE', markersize=8)
            EE_marker, = ax_bat_eff.plot(time_df[cycle_idx], EE_arr, '^',color='green',label='EE', markersize=4)
        fig_agg_bat.draw()
    if event == 'cb_cap':
        if values['cb_cap'] == False:
            charge_cap_marker.remove()
            dis_cap_marker.remove()
        else:            
            charge_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], charge_cap_arr, 's',color='orange',label='capacity', markersize=4)
            dis_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], discharge_cap_arr, 'x',color='brown',label='capacity', markersize=4)
        fig_agg_bat.draw()
    if event == 'cb_cv_volt':
        if values['cb_cv_volt'] == False:
            cv_volt_line.remove()
        else:
            cv_volt_line, = ax_bat_volt.plot(time_df, bat_volt_df, '-', label='Voltage', color='blue')
        fig_agg_bat.draw()
    if event == 'cb_current':
        if values['cb_current'] == False:
            current_line.remove()
        else:
            current_line, = ax_bat_current.plot(time_df, current_df, '--', label='Current', color='red')
        fig_agg_bat.draw()
    if event in ('cycle_start', 'cycle_end'):
        cycle_start = int(values['cycle_start'])
        
        if cycle_start > cycle_end - 1:
            cycle_end = cycle_start + 1
            window['cycle_end'].Update(cycle_end)
            
        cycle_end = int(values['cycle_end'])
        if cycle_end < cycle_start + 1:
            cycle_start = cycle_end - 1
            window['cycle_start'].Update(cycle_start)
            
        # Do not replot, since we only change xlim.
        cycle_idx_range = cy_idx_state_range(state_df, cycle_start, cycle_end, charge_CC_seq, discharge_CC_seq)
        left_bound = time_df[cycle_idx_range][0]
        right_bound = time_df[cycle_idx_range][1]
        
        # Change number of ticks with cycle range
        if cycle_end-cycle_start <= 10:  
            cycle_plot = np.arange(0,tot_cycle_number,1)
        elif cycle_end-cycle_start >= 10 and cycle_end-cycle_start <= 200:  
            cycle_plot = np.arange(0,tot_cycle_number,10)
        elif cycle_end-cycle_start >= 201 and cycle_end-cycle_start <= 500:
            cycle_plot = np.arange(0,tot_cycle_number,20)
        elif cycle_end-cycle_start >= 501 and cycle_end-cycle_start <= 1000:
            cycle_plot = np.arange(0,tot_cycle_number,50)          
        elif cycle_end-cycle_start >= 1001:
            cycle_plot = np.arange(0,tot_cycle_number,100)  
        
        ax_bat_cycle.set_xticks(cycle_plot)        
        ax_bat_volt.set_xlim(left=left_bound,right=right_bound)
        ax_bat_cycle.set_xlim(left=cycle_start,right=cycle_end)
        ax_bat_cycle.grid()
        
        VE_avg = np.average(VE_arr[cycle_start:cycle_end])
        CE_avg = np.average(CE_arr[cycle_start:cycle_end])
        EE_avg = np.average(EE_arr[cycle_start:cycle_end])
        window['output_ve'].Update(np.round(VE_avg,3))
        window['output_ce'].Update(np.round(CE_avg,3))
        window['output_ee'].Update(np.round(EE_avg,3))
                   
        ax_bat_cap.set_ylim(min(charge_cap_arr[cycle_start:cycle_end]), max(charge_cap_arr[cycle_start:cycle_end]))
        
        fig_agg_bat.draw()
    if event == 'bat_clear':
        clear_battery_plot()
    if event == 'save_bat':
        save_bat_loc = sg.popup_get_file('Create of choose a file (PNG) to save to', save_as=True)
        if save_bat_loc is None:
            continue
        elif save_bat_loc == '':
            continue
        fig_cv.savefig(save_bat_loc)            

window.close()