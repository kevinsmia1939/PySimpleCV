#!/usr/bin/python3
import os
import io
import sys
import numpy as np 
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg 
from matplotlib.figure import Figure
import PySimpleGUI as sg
import matplotlib 
from matplotlib.lines import Line2D
import pandas as pd
import tarfile
import shutil
matplotlib.use('TkAgg')
from PySimpleCV_main_func import battery_xls2df, get_CV_init, find_state_seq, get_battery_eff, cy_idx_state_range, CV_file2df, get_peak_CV, search_pattern, ir_compen_func, diffusion, reaction_rate, deflection, find_alpha, min_max_peak, check_val, switch_val
# from PySimpleCV_main_func import *

if not sys.warnoptions:
    import warnings
    warnings.simplefilter("ignore")

matplotlib.rcParams['figure.dpi'] = 80

def About_PySimpleCV():
    [sg.popup('PySimpleCV written by Kavin Teenakul',
    'License: GPL v3',
    'https://github.com/kevinsmia1939/PySimpleCV',
    'Libraries used:',
    'NumPy - https://numpy.org/',
    'pandas - https://pandas.pydata.org/',
    'Matplotlib - https://matplotlib.org/',
    'PySimpleGUI - https://www.pysimplegui.org',
    'impedance.py - https://impedancepy.readthedocs.io/en/latest/',
    'statsmodels - https://www.statsmodels.org',
    
    'Abbreviation',
    'Jpa - Anodic peak current/current density',
    'Jpc - Cathodic peak current/current density',
    'Epa - Anodic peak potential',
    'Epc - Cathodic peak potential',
    'E\u00bd  - Half-wave potential',
    'ΔE\u209a - Peak-to-peak separation potential',
    'Nicholson method - Nicholson, R. S. Semiempirical Procedure for Measuring with Stationary Electrode Polarography Rates of Chemical Reactions Involving the Product of Electron Transfer. Anal. Chem. 1966, 38 (10), 1406.'
    )]

sg.theme('DarkBlue')

def draw_figure(canvas, figure): 
    figure_canvas_agg = FigureCanvasTkAgg(figure, canvas) 
    figure_canvas_agg.draw() 
    figure_canvas_agg.get_tk_widget().pack(side='top', fill='both', expand=1) 
    return figure_canvas_agg

# Generate layout for CV tab
cv_slider_size = (50,18)
cv_cv=[[sg.Canvas(key='-CANVAS_cv-')]]
cv_diff=[[sg.Canvas(key='-CANVAS_cv_D-')]]
cv_kin =[[sg.Canvas(key='-CANVAS_cv_k-')]]

cv_open_menu = ["Menu",["VersaSTAT4 (.par)", "CorrWare (.cor)", "CSV (.csv)", "text (.txt)"]]
cv_peak_mode = ["max","min","deflection"]
         
cv_settings = [
    [sg.ButtonMenu("Add/Open CV file",cv_open_menu,key='cv_open_menu'),sg.Button("Load saved CV files", key='cv_load_cv'),sg.Combo(values=(), default_value='', readonly=False, key='cv_combo_cv', enable_events=True, size=(30,15)),sg.Button("Delete CV File", disabled=True)],
    [sg.Text('.csv file with voltage on 1st colume and current on 2nd column separated by comma')],
    [sg.Checkbox('Switch anodic and cathodic current', default=False, key='inv_jpa_jpc', disabled=True, enable_events=True)],
    [sg.Text('iR compensation'),sg.Input(default_text=('0'), key='ir_compen',size=(8,5),disabled=True, enable_events=True),sg.Text('Ω'),sg.Text('Electrode area'),sg.Input(default_text=('1'), key='elec_area',size=(8,5),disabled=True, enable_events=True),sg.Text('cm\u00b2'),
     sg.Text('Scan rate'),sg.Input(default_text=('0'), key='scan_rate',size=(8,5),disabled=True, enable_events=True),sg.Text('V/s')],
    [sg.Text('Trim CV plot start'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_s', disable_number_display=True, enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_cutval_s_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('Trim CV plot end'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_e', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_cutval_e_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('Start 1'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpa_lns', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_jpa_lns_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('End 1'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpa_lne', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_jpa_lne_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('Start 2'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpc_lns', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_jpc_lns_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('End 2'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_jpc_lne', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_jpc_lne_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('Search range'),sg.Slider(range=(1, 100), size=cv_slider_size, orientation='h', key='peak_range', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='peak_range_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('Peak position 1'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='peak_pos', enable_events=True, disabled=True), sg.Combo(values=('max','min','exact','deflection'), default_value='max', readonly=False, key='peak_mode_1', enable_events=True, size=(7,15)),sg.Text('position'), sg.Input(default_text=('0'), key='peak_pos_pos',size=(6,5),disabled=True, enable_events=True)],
    [sg.Text('Peak position 2'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='trou_pos', enable_events=True, disabled=True), sg.Combo(values=('max','min','exact','deflection'), default_value='min', readonly=False, key='peak_mode_2', enable_events=True, size=(7,15)),sg.Text('position'), sg.Input(default_text=('0'), key='trou_pos_pos',size=(6,5),disabled=True, enable_events=True)],
    
    [sg.Frame('Nicholson Method',[   
    [sg.Checkbox('Nicholson method (if baseline cannot be determine)', default=False, key='nicholson_cb', enable_events=True, disabled=True)],
    [sg.Text('Switching potential current (jps0)'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='idx_jsp0', enable_events=True, disabled=True),sg.Text('', key='jsp0_volt'),sg.Text('V'),sg.Text('position'),sg.Input(default_text=('0'), key='idx_jsp0_pos',size=(6,5),disabled=True, enable_events=True)],
    ], key='-frame_nicholson-')],
    
    [sg.Frame('Diffusion Coefficienct and rate of reaction',[   
    [sg.Text('Bulk concentration'),sg.Input(default_text=('0'), key='bulk_conc',size=(15,5),disabled=True, enable_events=True),sg.Text('mol/cm\u00b3'),sg.Text('Number of electrons'),sg.Input(default_text=('1'), key='elec_n',size=(15,5),disabled=True, enable_events=True)],
    [sg.Text('Average anodic alpha'),sg.Input(text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(), key='alpha_ano',size=(15,5),disabled=True, enable_events=True),sg.Text('Average cathodic alpha'),sg.Input(text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(), key='alpha_cat',size=(15,5),disabled=True, enable_events=True)],
    [sg.Text('Ano rev D (cm\u00b2/s)'),sg.Input('', key='d_rev_jpa', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True),sg.Text('Cat rev D (cm\u00b2/s)'),sg.Input('', key='d_rev_jpc', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True)],
    [sg.Text('Ano irr D (cm\u00b2/s)'),sg.Input('', key='d_irr_jpa', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True),sg.Text('Cat irr D (cm\u00b2/s)'),sg.Input('', key='d_irr_jpc', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True)],
    [sg.Text('Ano k (cm/s)'),sg.Input('', key='k_jpa', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True),sg.Text('Cat k (cm/s)'),sg.Input('', key='k_jpc', text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(),size=(15,5),disabled=True, enable_events=True)],
    ], key='-frame_D_k-')],
    
    [sg.Button('Save parameters', key='save_cv_param'),sg.Button('Save plot', key='save_cv'),sg.Button('About PySimpleCV'),sg.Button('Exit', key='exit')]
]
cv_D_k_tab = sg.TabGroup([[sg.Tab('CV', cv_cv, key='cv_cv_layout_key'), sg.Tab('Diffusion', cv_diff, key='cv_diff_layout_key'),sg.Tab('Kinetics', cv_kin, key='cv_kin_layout_key')]], enable_events=True)
             
cv_layout = [
            [sg.Checkbox('Plot Jp vs √scanrate for diffusion', default=False, key='enable_d', disabled=False, enable_events=True),sg.Checkbox('Plot Jp vs Ep-E0 for kinetic', default=False, key='enable_k', disabled=False, enable_events=True)],
            [cv_D_k_tab,sg.Column(cv_settings)],
            [sg.Multiline('',size=(155,8), disabled=True, key = 'cv_results_dis', font=('DejaVu Sans Mono', 12), no_scrollbar=False, horizontal_scroll=True)],  
            ]

cv_ecsa1 =[[sg.Canvas(key='-CANVAS_cv_ecsa-')]]
cv_ecsa2 = [
    [sg.Text('Create a rectangle area under the CV plot to calculate the electrochemical active surface area (ECSA) with gas absorption')],
    [sg.ButtonMenu("Add/Open CV file",cv_open_menu,key='cv_open_menu_ecsa'),sg.Button("Load saved CV files", key='cv_load_ecsa'),sg.Combo(values=(), default_value='', readonly=False, key='cv_combo_ecsa', enable_events=True, size=(30,15)),sg.Button("Delete CV File", disabled=True)],
    [sg.Text('.csv file with voltage on 1st colume and current on 2nd column separated by comma')],
    [sg.Text('iR compensation'),sg.Input(default_text=('0'), key='ir_compen_ecsa',size=(15,5),disabled=True, enable_events=True),sg.Text('Ω'),sg.Text('Electrode area'), sg.Input(default_text=('1'), key='elec_area_ecsa',size=(15,5),disabled=True, enable_events=True),sg.Text('cm\u00b2'),
     sg.Text('Scan rate'),sg.Input(default_text=('0'), key='scan_rate_ecsa',size=(15,5),disabled=True, enable_events=True),sg.Text('V')],
    [sg.Text('Trim CV plot start'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_s_ecsa', disable_number_display=True, enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_cutval_s_ecsa_pos',size=(10,5),disabled=True, enable_events=True)],
    [sg.Text('Trim CV plot end'), sg.Slider(range=(0, 1), size=cv_slider_size, orientation='h', key='sl_cutval_e_ecsa', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_cutval_e_ecsa_pos',size=(10,5),disabled=True, enable_events=True)],
    [sg.Text('Vertical Line'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_v_ln_ecsa', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_v_ln_ecsa_pos',size=(10,5),disabled=True, enable_events=True)],
    [sg.Text('Horizontal Line'),sg.Slider(range=(1, 1), size=cv_slider_size, orientation='h', key='sl_h_ln_ecsa', enable_events=True, disabled=True),sg.Text('position'), sg.Input(default_text=('0'), key='sl_h_ln_ecsa_pos',size=(10,5),disabled=True, enable_events=True)],
    [sg.Text('Peak search range'),sg.Slider(range=(1, 100), size=cv_slider_size, orientation='h', key='peak_range_ecsa', enable_events=True, disabled=False),sg.Text('position'), sg.Input(default_text=('0'), key='peak_range_ecsa_pos',size=(10,5),disabled=True, enable_events=True)],
    [sg.Text('Area: voltage x current'),sg.Input(text_color=sg.theme_text_color(), disabled_readonly_background_color=sg.theme_text_element_background_color(), key='VA_ecsa',size=(15,5),disabled=True, enable_events=True)]
    ]

cv_ecsa_layout = [[sg.Column(cv_ecsa1),sg.Column(cv_ecsa2)]]

# Generate layout for battery cycling tab.
bat_col1=[[sg.Canvas(key='-CANVAS_bat-')]]
bat_col2 = [
    [sg.Button("Open Battery File"),sg.Text('.xls files'),
     sg.Checkbox('Voltage', default=True, key='cb_volt', disabled=True, enable_events=True), 
     sg.Checkbox('Current', default=True, key='cb_current', disabled=True, enable_events=True),
     sg.Checkbox('Efficiencies', default=True, key='cb_eff', disabled=True, enable_events=True),
     sg.Checkbox('Capacities', default=True, key='cb_cap', disabled=True, enable_events=True)],
    [sg.Text('Battery file:'), sg.Text('No Battery file selected', key = 'bat_file_use')],
    [sg.Text('Average voltage efficiency='),sg.Text('', key = 'output_ve'),sg.Text('%')],
    [sg.Text('Average coulombic efficiency='), sg.Text('', key = 'output_ce'),sg.Text('%')],
    [sg.Text('Average energy efficiency='), sg.Text('', key = 'output_ee'),sg.Text('%')],
    [sg.Text('Total number of cycles='), sg.Text('', key= 'tot_cycle')],
    [sg.Text('Voltage, current, energy efficiency(%) for each row of cycle, press ctrl+c to copy')],
    [sg.Text('To copy nicely to spreadsheet software, select space as delimiter and merge delimters.')],
    [sg.Multiline('',size=(90,5), disabled=True, key = 'output_arr')],
    [sg.Text('Cycle start'), sg.Slider(range=(0, 0), size=(50, 8), orientation='h', key='cycle_start', enable_events=True, disabled=False)],
    [sg.Text('Cycle end'), sg.Slider(range=(1, 1), size=(50, 8), orientation='h', key='cycle_end', enable_events=True, disabled=False)],
    [sg.Button('Clear plot',key='bat_clear'),sg.Button('Save plot', key='save_bat'), sg.Button('Exit', key='exit_2')]
    ]          
bat_layout = [[sg.Column(bat_col1),sg.Column(bat_col2)]]

layout = sg.TabGroup([[sg.Tab('CV', cv_layout, key='cv_layout_key'),sg.Tab('CV ECSA', cv_ecsa_layout, key='cv_ecsa_layout_key'),sg.Tab('Battery Cycling', bat_layout, key='bat_layout_key')]], enable_events=True, expand_x=True, expand_y=True)
          
window = sg.Window('PySimpleCV', [[layout]], finalize=True, element_justification='center')

# window.maximize()
canvas_cv = window['-CANVAS_cv-'].tk_canvas
canvas_cv_D = window['-CANVAS_cv_D-'].tk_canvas
canvas_cv_k = window['-CANVAS_cv_k-'].tk_canvas
canvas_cv_ecsa = window['-CANVAS_cv_ecsa-'].tk_canvas
canvas_bat = window['-CANVAS_bat-'].tk_canvas
# canvas_eis = window['-CANVAS_eis-'].tk_canvas

# Generate initial empty plot.
fig_cv = Figure(figsize=(9,9))
ax_cv = fig_cv.add_subplot(111)
ax_cv.set_xlabel("Voltage")
ax_cv.set_ylabel("Current")
ax_cv.grid()

fig_cv_D = Figure(figsize=(9,9))
ax_cv_D = fig_cv_D.add_subplot(111)
ax_cv_D.set_xlabel("Scan rate 1/2")
ax_cv_D.set_ylabel("Jp")
ax_cv_D.grid()

fig_cv_kin = Figure(figsize=(9,9))
ax_cv_kin = fig_cv_kin.add_subplot(111)
ax_cv_kin.set_xlabel("Ep - E0")
ax_cv_kin.set_ylabel("Jp")
ax_cv_kin.grid()

# tight layout push away y label
# fig_cv.tight_layout(pad=2)
fig_agg_cv = draw_figure(canvas_cv, fig_cv)
fig_agg_cv_D = draw_figure(canvas_cv_D, fig_cv_D)
fig_agg_cv_k = draw_figure(canvas_cv_k, fig_cv_kin)

fig_cv_ecsa = Figure(figsize=(9,9))
ax_cv_ecsa = fig_cv_ecsa.add_subplot(111)
ax_cv_ecsa.set_xlabel("Voltage")
ax_cv_ecsa.set_ylabel("Current")
ax_cv_ecsa.grid()

fig_agg_cv_ecsa = draw_figure(canvas_cv_ecsa, fig_cv_ecsa)

fig_bat = Figure(figsize=(10,10))
ax_bat_volt = fig_bat.add_subplot(111)
ax_bat_current = ax_bat_volt.twinx()
ax_bat_eff = ax_bat_volt.twinx()
ax_bat_cap = ax_bat_volt.twinx()
ax_bat_cycle = ax_bat_volt.twiny()
ax_bat_eff.spines.right.set_position(("axes", 1.11))
ax_bat_cap.spines.right.set_position(("axes", 1.21))
ax_bat_volt.set_ylabel("Voltage")
ax_bat_current.set_ylabel("Current")
ax_bat_eff.set_ylabel("Voltage/Coulombic/ Energy Efficiencies")
ax_bat_cap.set_ylabel("Capacity")
ax_bat_cycle.set_xlabel("Cycle")
ax_bat_volt.set_xlabel("Time")
# Create manual legend so we can put them in the same box
volt_leg = Line2D([0], [0], label='Voltage', color='blue', linestyle='-')
current_leg = Line2D([0], [0], label='Current', color='red', linestyle='--')
VE_leg = Line2D([0], [0], label='VE', color='blue', marker='*', linestyle='None')
CE_leg = Line2D([0], [0], label='CE', color='red', marker='.', linestyle='None')
EE_leg = Line2D([0], [0], label='EE', color='green', marker='^', linestyle='None')
cap_leg = Line2D([0], [0], label='Capacity', color='orange', marker='s', linestyle='None')
ax_bat_volt.legend(handles=[volt_leg,current_leg,VE_leg,CE_leg,EE_leg,cap_leg],ncol=6, bbox_to_anchor=(0.5,-0.25),loc='lower center')
ax_bat_cycle.grid()
ax_bat_volt.grid(axis='y')
fig_bat.tight_layout()
fig_agg_bat = draw_figure(canvas_bat, fig_bat)

cycle_start = 1
cycle_end = 1

def clear_battery_plot():
    # function to clear the plot.
    # Reset scrolls and checkboxes
    window['cb_volt'].Update(False)
    window['cb_current'].Update(False)
    window['cb_eff'].Update(False)
    window['cb_volt'].Update(disabled=True)
    window['cb_current'].Update(disabled=True)
    window['cb_eff'].Update(disabled=True)
    window['cycle_start'].Update(range=(0,0))
    window['cycle_end'].Update(range=(1,1))
    window['cycle_start'].Update(disabled=True)
    window['cycle_end'].Update(disabled=True)    
    # Remove existing plot.
    ax_bat_current.cla()
    ax_bat_volt.cla()
    ax_bat_eff.cla()
    ax_bat_cap.cla()
    ax_bat_cycle.cla()
    #Redraw Efficiency axis and labels.
    ax_bat_eff.spines.right.set_position(("axes", 1.11))
    ax_bat_cap.spines.right.set_position(("axes", 1.21))
    ax_bat_volt.set_ylabel("Voltage")
    ax_bat_current.set_ylabel("Current")
    ax_bat_eff.set_ylabel("Voltage/Current/Energy Efficiencies")
    ax_bat_cap.set_ylabel("Capacity")
    ax_bat_cycle.set_xlabel("Cycle")
    ax_bat_volt.set_xlabel("Time")
    # Create manual legend so we can put them in the same box
    volt_leg = Line2D([0], [0], label='Voltage', color='blue', linestyle='-')
    current_leg = Line2D([0], [0], label='Current', color='red', linestyle='--')
    VE_leg = Line2D([0], [0], label='VE', color='blue', marker='*', linestyle='None')
    CE_leg = Line2D([0], [0], label='CE', color='red', marker='.', linestyle='None')
    EE_leg = Line2D([0], [0], label='EE', color='green', marker='^', linestyle='None')
    ax_bat_volt.legend(handles=[volt_leg,current_leg,VE_leg,CE_leg,EE_leg],ncol=5, bbox_to_anchor=(0.5,-0.25),loc='lower center')
    ax_bat_cycle.grid()
    fig_agg_bat.draw()
    
def disable_slider(bool):
    window['sl_cutval_s'].Update(disabled=bool)
    window['sl_cutval_e'].Update(disabled=bool)
    window['sl_jpa_lns'].Update(disabled=bool)
    window['sl_jpa_lne'].Update(disabled=bool)
    window['sl_jpc_lns'].Update(disabled=bool)
    window['sl_jpc_lne'].Update(disabled=bool)
    window['peak_range'].Update(disabled=bool)
    window['peak_pos'].Update(disabled=bool)
    window['trou_pos'].Update(disabled=bool)
    window['inv_jpa_jpc'].Update(disabled=bool)
    window['peak_mode_1'].Update(disabled=bool)
    window['peak_mode_2'].Update(disabled=bool)
    window['nicholson_cb'].Update(disabled=bool)
    window['idx_jsp0'].Update(disabled=bool)
    window['Delete CV File'].Update(disabled=bool)
    window['ir_compen'].Update(disabled=bool)
    window['elec_area'].Update(disabled=bool)
    window['scan_rate'].Update(disabled=bool)
    window['bulk_conc'].Update(disabled=bool)
    window['elec_n'].Update(disabled=bool)
    
    window['sl_cutval_s_pos'].Update(disabled=bool)
    window['sl_cutval_e_pos'].Update(disabled=bool)
    window['sl_jpa_lns_pos'].Update(disabled=bool)    
    window['sl_jpa_lne_pos'].Update(disabled=bool)
    window['sl_jpc_lns_pos'].Update(disabled=bool)
    window['sl_jpc_lne_pos'].Update(disabled=bool)
    window['peak_range_pos'].Update(disabled=bool)
    window['peak_pos_pos'].Update(disabled=bool)
    window['trou_pos_pos'].Update(disabled=bool)
    window['idx_jsp0_pos'].Update(disabled=bool)

    window['sl_cutval_s_ecsa'].Update(disabled=bool)
    window['sl_cutval_e_ecsa'].Update(disabled=bool)    
    window['sl_v_ln_ecsa'].Update(disabled=bool)
    window['sl_h_ln_ecsa'].Update(disabled=bool)
    window['peak_range_ecsa'].Update(disabled=bool)
    window['ir_compen_ecsa'].Update(disabled=bool)
    window['sl_cutval_s_ecsa_pos'].Update(disabled=bool)
    window['sl_cutval_e_ecsa_pos'].Update(disabled=bool)
    window['sl_v_ln_ecsa_pos'].Update(disabled=bool)
    window['sl_h_ln_ecsa_pos'].Update(disabled=bool)
    window['peak_range_ecsa_pos'].Update(disabled=bool)

randles_select = True
volt_lst = []
# smh_volt_lst = []
# smh_curr_lst = []
idx_intc_defl_lst = []
current_lst = []
current_den_lst = []
volt_ir_lst = []
cv_path_lst = []
cv_name_lst = []
cv_size_lst = []
#                            0         1         2         3       4         5      6           7         8          9          10           11          12           13        14          15        16            17             18              19        20         21        22           23
#                            file name,file format, cutval_s, cutval_e, jpa_lns, jpa_lne, jpc_lns, jpc_lne, peak_pos, trou_pos, peak_range, ir_compen, peak_mode_1, peak_mode_2,elec_area, idx_jsp0, inv_jpa_jpc, scan_rate, nicholson_cb, cutval_s_ecsa, cutval_e_ecsa, v_ln_ecsa, h_ln_ecsa, peak_range_ecsa
fitting_default = np.array([["",       "",          0.,       0.,       0.,      0.,      0.,      0.,      1.,       1.,       100.,       0.,        "max",       "min",      1.,        0.,       0.,          0.,        0.,           0.,            0.,            0.,        0.,        1.]], dtype=object)
fitting_save_array = np.zeros((1,fitting_default.size), dtype=object)
cv_name_idx_old = -1 #set to -1 so that cv_name_idx != cv_name_idx_old will trigger the first time
ir_compen_old = 0
elec_area_old = 1
cv_results = pd.DataFrame(columns =  ["file_name", "scan_rate", "Jpa", "Jpc", "Jpc0", "Epa", "Epc", "Jpa/Jpc", "E\u00bd", "ΔE\u209a", "alpha_ano", "alpha_cat"])
while True:
    event, values = window.read()
    # print(event)
    # print(values)
    # print(values[1]) #This print active tab
    if event in (sg.WIN_CLOSED,'exit','exit_2'):
        try:
            shutil.rmtree(temp_path) # Delete temporary files from loading CV tar file.
        except NameError:
            pass
        break
    
    if event == 'About PySimpleCV':
            About_PySimpleCV()
            continue

    if event in ('cv_load_cv', 'cv_load_ecsa'):
        load_cv_dir = sg.popup_get_file('', no_window=True, file_types=(("TXT Files", "*.txt"), ("All Files", "*.*")))        
        directory, filename = os.path.split(load_cv_dir)
        filename_without_extension, _ = os.path.splitext(filename)
        results_filename = f"{filename_without_extension}_results.ods"
        cv_result_path = os.path.join(directory, results_filename)
        if load_cv_dir is None or load_cv_dir == '' or load_cv_dir == ():
            continue
        try:
            fitting_save_array = np.loadtxt(load_cv_dir,dtype=object, delimiter=',')     
            cv_results = pd.read_excel(cv_result_path, index_col=0) #Use first column as index
            
            file_name_load_mult = fitting_save_array[1:,0]
            file_form_load_mult = fitting_save_array[1:,1]
            for i in np.arange(0,len(file_name_load_mult)):
                print(i)
                cv_file = file_name_load_mult[i]
                file_format = file_form_load_mult[i]
                cv_name = os.path.basename(cv_file) #Get file name
                df_CV, file_scan_rate = CV_file2df(cv_file, file_format)       
                cv_size, volt, current = get_CV_init(df_CV)
                cv_path_lst.append(cv_file) #Create 2D array of CVs so we can select, plot, and analyze data based on index
                cv_name_lst.append(cv_name)
                volt_lst.append(volt)
                current_lst.append(current)
                volt_ir_lst.append(volt) #Append volt to ir compensated volt, this is like ir=0
                current_den_lst.append(current) # This is like elec_area = 1
                cv_size_lst.append(cv_size)
                # deflection and Peak detection
                _, idx_intc_defl = deflection(cv_size,volt,current)
                idx_intc_defl_lst.append(idx_intc_defl)
                
                window['cv_combo_cv'].Update(values=cv_name_lst) # Update combo list of CVs
                window['cv_combo_cv'].Update(cv_name) # Update default combo display
                values['cv_combo_cv'] = cv_name
                window['cv_combo_ecsa'].Update(values=cv_name_lst) # Update combo list of CVs
                window['cv_combo_ecsa'].Update(cv_name) # Update default combo display
                values['cv_combo_ecsa'] = cv_name
                disable_slider(False)
                cv_select = cv_name    
                cv_name_idx = cv_name_lst.index(cv_select)
                # cv_results.loc[cv_name_idx] = [cv_select, file_scan_rate, '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']   
        except FileNotFoundError as file_not_found_error:
            sg.popup('CV file not found, maybe missing file was moved',file_not_found_error, keep_on_top=True)
            continue
             
        volt = volt_lst[cv_name_idx]
        current = current_lst[cv_name_idx]
        cv_size = cv_size_lst[cv_name_idx]
        idx_arr = np.arange(0,cv_size)
        idx_defl_points = np.array(idx_intc_defl_lst[cv_name_idx])       
        window['sl_cutval_s'].Update(range=(0,cv_size-1))
        window['sl_cutval_e'].Update(range=(0,cv_size-1))
        window['sl_jpa_lns'].Update(range=(0,cv_size-1))
        window['sl_jpa_lne'].Update(range=(0,cv_size-1))
        window['sl_jpc_lns'].Update(range=(0,cv_size-1))
        window['sl_jpc_lne'].Update(range=(0,cv_size-1))
        window['peak_range'].Update(range=(1, 100))
        window['peak_pos'].Update(range=(1, cv_size-1))
        window['trou_pos'].Update(range=(1, cv_size-1))
        window['idx_jsp0'].Update(range=(1, cv_size-1))
        
    if event in ('cv_open_menu', 'cv_open_menu_ecsa'):
        if values['cv_open_menu'] == "VersaSTAT4 (.par)" or values['cv_open_menu_ecsa'] == "VersaSTAT4 (.par)":
            file_format = "VersaSTAT"
            cv_file_new = sg.popup_get_file('Choose VersaSTAT4 CV file',multiple_files=True)
        elif values['cv_open_menu'] == "CorrWare (.cor)" or values['cv_open_menu_ecsa'] == "CorrWare (.cor)":
            file_format = "CorrWare"
            cv_file_new = sg.popup_get_file('Choose CorrWare CV file',multiple_files=True)
        elif values['cv_open_menu'] == "CSV (.csv)" or values['cv_open_menu_ecsa'] == "CSV (.csv)":
            file_format = "CSV"
            cv_file_new = sg.popup_get_file('Choose CSV CV file',multiple_files=True)
        elif values['cv_open_menu'] == "text (.txt)" or values['cv_open_menu_ecsa'] == "text (.txt)":
            file_format = "text"
            cv_file_new = sg.popup_get_file('Choose text CV file',multiple_files=True)
            
        # If cancel, close the window, go back to beginning
        if cv_file_new is None or cv_file_new == '' or cv_file_new == ():
            continue
        try:
            cv_file_multiple = cv_file_new     
            for cv_file in cv_file_multiple.split(';'):      
                cv_name = os.path.basename(cv_file) #Get file name
                df_CV, file_scan_rate = CV_file2df(cv_file, file_format)       
                cv_size, volt, current = get_CV_init(df_CV)
                cv_path_lst.append(cv_file) #Create 2D array of CVs so we can select, plot, and analyze data based on index
                cv_name_lst.append(cv_name)
                volt_lst.append(volt)
                current_lst.append(current)
                volt_ir_lst.append(volt) #Append volt to ir compensated volt, this is like ir=0
                current_den_lst.append(current) # This is like elec_area = 1
                cv_size_lst.append(cv_size)
                
                # deflection and Peak detection
                _, idx_intc_defl = deflection(cv_size,volt,current)
                idx_intc_defl_lst.append(idx_intc_defl)
                
                ###############################################################################
                # Add new value from the CV file to save data array
                fitting_default[:,0] = cv_file
                fitting_default[:,1] = file_format
                fitting_default[:,3] = cv_size
                # fitting_default[:,4] = int(cv_size/10)
                fitting_default[:,20] = cv_size 
                fitting_default[:,17] = file_scan_rate
                fitting_save_array = np.append(fitting_save_array,fitting_default,axis=0)
                ###############################################################################
                
                window['cv_combo_cv'].Update(values=cv_name_lst) # Update combo list of CVs
                window['cv_combo_cv'].Update(cv_name) # Update default combo display
                values['cv_combo_cv'] = cv_name
                window['cv_combo_ecsa'].Update(values=cv_name_lst) # Update combo list of CVs
                window['cv_combo_ecsa'].Update(cv_name) # Update default combo display
                values['cv_combo_ecsa'] = cv_name
                disable_slider(False)
                cv_select = cv_name    
                cv_name_idx = cv_name_lst.index(cv_select)
                cv_results.loc[cv_name_idx] = [cv_select, file_scan_rate, '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
                
            volt = volt_lst[cv_name_idx]
            current = current_lst[cv_name_idx]
            cv_size = cv_size_lst[cv_name_idx]
            idx_arr = np.arange(0,cv_size)
            idx_defl_points = np.array(idx_intc_defl_lst[cv_name_idx])
            
            window['sl_cutval_s'].Update(range=(0,cv_size-1))
            window['sl_cutval_e'].Update(range=(0,cv_size-1))
            window['sl_jpa_lns'].Update(range=(0,cv_size-1))
            window['sl_jpa_lne'].Update(range=(0,cv_size-1))
            window['sl_jpc_lns'].Update(range=(0,cv_size-1))
            window['sl_jpc_lne'].Update(range=(0,cv_size-1))
            window['peak_range'].Update(range=(1, 100))
            window['peak_pos'].Update(range=(1, cv_size-1))
            window['trou_pos'].Update(range=(1, cv_size-1))
            window['idx_jsp0'].Update(range=(1, cv_size-1))
        except Exception as file_error:
            sg.popup(file_error, keep_on_top=True)
            continue
        
    # if event == 1:
    #     print("===========tab change========")

    if event in ('cv_open_menu','cv_load_cv','cv_combo_cv'): #Change combo also update slider range
        cv_select = values['cv_combo_cv']
        if values['cv_combo_cv'] == '': #Prevent error when combo box value is empty
            cv_name_idx = 0
        else:
            cv_name_idx = cv_name_lst.index(cv_select)  
        volt = volt_lst[cv_name_idx]
        current = current_lst[cv_name_idx]
        cv_size = cv_size_lst[cv_name_idx]
        idx_arr = np.arange(0,cv_size)
        idx_defl_points = np.array(idx_intc_defl_lst[cv_name_idx]) 
        window['sl_cutval_s'].Update(range=(0,cv_size-1))
        window['sl_cutval_e'].Update(range=(0,cv_size-1))
        window['sl_jpa_lns'].Update(range=(0,cv_size-1))
        window['sl_jpa_lne'].Update(range=(0,cv_size-1))
        window['sl_jpc_lns'].Update(range=(0,cv_size-1))
        window['sl_jpc_lne'].Update(range=(0,cv_size-1))
        window['peak_range'].Update(range=(1, 100))
        window['peak_pos'].Update(range=(1, cv_size-1))
        window['trou_pos'].Update(range=(1, cv_size-1))
        window['idx_jsp0'].Update(range=(1, cv_size-1))
        if cv_name_idx != cv_name_idx_old: #If the option index change (combo box change), update slider
            cv_name_idx_old = cv_name_idx                    
            # Restore saved values
            cutval_s_save = int(fitting_save_array[cv_name_idx+1,2])
            cutval_e_save = int(fitting_save_array[cv_name_idx+1,3])
            jpa_lns_save = int(fitting_save_array[cv_name_idx+1,4])
            jpa_lne_save = int(fitting_save_array[cv_name_idx+1,5])
            jpc_lns_save = int(fitting_save_array[cv_name_idx+1,6])
            jpc_lne_save = int(fitting_save_array[cv_name_idx+1,7])
            peak_pos_save = int(fitting_save_array[cv_name_idx+1,8])
            trou_pos_save = int(fitting_save_array[cv_name_idx+1,9])
            peak_range_save = int(fitting_save_array[cv_name_idx+1,10])
            ir_compen_save = float(fitting_save_array[cv_name_idx+1,11])
            peak_mode_1_save = str(fitting_save_array[cv_name_idx+1,12])
            peak_mode_2_save = str(fitting_save_array[cv_name_idx+1,13])
            elec_area_save = float(fitting_save_array[cv_name_idx+1,14])
            idx_jsp0_save = int(fitting_save_array[cv_name_idx+1,15])
            inv_jpa_jpc_save = int(fitting_save_array[cv_name_idx+1,16])
            scan_rate_save = float(fitting_save_array[cv_name_idx+1,17])
            nicholson_cb_save = float(fitting_save_array[cv_name_idx+1,18])
            # Put slider to previous position, this is just what is shown not real value
            window['sl_cutval_s'].Update(cutval_s_save)
            window['sl_cutval_e'].Update(cutval_e_save)           
            window['sl_jpa_lns'].Update(jpa_lns_save)
            window['sl_jpa_lne'].Update(jpa_lne_save)
            window['sl_jpc_lns'].Update(jpc_lns_save)
            window['sl_jpc_lne'].Update(jpc_lne_save)
            window['peak_pos'].Update(peak_pos_save)
            window['trou_pos'].Update(trou_pos_save)
            window['peak_range'].Update(peak_range_save)
            window['ir_compen'].Update(ir_compen_save)
            window['peak_mode_1'].Update(peak_mode_1_save)
            window['peak_mode_2'].Update(peak_mode_2_save)
            window['elec_area'].Update(elec_area_save)
            window['idx_jsp0'].Update(idx_jsp0_save)
            window['inv_jpa_jpc'].Update(inv_jpa_jpc_save)
            window['scan_rate'].Update(scan_rate_save)
            window['nicholson_cb'].Update(nicholson_cb_save)
            # Put actual value             
            values['sl_cutval_s'] = cutval_s_save
            values['sl_cutval_e'] = cutval_e_save           
            values['sl_jpa_lns'] = jpa_lns_save
            values['sl_jpa_lne'] = jpa_lne_save
            values['sl_jpc_lns'] = jpc_lns_save
            values['sl_jpc_lne'] = jpc_lne_save
            values['peak_pos'] = peak_pos_save
            values['trou_pos'] = trou_pos_save
            values['peak_range'] = peak_range_save
            values['ir_compen'] = ir_compen_save
            values['peak_mode_1'] = peak_mode_1_save
            values['peak_mode_2'] = peak_mode_2_save
            values['elec_area'] = elec_area_save
            values['idx_jsp0'] = idx_jsp0_save
            values['inv_jpa_jpc'] = inv_jpa_jpc_save
            values['scan_rate'] = scan_rate_save
            values['nicholson_cb'] = nicholson_cb_save  
            
            # Assign the value from saved data
            cutval_s = cutval_s_save
            cutval_e = cutval_e_save
            jpa_lns = jpa_lns_save
            jpa_lne = jpa_lne_save
            jpc_lns = jpc_lns_save
            jpc_lne = jpc_lne_save
            peak_pos = peak_pos_save
            trou_pos = trou_pos_save
            peak_range = peak_range_save
            ir_compen = ir_compen_save
            peak_mode_1 = peak_mode_1_save
            peak_mode_2 = peak_mode_2_save
            elec_area = elec_area_save
            idx_jsp0 = idx_jsp0_save
            inv_jpa_jpc = inv_jpa_jpc_save
            scan_rate = scan_rate_save
            nicholson_cb = nicholson_cb_save
            
        # elif cv_name_idx == cv_name_idx_old: #If combobox does not change, simply read value from slider
    if event in ('cv_open_menu', 'cv_load_cv', 'ir_compen', 'elec_area','inv_jpa_jpc', 'sl_cutval_s', 'sl_cutval_e', 'sl_jpa_lns', 'sl_jpa_lne',  'sl_jpc_lns', 'sl_jpc_lne', 'peak_range', 'peak_pos', 'trou_pos', 'sl_cutval_s_pos', 'sl_cutval_e_pos', 'sl_jpa_lns_pos', 'sl_jpa_lne_pos',  'sl_jpc_lns_pos', 'sl_jpc_lne_pos', 'peak_range_pos', 'peak_pos_pos', 'trou_pos_pos', 'nicholson_cb', 'idx_jsp0', 'idx_jsp0_pos', 'scan_rate', 'bulk_conc', 'elec_n', 'enable_d', 'enable_k','peak_mode_1', 'peak_mode_2'):
        cutval_s = int(values['sl_cutval_s'])
        cutval_e = int(values['sl_cutval_e'])        
        jpa_lns = int(values['sl_jpa_lns'])
        jpa_lne = int(values['sl_jpa_lne'])
        jpc_lns = int(values['sl_jpc_lns'])
        jpc_lne = int(values['sl_jpc_lne'])
        peak_pos = int(values['peak_pos'])
        trou_pos = int(values['trou_pos'])
        peak_range = int(values['peak_range'])
        peak_mode_1 = str(values['peak_mode_1'])
        peak_mode_2 = str(values['peak_mode_2'])
        idx_jsp0 = int(values['idx_jsp0'])
        inv_jpa_jpc = int(values['inv_jpa_jpc'])
        nicholson_cb = int(values['nicholson_cb'])
        # Make sure that proper number format is used
        ir_compen = check_val(values['ir_compen'], "float", 0)
        scan_rate = check_val(values['scan_rate'], "float", 0)
        elec_area = check_val(values['elec_area'], "float", 1)    
        cutval_s_pos = check_val(values['sl_cutval_s_pos'], "int", 1)
        cutval_e_pos = check_val(values['sl_cutval_e_pos'], "int", 1)  
        jpa_lns_pos = check_val(values['sl_jpa_lns_pos'], "int", 1)
        jpa_lne_pos = check_val(values['sl_jpa_lne_pos'], "int", 1)  
        jpc_lns_pos = check_val(values['sl_jpc_lns_pos'], "int", 1)  
        jpc_lne_pos = check_val(values['sl_jpc_lne_pos'], "int", 1)  
        peak_range_pos = check_val(values['peak_range_pos'], "int", 1)  
        peak_pos_pos = check_val(values['peak_pos_pos'], "int", 1) 
        trou_pos_pos = check_val(values['trou_pos_pos'], "int", 1)
        idx_jsp0_pos = check_val(values['idx_jsp0_pos'], "int", 1) 
        
        if event == 'sl_cutval_s':
            window['sl_cutval_s_pos'].Update(cutval_s)
        elif event == 'sl_cutval_s_pos':
            window['sl_cutval_s'].Update(cutval_s_pos)
            cutval_s = cutval_s_pos
            
        elif event == 'sl_cutval_e':
            window['sl_cutval_e_pos'].Update(cutval_e)
        elif event == 'sl_cutval_e_pos':
            window['sl_cutval_e'].Update(cutval_e_pos)
            cutval_e = cutval_e_pos
        
        elif event == 'sl_jpa_lns':
            window['sl_jpa_lns_pos'].Update(jpa_lns)
        elif event == 'sl_jpa_lns_pos':
            window['sl_jpa_lns'].Update(jpa_lns)
            jpa_lns = jpa_lns_pos
            
        elif event == 'sl_jpa_lne':
            window['sl_jpa_lne_pos'].Update(jpa_lne)
        elif event == 'sl_jpa_lne_pos':
            window['sl_jpa_lne'].Update(jpa_lne)
            jpa_lne = jpa_lne_pos
            
        elif event == 'sl_jpc_lns':
            window['sl_jpc_lns_pos'].Update(jpc_lns)
        elif event == 'sl_jpc_lns_pos':
            window['sl_jpc_lns'].Update(jpc_lns)
            jpc_lns = jpc_lns_pos
            
        elif event == 'sl_jpc_lne':
            window['sl_jpc_lne_pos'].Update(jpc_lne)
        elif event == 'sl_jpc_lne_pos':
            window['sl_jpc_lne'].Update(jpc_lne)
            jpc_lne = jpc_lne_pos
            
        elif event == 'peak_range':
            window['peak_range_pos'].Update(peak_range)
        elif event == 'peak_range_pos':
            window['peak_range'].Update(peak_range_pos)
            peak_range = peak_range_pos     
            
        elif event == 'peak_pos':
            window['peak_pos_pos'].Update(peak_pos)
        elif event == 'peak_pos_pos':
            window['peak_pos'].Update(peak_pos_pos)
            peak_pos = peak_pos_pos     
            
        elif event == 'trou_pos':
            window['trou_pos_pos'].Update(trou_pos)
        elif event == 'trou_pos_pos':
            window['trou_pos'].Update(trou_pos_pos)
            trou_pos = trou_pos_pos   
            
        elif event == 'idx_jsp0':
            window['idx_jsp0_pos'].Update(idx_jsp0)
        elif event == 'idx_jsp0_pos':
            window['idx_jsp0'].Update(idx_jsp0_pos)
            idx_jsp0 = idx_jsp0_pos      
        cutval_s,cutval_e = switch_val(cutval_s,cutval_e)
        jpa_lns,jpa_lne = switch_val(jpa_lns,jpa_lne)
        jpc_lns,jpc_lne = switch_val(jpc_lns,jpc_lne)
        
        fitting_save_cv = np.array([cutval_s, cutval_e, jpa_lns, jpa_lne, jpc_lns, jpc_lne, peak_pos, trou_pos, peak_range, ir_compen, peak_mode_1, peak_mode_2,elec_area, idx_jsp0, inv_jpa_jpc, scan_rate, nicholson_cb])
        
        fitting_save_array[cv_name_idx+1][2:19] = fitting_save_cv
        if ir_compen != ir_compen_old:
            ir_compen_old = ir_compen
            volt_compen = ir_compen_func(volt,current,ir_compen)
            # Overwrite volt and curr with ir compen
            volt_ir_lst[cv_name_idx] = volt_compen
        else:
            volt_compen = volt_ir_lst[cv_name_idx]
        
        if elec_area != elec_area_old:
            elec_area_old = elec_area
            current_den = current/elec_area
            # Overwrite current with current density
            current_den_lst[cv_name_idx] = current_den
        else:
            current_den = current_den_lst[cv_name_idx]
    
        if peak_mode_1 == 'deflection':
            peak_pos = idx_defl_points[np.abs(idx_defl_points - peak_pos).argmin()]
            peak_pos = int(peak_pos)
        if peak_mode_2 == 'deflection':
            trou_pos = idx_defl_points[np.abs(idx_defl_points - trou_pos).argmin()]
            trou_pos = int(trou_pos)
            
        ax_cv.cla() ###### Clear plot before redraw    
        if nicholson_cb == False:
            low_range_a, high_range_a, peak_volt, peak_curr_a, jpa, jpa_poly1d = get_peak_CV(peak_mode_1,cv_size, volt, current, peak_range, peak_pos, jpa_lns, jpa_lne)
            low_range_c, high_range_c, trou_volt, peak_curr_c, jpc, jpc_poly1d = get_peak_CV(peak_mode_2,cv_size, volt, current, peak_range, trou_pos, jpc_lns, jpc_lne)                
            
            # Find alpha
            ep12_jpa, jp12_jpa, alpha_jpa = find_alpha(volt_compen,current_den,jpa_lns,peak_pos,jpa_poly1d,jpa,peak_volt)
            ep12_jpc, jp12_jpc, alpha_jpc = find_alpha(volt_compen,current_den,jpc_lns,trou_pos,jpc_poly1d,jpc,trou_volt)
            
            ax_cv.plot(ep12_jpa,jp12_jpa,'x')
            ax_cv.plot(ep12_jpc,jp12_jpc,'x')
            
            # Find estimate standard electrode potential (E1/2~E0)
            E1_2 = (trou_volt+peak_volt)/2
            # Find peak-peak separation voltage
            delta_e = np.abs(trou_volt-peak_volt)
            
            ax_cv.plot(E1_2,0,"D", markersize = 6)
            
            
            ax_cv.plot((volt_compen[low_range_a],volt_compen[high_range_a]),(current_den[low_range_a],current_den[high_range_a]),"|", markersize = 10)
            ax_cv.plot((volt_compen[low_range_c],volt_compen[high_range_c]),(current_den[low_range_c],current_den[high_range_c]),"|", markersize = 10)
        
            ax_cv.plot(volt_compen[jpa_lns:jpa_lne],current_den[jpa_lns:jpa_lne],linewidth=2,linestyle='-', color='red')
            ax_cv.arrow(peak_volt,jpa_poly1d(peak_volt),0,jpa,linewidth=0.2,head_width=0.005, head_length=0.0003 ,color='r', length_includes_head=True)
            ax_cv.plot(np.array([volt_compen[jpa_lns],peak_volt]),np.array([jpa_poly1d(volt_compen[jpa_lns]),jpa_poly1d(peak_volt)]),'--', color='red')
            
            ax_cv.plot(volt_compen[jpc_lns:jpc_lne],current_den[jpc_lns:jpc_lne],linewidth=2,linestyle='-',color='blue')
            ax_cv.arrow(trou_volt,jpc_poly1d(trou_volt),0,jpc,linewidth=0.2,head_width=0.005, head_length=0.0003, color='b', length_includes_head=True)
            ax_cv.plot(np.array([volt_compen[jpc_lns],trou_volt]),np.array([jpc_poly1d(volt_compen[jpc_lns]),jpc_poly1d(trou_volt)]),'--', color='blue')
            jpc0 = 0 #Only with Nicholson method
            jpc = np.abs(jpc) # Report positive value
        elif nicholson_cb == True:
            if values['inv_jpa_jpc'] == True: 
                jp1_text = 'jpc'
                jp2_text = 'jpa0'
            else:
                jp1_text = 'jpa'
                jp2_text = 'jpc0'
            jpc0_lns = jpa_lns
            jpc0_lne = jpa_lne
            
            low_range_a, high_range_a, peak_volt, peak_curr_a, jpa, jpa_poly1d = get_peak_CV(peak_mode_1,cv_size, volt, current, peak_range, peak_pos, jpa_lns, jpa_lne)
            low_range_c, high_range_c, trou_volt, peak_curr_c, jpc0, _ = get_peak_CV(peak_mode_2,cv_size, volt, current, peak_range, trou_pos, jpa_lns, jpa_lne)
            # Find estimate standard electrode potential (E1/2~E0)
            E1_2 = (peak_volt+trou_volt)/2
            # Find peak-peak separation voltage
            delta_e = np.abs(trou_volt-peak_volt)
            ax_cv.plot(E1_2,0,"D", markersize = 6)
        
            ax_cv.plot((volt_compen[low_range_a],volt_compen[high_range_a]),(current_den[low_range_a],current_den[high_range_a]),"|", markersize = 10)
            ax_cv.plot((volt_compen[low_range_c],volt_compen[high_range_c]),(current_den[low_range_c],current_den[high_range_c]),"|", markersize = 10)
        
            ax_cv.plot(np.array([volt_compen[jpa_lns],peak_volt]),np.array([jpa_poly1d(volt_compen[jpa_lns]),jpa_poly1d(peak_volt)]),'--', color='green') #Peak
            ax_cv.plot(np.array([volt_compen[jpa_lns],trou_volt]),np.array([jpa_poly1d(volt_compen[jpa_lns]),jpa_poly1d(trou_volt)]),'--', color='green') #Peak    
            ax_cv.arrow(trou_volt,jpa_poly1d(trou_volt),0,jpc0,linewidth=0.2,head_width=0.005, head_length=0.0003 ,color='green', length_includes_head=True) #jpc0 
            ax_cv.arrow(peak_volt,jpa_poly1d(peak_volt),0,jpa,linewidth=0.2,head_width=0.005, head_length=0.0003, color='black', length_includes_head=True) #jpa
    
            jsp0_volt = volt_compen[idx_jsp0]
            jsp0 = current_den[idx_jsp0]-jpa_poly1d(jsp0_volt)
            ax_cv.plot(np.array([volt_compen[jpa_lns],volt_compen[idx_jsp0]]),np.array([jpa_poly1d(volt_compen[jpa_lns]),jpa_poly1d(jsp0_volt)]),'--', color='green') #jsp0
            ax_cv.plot(volt_compen[jpa_lns:jpa_lne],current_den[jpa_lns:jpa_lne],linewidth=3,linestyle='-', color='blue')
            ax_cv.arrow(volt_compen[idx_jsp0],jpa_poly1d(jsp0_volt),0,jsp0,linewidth=0.2,head_width=0.005, head_length=0.0003, color='b', length_includes_head=True) #jsp0
            
            ax_cv.text(peak_volt,jpa_poly1d(peak_volt), jp1_text, fontsize=10)
            ax_cv.text(trou_volt,jpa_poly1d(trou_volt), jp2_text, fontsize=10)
            ax_cv.text(volt_compen[idx_jsp0],jpa_poly1d(jsp0_volt), 'jsp0', fontsize=10)
            
            jpa = np.abs(jpa)
            jpc0 = np.abs(jpc0)
            jsp0 = np.abs(jsp0)
            # Nicholson, R. S. Semiempirical Procedure for Measuring with
            # Stationary Electrode Polarography Rates of Chemical Reactions
            # Involving the Product of Electron Transfer. Anal. Chem. 1966, 38
            # (10), 1406.
            jpc = np.abs(jpa*((jpc0/jpa)+((0.485*np.abs(jsp0))/jpa)+0.086))
            window['jsp0_volt'].Update(jsp0_volt)            
            # invert jpa and jpc or not
        if values['inv_jpa_jpc'] == True:
            jpa, jpc = jpc, jpa
            alpha_jpa, alpha_jpc = alpha_jpc, alpha_jpa
                
        # Plot lines
        volt_lst_len = len(volt_lst)
        for j in np.arange(0,volt_lst_len):
            cutval_s_all = int(fitting_save_array[j+1,2])
            cutval_e_all = int(fitting_save_array[j+1,3])
            ax_cv.plot(np.array(volt_ir_lst[j][cutval_s_all:cutval_e_all]).T, np.array(current_den_lst[j][cutval_s_all:cutval_e_all]).T, '-', color='black',linewidth=0.8)
        
        if peak_mode_1 == "deflection" or peak_mode_2 == "deflection":
            clip_defl = idx_defl_points[(idx_defl_points >= cutval_s) & (idx_defl_points <= cutval_e)]
            volt_defl = np.interp([clip_defl], idx_arr, volt_compen)
            curr_defl = np.interp([clip_defl], idx_arr, current_den)
      
            ax_cv.plot(volt_defl,curr_defl,'.',color='green')
        ax_cv.grid()
        ax_cv.set_xlabel("Voltage")
        ax_cv.set_ylabel("Current")       
        fig_agg_cv.draw()
        
        print(cv_results.to_string)
        cv_results.loc[cv_name_idx] = [cv_select, scan_rate, jpa, jpc, jpc0, peak_volt, trou_volt, jpa/jpc, E1_2, delta_e, alpha_jpa, alpha_jpc]
        cv_results = cv_results.sort_index()
        window['cv_results_dis'].Update(cv_results.to_string(index=False))
            
        try:
            bulk_conc = float(values['bulk_conc'])
        except ValueError:
            bulk_conc = float(0)             
            
        try:
            elec_n = int(values['elec_n'])
        except ValueError:
            elec_n = int(1)
        
        alpha_ano = np.average(np.asarray(cv_results.loc[:,'alpha_ano'].to_numpy(), dtype=float))
        alpha_cat = np.average(np.asarray(cv_results.loc[:,'alpha_cat'].to_numpy(), dtype=float))
        window['alpha_ano'].Update(alpha_ano)
        window['alpha_cat'].Update(alpha_cat)    

        if values['enable_d'] == True and values[0] == 'cv_diff_layout_key':
            jpc_arr = np.asarray(cv_results.loc[:,'Jpc'].to_numpy(), dtype=float)
            jpa_arr = np.asarray(cv_results.loc[:,'Jpa'].to_numpy(), dtype=float)
            scan = np.array([float(value) for value in cv_results['scan_rate']])
            # Plot peak current vs scan rate^1/2 to find diffusion coefficient
            ax_cv_D.cla()
            try:
                sqrt_scan_ano, jpa_fit ,D_irr_a ,D_rev_a ,r2_ano = diffusion(scan,jpa_arr,alpha_ano,bulk_conc,elec_n)
                sqrt_scan_cat, jpc_fit ,D_irr_c ,D_rev_c ,r2_cat = diffusion(scan,jpc_arr,alpha_cat,bulk_conc,elec_n)
                ax_cv_D.plot(sqrt_scan_ano,jpa_fit,'-',color='red')
                ax_cv_D.plot(sqrt_scan_cat,jpc_fit,'-',color='blue')
                window['d_rev_jpa'].Update(f"{D_rev_a:e}")
                window['d_rev_jpc'].Update(f"{D_rev_c:e}")
                window['d_irr_jpa'].Update(f"{D_irr_a:e}")
                window['d_irr_jpc'].Update(f"{D_irr_c:e}")
            except SystemError:
                pass
            ax_cv_D.plot(sqrt_scan_ano,jpa_arr,'o',color='red',label='Jpa')
            ax_cv_D.plot(sqrt_scan_cat,jpc_arr,'o',color='blue',label='Jpc')
            ax_cv_D.set_xlabel("Scan rate 1/2")
            ax_cv_D.set_ylabel("Jp")
            fig_cv_D.legend()
            fig_agg_cv_D.draw()
        #Find kinetic parameter
        if values['enable_k'] == True and values[0] == 'cv_kin_layout_key':
            jpc_arr = np.asarray(cv_results.loc[:,'Jpc'].to_numpy(), dtype=float)
            jpa_arr = np.asarray(cv_results.loc[:,'Jpa'].to_numpy(), dtype=float)
            e_e0_arr = (np.array([float(value) for value in cv_results['ΔE\u209a']]))/2
            ax_cv_kin.cla()
            try: 
                lnjpa, lnjpa_fit, k0_a, alpha_cat_a, alpha_ano_a, r2_a = reaction_rate(e_e0_arr,jpa_arr,bulk_conc,elec_n)
                lnjpc, lnjpc_fit, k0_c, alpha_cat_c, alpha_ano_c, r2_c = reaction_rate(e_e0_arr,jpc_arr,bulk_conc,elec_n)
                ax_cv_kin.plot(e_e0_arr,lnjpa_fit,'-',color='red')
                ax_cv_kin.plot(e_e0_arr,lnjpc_fit,'-',color='blue')
                window['k_jpa'].Update(f"{k0_a:e}")
                window['k_jpc'].Update(f"{k0_c:e}")
            except SystemError:
                pass            
            ax_cv_kin.plot(e_e0_arr,lnjpa,'o',color='red',label='Jpa')
            ax_cv_kin.plot(e_e0_arr,lnjpc,'o',color='blue',label='Jpc')
            ax_cv_kin.set_xlabel("Ep - E0")
            ax_cv_kin.set_ylabel("Jp")
            fig_cv_kin.legend()
            fig_agg_cv_k.draw()

    if event == 'save_cv_param':
        cv_param = sg.popup_get_file('', save_as=True, no_window=True, file_types=(("TXT Files", "*.txt"), ("All Files", "*.*")))
        directory, filename = os.path.split(cv_param)
        filename_without_extension, _ = os.path.splitext(filename)
        results_filename = f"{filename_without_extension}_results.ods"
        cv_result_path = os.path.join(directory, results_filename)

        np.savetxt(cv_param, fitting_save_array, delimiter=',', fmt='%s')
        cv_results.to_excel(cv_result_path, index=True)

        #====================================================================================#
        #======================================CV ECSA ======================================#
        #====================================================================================#
    # if event in ('cv_open_menu_ecsa', 'cv_load_ecsa','cv_combo_ecsa'):
        cv_select = values['cv_combo_ecsa']
        if values['cv_combo_ecsa'] == '': #Prevent error when combo box value is empty
            cv_name_idx = 0
        else:
            cv_name_idx = cv_name_lst.index(cv_select)
        volt = volt_lst[cv_name_idx]
        current = current_lst[cv_name_idx]
        cv_size = cv_size_lst[cv_name_idx]
        idx_arr = np.arange(0,cv_size)
        idx_defl_points = np.array(idx_intc_defl_lst[cv_name_idx]) 
        window['sl_cutval_s_ecsa'].Update(range=(0,cv_size-1))
        window['sl_cutval_e_ecsa'].Update(range=(0,cv_size-1))
        window['sl_v_ln_ecsa'].Update(range=(0,cv_size-1))
        window['sl_h_ln_ecsa'].Update(range=(0,cv_size-1))
        window['peak_range_ecsa'].Update(range=(1,100))  
        
        if cv_name_idx != cv_name_idx_old: #If the option index change (combo box change), update slider
            cv_name_idx_old = cv_name_idx                    
            # Restore saved values        
            cutval_s_ecsa_save = int(fitting_save_array[cv_name_idx+1,19])
            cutval_e_ecsa_save = int(fitting_save_array[cv_name_idx+1,20])               
            v_ln_ecsa_save = int(fitting_save_array[cv_name_idx+1,21])
            h_ln_ecsa_save = int(fitting_save_array[cv_name_idx+1,22])
            peak_range_ecsa_save = int(fitting_save_array[cv_name_idx+1,23])
            # Put slider to previous position
            window['sl_cutval_s_ecsa'].Update(cutval_s_ecsa_save)
            window['sl_cutval_e_ecsa'].Update(cutval_e_ecsa_save)
            window['sl_v_ln_ecsa'].Update(v_ln_ecsa_save)
            window['sl_h_ln_ecsa'].Update(h_ln_ecsa_save)
            window['peak_range_ecsa'].Update(peak_range_ecsa_save)  
            window['sl_cutval_s_ecsa_pos'].Update(cutval_s_ecsa_save)
            window['sl_cutval_e_ecsa_pos'].Update(cutval_e_ecsa_save)
            window['sl_v_ln_ecsa_pos'].Update(v_ln_ecsa_save)                   
            window['sl_h_ln_ecsa_pos'].Update(h_ln_ecsa_save)
            window['peak_range_ecsa_pos'].Update(h_ln_ecsa_save)
            # Put actual value    
            values['sl_cutval_s_ecsa'] = cutval_s_ecsa_save
            values['sl_cutval_e_ecsa'] = cutval_e_ecsa_save
            values['sl_v_ln_ecsa'] = v_ln_ecsa_save
            values['sl_h_ln_ecsa'] = h_ln_ecsa_save
            values['peak_range_ecsa'] = peak_range_ecsa_save
            values['sl_cutval_s_ecsa_pos'] = cutval_s_ecsa_save
            values['sl_cutval_e_ecsa_pos'] = cutval_e_ecsa_save
            values['sl_v_ln_ecsa_pos'] = v_ln_ecsa_save          
            values['sl_h_ln_ecsa_pos'] = h_ln_ecsa_save
            values['peak_range_ecsa_pos'] = h_ln_ecsa_save
            
            # Assign the value from saved data
            cutval_s_ecsa = cutval_s_ecsa_save
            cutval_e_ecsa = cutval_e_ecsa_save
            v_ln_ecsa = v_ln_ecsa_save
            h_ln_ecsa = h_ln_ecsa_save
            cutval_s_ecsa_pos = cutval_s_ecsa_save
            cutval_e_ecsa_pos = cutval_e_ecsa_save
            v_ln_ecsa_pos = v_ln_ecsa_save
            h_ln_ecsa_pos = h_ln_ecsa_save
            peak_range_ecsa = peak_range_ecsa_save
        
    # if event in ('cv_open_menu_ecsa', 'sl_v_ln_ecsa', 'sl_h_ln_ecsa', 'sl_cutval_s_ecsa', 'sl_cutval_e_ecsa', 'peak_range_ecsa', 'ir_compen_ecsa', 'sl_cutval_s_ecsa_pos', 'sl_cutval_e_ecsa_pos', 'sl_v_ln_ecsa_pos', 'sl_h_ln_ecsa_pos', 'peak_range_ecsa_pos'):
        cutval_s_ecsa = int(values['sl_cutval_s_ecsa'])
        cutval_e_ecsa = int(values['sl_cutval_e_ecsa'])
        v_ln_ecsa = int(values['sl_v_ln_ecsa'])
        h_ln_ecsa = int(values['sl_h_ln_ecsa'])  
        peak_range_ecsa = int(values['peak_range_ecsa'])
        # Make sure that proper number format is used
        ir_compen = check_val(values['ir_compen'], "float", 0)
        scan_rate = check_val(values['scan_rate'], "float", 0)
        elec_area = check_val(values['elec_area'], "float", 1)
        
        cutval_s_ecsa_pos = check_val(values['sl_cutval_s_ecsa_pos'], "int", 1)
        cutval_e_ecsa_pos = check_val(values['sl_cutval_e_ecsa_pos'], "int", 1)    
        v_ln_ecsa_pos = check_val(values['sl_v_ln_ecsa_pos'], "int", 1)
        h_ln_ecsa_pos = check_val(values['sl_h_ln_ecsa_pos'], "int", 1)   
        peak_range_ecsa_pos = check_val(values['peak_range_ecsa_pos'], "int", 1)
            
        if event == 'sl_cutval_s_ecsa':
            window['sl_cutval_s_ecsa_pos'].Update(cutval_s_ecsa)
        elif event == 'sl_cutval_s_ecsa_pos':
            window['sl_cutval_s_ecsa'].Update(cutval_s_ecsa_pos)
            cutval_s_ecsa = cutval_s_ecsa_pos
            
        elif event == 'sl_cutval_e_ecsa':
            window['sl_cutval_e_ecsa_pos'].Update(cutval_e_ecsa)
        elif event == 'sl_cutval_e_ecsa_pos':
            window['sl_cutval_e_ecsa'].Update(cutval_e_ecsa_pos)
            cutval_e_ecsa = cutval_e_ecsa_pos
        
        elif event == 'sl_v_ln_ecsa':
            window['sl_v_ln_ecsa_pos'].Update(v_ln_ecsa)
        elif event == 'sl_v_ln_ecsa_pos':
            window['sl_v_ln_ecsa'].Update(v_ln_ecsa_pos)
            v_ln_ecsa = v_ln_ecsa_pos
            
        elif event == 'sl_h_ln_ecsa':
            window['sl_h_ln_ecsa_pos'].Update(h_ln_ecsa)
        elif event == 'sl_h_ln_ecsa_pos':
            window['sl_h_ln_ecsa'].Update(h_ln_ecsa_pos)
            h_ln_ecsa = h_ln_ecsa_pos  
            
        elif event == 'peak_range_ecsa':
            window['peak_range_ecsa_pos'].Update(peak_range_ecsa)
        elif event == 'peak_range_ecsa_pos':
            window['peak_range_ecsa'].Update(peak_range_ecsa_pos)
            peak_range_ecsa = peak_range_ecsa_pos           
                      
        cutval_s_ecsa,cutval_e_ecsa = switch_val(cutval_s_ecsa,cutval_e_ecsa)

        fitting_save_ecsa = np.array([cutval_s_ecsa, cutval_e_ecsa, v_ln_ecsa, h_ln_ecsa, peak_range_ecsa], dtype=object) 
        fitting_save_array[cv_name_idx+1][19:24] = fitting_save_ecsa
        
        if ir_compen != ir_compen_old:
            ir_compen_old = ir_compen
            volt_compen = ir_compen_func(volt,current,ir_compen)
            # Overwrite volt and curr with ir compen
            volt_ir_lst[cv_name_idx] = volt_compen
        else:
            volt_compen = volt_ir_lst[cv_name_idx]
        
        if elec_area != elec_area_old:
            elec_area_old = elec_area
            current_den = current/elec_area
            # Overwrite current with current density
            current_den_lst[cv_name_idx] = current_den
        else:
            current_den = current_den_lst[cv_name_idx]

        ax_cv_ecsa.cla() ###### Clear plot before redraw
        volt_lst_len = len(volt_lst)
        for j in np.arange(0,volt_lst_len):
            cutval_s_ecsa_all = int(fitting_save_array[j+1,19])
            cutval_e_ecsa_all = int(fitting_save_array[j+1,20])
            ax_cv_ecsa.plot(np.array(volt_ir_lst[j][cutval_s_ecsa_all:cutval_e_ecsa_all]).T, np.array(current_den_lst[j][cutval_s_ecsa_all:cutval_e_ecsa_all]).T, '-', color='black',linewidth=2)
        
        search_mode = 'max' ######### Need new setting
        high_range_a, low_range_a, peak_volt, peak_curr, peak_real_idx = min_max_peak(search_mode, cv_size, volt, current, peak_range_ecsa, v_ln_ecsa)
        
        ax_cv_ecsa.plot((volt_compen[low_range_a],volt_compen[high_range_a]),(current_den[low_range_a],current_den[high_range_a]),"|", markersize = 10)
        
        ax_cv_ecsa.hlines(y=current_den[h_ln_ecsa], xmin=peak_volt, xmax=volt_compen[h_ln_ecsa], linewidth=2, color='r', linestyle='--')
        ax_cv_ecsa.vlines(x=peak_volt, ymin=peak_curr, ymax=current_den[h_ln_ecsa], linewidth=2, color='r', linestyle='--')

        # Switch position for fill_between and np.trapz
        # b is always larger than a
        if peak_real_idx > h_ln_ecsa:
            a = h_ln_ecsa
            b = peak_real_idx
        else:
            b = h_ln_ecsa
            a = peak_real_idx
            
        ax_cv_ecsa.fill_between(volt_compen[a:b], current_den[h_ln_ecsa],current_den[a:b],color='orange')
        ax_cv_ecsa.grid()
        ax_cv_ecsa.set_xlabel("Voltage")
        ax_cv_ecsa.set_ylabel("Current")  
        fig_agg_cv_ecsa.draw()

        volt_ecsa = volt_compen[a:b]
        curr_ecsa = current_den[a:b]

        cv_ecsa_area = abs(np.trapz(curr_ecsa,volt_ecsa))
        sq_area = (current_den[h_ln_ecsa]) * abs(volt_compen[h_ln_ecsa]-peak_volt)
        VA_area = abs(cv_ecsa_area-sq_area)
        window['VA_ecsa'].Update(f"{VA_area:e}")

    if event == 'Delete CV File':
        del current_lst[cv_name_idx]
        del current_den_lst[cv_name_idx]
        del cv_name_lst[cv_name_idx]
        del cv_path_lst[cv_name_idx]
        del cv_size_lst[cv_name_idx]
        del idx_intc_defl_lst[cv_name_idx]
        del volt_lst[cv_name_idx]
        del volt_ir_lst[cv_name_idx]           
        fitting_save_array = np.delete(fitting_save_array,1+cv_name_idx,0)
        cv_results = cv_results.drop([cv_name_idx])
        cv_results.reset_index(inplace=True)
        cv_results = cv_results.drop('index',axis=1)      
        # If the deleted data is the last in the list, when delete, the cv_name_idx must be substract to refer to data below it.
        if len(cv_name_lst)-1 < cv_name_idx: 
            cv_name_idx = cv_name_idx - 1
                
        if cv_results.empty: # If dataframe empty, just put nothing in display
            window['cv_results_dis'].Update('')
        else:
            window['cv_results_dis'].Update(cv_results.to_string(index=False))
        
        window['cv_combo_cv'].Update(values=cv_name_lst)       
        # Change Slider range
        cv_size = len(volt_lst[cv_name_idx])
        window['sl_cutval_s'].Update(range=(0,cv_size-1))
        window['sl_cutval_e'].Update(range=(0,cv_size-1))
        window['sl_jpa_lns'].Update(range=(0,cv_size-1))
        window['sl_jpa_lne'].Update(range=(0,cv_size-1))
        window['sl_jpc_lns'].Update(range=(0,cv_size-1))
        window['sl_jpc_lne'].Update(range=(0,cv_size-1))
        window['peak_range'].Update(range=(1, 100))
        window['peak_pos'].Update(range=(1, cv_size-1))
        window['trou_pos'].Update(range=(1, cv_size-1))
        window['idx_jsp0'].Update(range=(1, cv_size-1))     
        # Put slider to previous position, this is just what is shown not real value
        window['sl_cutval_s'].Update(int(fitting_save_array[cv_name_idx+1,2]))
        window['sl_cutval_e'].Update(int(fitting_save_array[cv_name_idx+1,3]))           
        window['sl_jpa_lns'].Update(int(fitting_save_array[cv_name_idx+1,4]))
        window['sl_jpa_lne'].Update(int(fitting_save_array[cv_name_idx+1,5]))
        window['sl_jpc_lns'].Update(int(fitting_save_array[cv_name_idx+1,6]))
        window['sl_jpc_lne'].Update(int(fitting_save_array[cv_name_idx+1,7]))
        window['peak_pos'].Update(int(fitting_save_array[cv_name_idx+1,8]))
        window['trou_pos'].Update(int(fitting_save_array[cv_name_idx+1,9]))
        window['peak_range'].Update(int(fitting_save_array[cv_name_idx+1,10]))
        window['ir_compen'].Update(float(fitting_save_array[cv_name_idx+1,11]))
        window['peak_mode_1'].Update(str(fitting_save_array[cv_name_idx+1,12]))
        window['peak_mode_2'].Update(str(fitting_save_array[cv_name_idx+1,13]))
        window['elec_area'].Update(float(fitting_save_array[cv_name_idx+1,14]))
        window['idx_jsp0'].Update(int(fitting_save_array[cv_name_idx+1,15]))
        window['inv_jpa_jpc'].Update(int(fitting_save_array[cv_name_idx+1,16]))
        window['scan_rate'].Update(float(fitting_save_array[cv_name_idx+1,17]))
        window['nicholson_cb'].Update(float(fitting_save_array[cv_name_idx+1,18]))
        # Put actual value             
        values['sl_cutval_s'] = cutval_s_save
        values['sl_cutval_e'] = cutval_e_save           
        values['sl_jpa_lns'] = jpa_lns_save
        values['sl_jpa_lne'] = jpa_lne_save
        values['sl_jpc_lns'] = jpc_lns_save
        values['sl_jpc_lne'] = jpc_lne_save
        values['peak_pos'] = peak_pos_save
        values['trou_pos'] = trou_pos_save
        values['peak_range'] = peak_range_save
        values['ir_compen'] = ir_compen_save
        values['peak_mode_1'] = peak_mode_1_save
        values['peak_mode_2'] = peak_mode_2_save
        values['elec_area'] = elec_area_save
        values['idx_jsp0'] = idx_jsp0_save
        values['inv_jpa_jpc'] = inv_jpa_jpc_save
        values['scan_rate'] = scan_rate_save
        values['nicholson_cb'] = nicholson_cb_save  
        if len(cv_name_lst) == 0: # If CV all delete, make combo empty and disable slider
            window['cv_combo_cv'].Update()
            disable_slider(True)
            window['Delete CV File'].Update(disabled=True) # Disable delete button if empty
            window['cv_combo_cv'].Update('')
            values['cv_combo_cv'] = ''
            continue
        elif len(cv_name_lst) >= 1:
            window['cv_combo_cv'].Update(cv_name_lst)     
            cv_select = cv_name_lst[cv_name_idx]
            window['cv_combo_cv'].Update(cv_select)
            values['cv_combo_cv'] = cv_select    



    # if event in ('inv_jpa_jpc', 'ir_compen', 'elec_area', 'sl_cutval_s', 'sl_cutval_e', 'sl_jpa_lns', 'sl_jpa_lne',  'sl_jpc_lns', 'sl_jpc_lne', 'peak_range', 'peak_pos',| 'trou_pos', 'sl_cutval_s_pos', 'sl_cutval_e_pos', 'sl_jpa_lns_pos', 'sl_jpa_lne_pos',  'sl_jpc_lns_pos', 'sl_jpc_lne_pos', 'peak_range_pos', 'peak_pos_pos', 'trou_pos_pos', 'nicholson_cb', 'idx_jsp0', 'idx_jsp0_pos', 'scan_rate', 'bulk_conc', 'elec_n', 'enable_d', 'enable_k', 'peak_mode_1', 'peak_mode_2')
    # print(cv_name_idx,cv_name_idx_old)    
    # match event:      
    #     case 'cv_open_menu' | 'cv_load_cv' | 'cv_combo_cv' | 'inv_jpa_jpc' | 'ir_compen' | 'elec_area' | 'sl_cutval_s' | 'sl_cutval_e' | 'sl_jpa_lns' | 'sl_jpa_lne' |  'sl_jpc_lns' | 'sl_jpc_lne' | 'peak_range' | 'peak_pos' | 'trou_pos' | 'sl_cutval_s_pos' | 'sl_cutval_e_pos' | 'sl_jpa_lns_pos' | 'sl_jpa_lne_pos' |  'sl_jpc_lns_pos' | 'sl_jpc_lne_pos' | 'peak_range_pos' | 'peak_pos_pos' | 'trou_pos_pos'| 'nicholson_cb' | 'idx_jsp0' | 'idx_jsp0_pos' | 'scan_rate'  | 'bulk_conc'  | 'elec_n' | 'enable_d' | 'enable_k' | 'peak_mode_1' | 'peak_mode_2' | 'cv_open_menu_ecsa' | 'cv_load_ecsa' | 'cv_combo_ecsa' | 'sl_v_ln_ecsa' | 'sl_h_ln_ecsa' | 'sl_cutval_s_ecsa' | 'sl_cutval_e_ecsa' | 'peak_range_ecsa' | 'ir_compen_ecsa' | 'sl_cutval_s_ecsa_pos' | 'sl_cutval_e_ecsa_pos' | 'sl_v_ln_ecsa_pos' | 'sl_h_ln_ecsa_pos' | 'peak_range_ecsa_pos' :

    #     case 'save_cv_param':
    #         save_cv_dir = sg.popup_get_file('', save_as=True, no_window=True, file_types=(("All TAR Files", "*.tar"), ("All Files", "*.*")))
    #         if save_cv_dir is None or save_cv_dir == '' or save_cv_dir == ():
    #             continue
    #         with tarfile.open(save_cv_dir, 'w') as tar:
    #             csv_buffer = io.BytesIO()
    #             np.savetxt(csv_buffer, fitting_save_array, delimiter=',')
    #             csv_buffer.seek(0)
    #             tarinfo = tarfile.TarInfo('cv_param'+'.csv')
    #             tarinfo.size = len(csv_buffer.getvalue())
    #             tar.addfile(tarinfo, fileobj=csv_buffer)
    #             for cv_file in cv_path_lst:
    #                 arcname = os.path.basename(cv_file)
    #                 tar.add(cv_file, arcname='cv/'+str(arcname))
    #         tar.close()
    #     case 'Delete CV File':
    #         del current_lst[cv_name_idx]
    #         del current_den_lst[cv_name_idx]
    #         del cv_name_lst[cv_name_idx]
    #         del cv_path_lst[cv_name_idx]
    #         del cv_size_lst[cv_name_idx]
    #         del idx_intc_defl_lst[cv_name_idx]
    #         del smh_volt_lst[cv_name_idx]
    #         del smh_curr_lst[cv_name_idx]
    #         del volt_lst[cv_name_idx]
    #         del volt_ir_lst[cv_name_idx]           
    #         fitting_save_array = np.delete(fitting_save_array,1+cv_name_idx,0)
    #         cv_results = cv_results.drop([cv_name_idx])
    #         cv_results.reset_index(inplace=True)
    #         cv_results = cv_results.drop('index',axis=1)
            
    #         # If the deleted data is the last in the list, when delete, the cv_name_idx must be substract to refer to data below it.
    #         if len(cv_name_lst)-1 < cv_name_idx: 
    #             cv_name_idx = cv_name_idx - 1
                    
    #         if cv_results.empty: # If dataframe empty, just put nothing in display
    #             window['cv_results_dis'].Update('')
    #         else:
    #             window['cv_results_dis'].Update(cv_results.to_string(index=False))
            
    #         window['cv_combo'].Update(values=cv_name_lst)
            
    #         if len(cv_name_lst) == 0: # If CV all delete, make combo empty and disable slider
    #             window['cv_combo'].Update()
    #             disable_slider(True)
    #             window['Delete CV File'].Update(disabled=True) # Disable delete button if empty
    #             window['cv_combo'].Update('')
    #             values['cv_combo'] = ''
    #             continue
    #         elif len(cv_name_lst) >= 1:
    #             window['cv_combo'].Update(cv_name_lst)     
    #             cv_select = cv_name_lst[cv_name_idx]
    #             window['cv_combo'].Update(cv_select)
    #             values['cv_combo'] = cv_select
    #     case 'save_cv':
    #         save_cv_loc = sg.popup_get_file('Create of choose a file (PNG) to save to', save_as=True)
    #         if save_cv_loc is None or save_cv_loc == '' or save_cv_loc == ():
    #             continue
    #         fig_cv.savefig(save_cv_loc)
    #     case 'Open battery file':
    #         bat_file_new = sg.popup_get_file('Choose battery cycle file (.xls)')
    #         # If cancel, close the window, go back to beginning
    #         # If empty, use old file
    #         if bat_file_new is None or bat_file_new == '' or bat_file_new == ():
    #             continue
    #         try:
    #             clear_battery_plot()
    #             bat_file = bat_file_new
    #             df_bat, row_size, time_df, volt_df, current_df, capacity_df, state_df = battery_xls2df(bat_file)
    
    #             # Voltage difference with current interrupt method between C_CC and R
    #             CIM_idx = search_pattern(list(state_df), ['C_CC','R'])
    #             CIM_volt_drop_lst = []
    #             for i in CIM_idx:
    #                 CIM_volt_drop = volt_df[i]-volt_df[i+1]
    #                 CIM_volt_drop_lst.append(CIM_volt_drop)              
    #             # Sequence information
    #             charge_CC_seq, discharge_CC_seq, rest_seq, charge_CV_seq, discharge_CV_seq = find_state_seq(state_df)
    #             VE_arr, CE_arr, EE_arr, charge_cap_arr, discharge_cap_arr, tot_cycle_number = get_battery_eff(row_size, time_df, volt_df, current_df, capacity_df, state_df, charge_CC_seq, discharge_CC_seq)
                
    #             VE_avg = np.average(VE_arr[0:cycle_end])
    #             CE_avg = np.average(CE_arr[0:cycle_end])
    #             EE_avg = np.average(EE_arr[0:cycle_end])
    #             charge_cap_avg = np.average(charge_cap_arr[0:cycle_end])
    #             discharge_cap_avg = np.average(discharge_cap_arr[0:cycle_end]) 
    #             #For display table
    #             df_display=pd.DataFrame([charge_cap_arr,discharge_cap_arr,VE_arr,CE_arr,EE_arr]) # Create dataframe to display in multiline output
    #             df_display=df_display.T
    #             df_display.columns = ['Charge-Capacity','Discharge-Capacity','VE', 'CE', 'EE']
    #             df_display.index = df_display.index + 1 # Start index at 1 for nice looking
                
    #             window['cycle_end'].Update(disabled=False)
    #             window['cycle_start'].Update(disabled=False)
    #             window['cb_volt'].Update(disabled=False)
    #             window['cb_current'].Update(disabled=False)
    #             window['cb_eff'].Update(disabled=False)
    #             window['cb_cap'].Update(disabled=False)
    #             window['cb_volt'].Update(True)
    #             window['cb_current'].Update(True)
    #             window['cb_eff'].Update(True)
    #             window['cycle_start'].Update(range=(0,tot_cycle_number-1))
    #             window['cycle_end'].Update(range=(1,tot_cycle_number))
    #             window['bat_file_use'].Update(bat_file)
    #             window['output_arr'].Update(df_display.to_string()) # Make sure to print all lines
    #             window['tot_cycle'].Update(tot_cycle_number) 
    #             window['output_ve'].Update(np.round(VE_avg,3))
    #             window['output_ce'].Update(np.round(CE_avg,3))
    #             window['output_ee'].Update(np.round(EE_avg,3))
                
    #             volt_line, = ax_bat_volt.plot(time_df, volt_df, '-', label='Voltage', color='blue')
    #             current_line, = ax_bat_current.plot(time_df, current_df, '--', label='Current', color='red')
                
    #             cycle_idx = (charge_CC_seq)[:,1]
    
    #             cycle_idx = cycle_idx[0:min((charge_CC_seq)[:,1].size,(discharge_CC_seq)[:,1].size)]
    #             time_cycle = time_df[cycle_idx]
    #             VE_marker, = ax_bat_eff.plot(time_df[cycle_idx], VE_arr, '*',color='blue',label='VE', markersize=8)
    #             CE_marker, = ax_bat_eff.plot(time_df[cycle_idx], CE_arr, '.',color='red',label='CE', markersize=8)
    #             EE_marker, = ax_bat_eff.plot(time_df[cycle_idx], EE_arr, '^',color='green',label='EE', markersize=4)              
    #             charge_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], charge_cap_arr, 's',color='orange',label='capacity', markersize=4)
    #             dis_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], discharge_cap_arr, 'x',color='brown',label='capacity', markersize=4)
    #             CIM_marker, = ax_bat_volt.plot(time_df[cycle_idx], np.array(CIM_volt_drop_lst)/0.65, 'o',color='blue',label='CIM', markersize=4)
                
    #             ax_bat_volt.autoscale()
    #             ax_bat_current.autoscale()
    #             ax_bat_eff.autoscale()
    #             ax_bat_cap.autoscale()
    #             # Set limit and ticks of bat_cycle
    #             # Match cycle scale to time scale and plot efficiency.
    #             cycle_plot = np.arange(0,tot_cycle_number,10)
    #             ax_bat_cycle.set_xticks(cycle_plot)
    #             ax_bat_cycle.set_xlim(left=0,right=tot_cycle_number)
                
    #             # Set limit for efficiencies
    #             ax_bat_eff.set_ylim(0,100)
                
    #             ax_bat_volt.set_xlim(left=0,right=max(time_df))
    
    #             ax_bat_cycle.grid()
    #             ax_bat_volt.grid(axis='y')
    #             fig_agg_bat.draw()
    #         except Exception as file_error:
    #             sg.popup(file_error, keep_on_top=True)
    #     case 'cb_eff':
    #         if values['cb_eff'] == False:
    #             VE_marker.remove()
    #             CE_marker.remove()
    #             EE_marker.remove()
    #         else:
    #             VE_marker, = ax_bat_eff.plot(time_df[cycle_idx], VE_arr, '*',color='blue',label='VE', markersize=8)
    #             CE_marker, = ax_bat_eff.plot(time_df[cycle_idx], CE_arr, '.',color='red',label='CE', markersize=8)
    #             EE_marker, = ax_bat_eff.plot(time_df[cycle_idx], EE_arr, '^',color='green',label='EE', markersize=4)
    #         fig_agg_bat.draw()
    #     case 'cb_cap':
    #         if values['cb_cap'] == False:
    #             charge_cap_marker.remove()
    #             dis_cap_marker.remove()
    #         else:            
    #             charge_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], charge_cap_arr, 's',color='orange',label='capacity', markersize=4)
    #             dis_cap_marker, = ax_bat_cap.plot(time_df[cycle_idx], discharge_cap_arr, 'x',color='brown',label='capacity', markersize=4)
    #         fig_agg_bat.draw()
    #     case 'cb_volt':
    #         if values['cb_volt'] == False:
    #             volt_line.remove()
    #         else:
    #             volt_line, = ax_bat_volt.plot(time_df, volt_df, '-', label='Voltage', color='blue')
    #         fig_agg_bat.draw()
    #     case 'cb_current':
    #         if values['cb_current'] == False:
    #             current_line.remove()
    #         else:
    #             current_line, = ax_bat_current.plot(time_df, current_df, '--', label='Current', color='red')
    #         fig_agg_bat.draw()
    #     case 'cycle_start' | 'cycle_end':
    #         cycle_start = int(values['cycle_start'])
            
    #         if cycle_start > cycle_end - 1:
    #             cycle_end = cycle_start + 1
    #             window['cycle_end'].Update(cycle_end)
                
    #         cycle_end = int(values['cycle_end'])
    #         if cycle_end < cycle_start + 1:
    #             cycle_start = cycle_end - 1
    #             window['cycle_start'].Update(cycle_start)
                
    #         # Do not replot, since we only change xlim.
    #         cycle_idx_range = cy_idx_state_range(state_df, cycle_start, cycle_end, charge_CC_seq, discharge_CC_seq)
    #         left_bound = time_df[cycle_idx_range][0]
    #         right_bound = time_df[cycle_idx_range][1]
            
    #        # Change number of ticks with cycle range
    #         if cycle_end-cycle_start <= 10:  
    #             cycle_plot = np.arange(0,tot_cycle_number,1)
    #         elif cycle_end-cycle_start >= 10 and cycle_end-cycle_start <= 200:  
    #             cycle_plot = np.arange(0,tot_cycle_number,10)
    #         elif cycle_end-cycle_start >= 201 and cycle_end-cycle_start <= 500:
    #             cycle_plot = np.arange(0,tot_cycle_number,20)
    #         elif cycle_end-cycle_start >= 501 and cycle_end-cycle_start <= 1000:
    #             cycle_plot = np.arange(0,tot_cycle_number,50)          
    #         elif cycle_end-cycle_start >= 1001:
    #             cycle_plot = np.arange(0,tot_cycle_number,100)                    
    #         ax_bat_cycle.set_xticks(cycle_plot)
                
    #         ax_bat_volt.set_xlim(left=left_bound,right=right_bound)
    #         ax_bat_cycle.set_xlim(left=cycle_start,right=cycle_end)
    #         ax_bat_cycle.grid()
            
    #         VE_avg = np.average(VE_arr[cycle_start:cycle_end])
    #         CE_avg = np.average(CE_arr[cycle_start:cycle_end])
    #         EE_avg = np.average(EE_arr[cycle_start:cycle_end])
    #         window['output_ve'].Update(np.round(VE_avg,3))
    #         window['output_ce'].Update(np.round(CE_avg,3))
    #         window['output_ee'].Update(np.round(EE_avg,3))
                       
    #         ax_bat_cap.set_ylim(min(charge_cap_arr[cycle_start:cycle_end]), max(charge_cap_arr[cycle_start:cycle_end]))
            
    #         fig_agg_bat.draw()
    #     case 'bat_clear':
    #         clear_battery_plot()
    #     case 'save_bat':
    #         save_bat_loc = sg.popup_get_file('Create of choose a file (PNG) to save to', save_as=True)
    #         if save_bat_loc is None:
    #             continue
    #         elif save_bat_loc == '':
    #             continue
    #         fig_cv.savefig(save_bat_loc)            

window.close()